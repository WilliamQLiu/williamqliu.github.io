---
layout: post
title: Pandas
---

## {{ page.title }}

- - - -

**Summary**

Pandas is built on top of NumPy and takes the `ndarray` a step even further into high-level data structures with `Series` and `DataFrame` objects; these data objects contain metadata like column and row names as an `index` with an `index.name`.  There are also a lot of helper functions for loading, selecting, and chunking data.  If you are using something like `SQL` for anything that goes beyond a simple query or a large dataset, its time to switch to pandas.

Pandas is similar to `R` and follows the same patterns of using the `split-apply-combine` strategy using the `groupby` method.  Melting is done through the `melt` method.

- - - -

**About Pandas**

Pandas is a high-level data structure and is built on top of NumPy.  This includes:

*  Series
    -  Creating
    -  Selecting
*  DataFrame
    -  Creating
    -  Selecting (ix, iloc)
    -  Transpose
*  Object Properties
    -  index, reindex, values
    -  dtype, astype
    -  isnull, notnull
*  Operations
    -  NumPy ufuncs
    -  Arithmetic Operations
    -  Arithmetic Methods (add, sub, div, mul)
*  Functions, Apply, Map
    -  apply
    -  map
    -  applymap)
*  Sorting, Ranking, Categorical
    -  Sorting
    -  Ranking
    -  Categorical
*  Summary Statistics
    -  describe
    -  sum, mean, cumsum, diff, skew, pct_change
    -  correlation, covariance
    -  unique values, value counts
    -  working with null and na
*  Split-Apply-Combine
    -  groupby


TODO:

*  Hierarchical Indexing
    -  Ordering and sorting levels
    -  Summary statistics by levels  
*  Combining and Merging Data
    -  merge
    -  concat
    -  combine_first
    -  stack, unstack
    -  pivot_table, pivot
    -  melt, wide_to_long
    -  get_dummies

- - - -

##Setup

Import the pandas library

    from pandas import Series, DataFrame
    import pandas as pd

- - - -

##SERIES

A **Series** is a one-dimensional array-like object containing any NumPy data type as `values` as well as data labels called the `index`.  If no index is specified, a default one is created using integers that span 0 through N-1 (where N is the length of data).

####Creating Series

    from pandas import Series
    
    obj = Series([4, 7, -5, 3])  #Simplest Series is an array
    
    #If no index specified, default index is created
    obj
    #0  4
    #1  7
    #2 -5
    #3  3
    #dtype: int64

####Selecting Series Values

You can select single values or a set of values by specifying the index within `[]`.

    obj2['a']  # Get value corresponding to obj2's index 'a'
    #-5
    
    obj2[['c', 'a', 'd']]  # Get values to this list of indexes
    #c  3
    #a -5
    #d  4
    #dtype: int64

####Dict

You can think of a Series as a fixed-length, ordered dictionary since it maps the `index` to `values`.  You can even pass in a Python dict to create a Series.

    'b' in obj2  # True
    'e' in obj2  # False
    
    # You can pass in a Python dict to create a Series
    sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000}
    obj3 = Series(sdata)
    obj3
    #Ohio     35000
    #Oregon   16000
    #Texas    71000
    #Utah      5000
    #dtype: int64

    # You can specify an index; if no matching value, then value is 'NaN'
    states = ['California', 'Ohio', 'Oregon', 'Texas']
    obj4 = Series(sdata, index=states)
    obj4
    #California   NaN  #Since we cannot find value to this index
    #Ohio       35000
    #Oregon     16000
    #Texas      71000

- - - -

##DATAFRAME

A **DataFrame** is a tabular, spreadsheet-like data structure (like Excel) and contains an ordered collection of columns, each of which can be a different value type (numeric, string, boolean, etc.).  There is both a row and column `index`.

####Creating (from a dict of lists or arrays)

    # Create a dict of equal-length lists or NumPy arrays
    data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'],
            'year': [2000, 2001, 2002, 2001, 2002],
            'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}
    df = DataFrame(data)
    
    df
    #   pop   state  year
    #0  1.5    Ohio  2000
    #1  1.7    Ohio  2001
    #2  3.6  Nevada  2001
    #3  2.4  Nevada  2001
    #4  2.9  Nevada  2002
    
    # Can specify column names, order, and index names
    df2 = DataFrame(data,
                   columns=['year', 'state', 'pop', 'debt'],
                   index=['one', 'two', 'three', 'four', 'five'])
    df2
    #       year     state   pop  debt
    #one    2000      Ohio   1.5   NaN
    #two    2001      Ohio   1.7   NaN
    #three  2002      Ohio   3.6   NaN
    #four   2001    Nevada   2.4   NaN
    #five   2002    Nevada   2.9   NaN

####columns

You can see what columns are available using `columns`.  

    df2.columns  # List all columns
    #Index([u'year', u'state', u'pop', u'debt'], dtype='object')

####Selecting Columns (using dict and attribute)

If you want to select a column, this will return a `Series`; you can do this by calling the column index as a dictionary (i.e. `[]`) or by calling the column index as an attribute (i.e. `.`).

    df2['state']  # get 'state' column using dict notation, returns Series
    #one     Ohio
    #two     Ohio
    #three   Ohio
    #four  Nevada
    #five  Nevada
    #Name: state, dtype: object
    
    df2.state  # get 'state' column using attribute notation, same as above

####Selecting Rows (ix)

With `ix`, you can select a row index by either position (e.g. `df.ix[2]`) or the `name` (say `df.ix['state']`).  Since this is built on top of NumPy, these selections are **views** (which means they are the actual values); if you want a copy, then use `copy()`.

    df2.ix['three']  # Get row with index 'three'
    #year   2002
    #state  Ohio
    #pop     3.6
    #debt    NaN
    #Name: three, dtype: object
    
    df2.ix['three']['state']  # Get value of index 'three', column 'state'
    #'Ohio'

####Selecting Rows and Columns (iloc)

You can also select rows or columns by an integer based indexing using the `iloc` method or by using `[]`; either way requires arguments for the `start`, `stop` and optionally an `interval`.

    #Select using Rows
    df2.iloc[2:4]
    #      year   state  pop  debt
    #three 2002    Ohio  3.6   NaN
    #four  2001  Nevada  2.4   NaN
    
    df2[2:4]  #same as above, but prefer to use iloc so we are explicit
    
    #Select using Columns
    df2.iloc[:, 1:3]
    #       state  pop
    #one     Ohio  1.5
    #two     Ohio  1.7
    #three   Ohio  3.6
    #four  Nevada  2.4
    #five  Nevada  2.9

####Assigning values

You can assign values similar to how you select items.  The value\'s length must match the length of the DataFrame.

    df2.ix['three']['state'] = 'California'  #Assign by row and col
    df2['debt'] = 16.5  #Assign entire col the same value
    df2['debt'] = [10, 9, 8, 7, 6]  #Assign entire col different values
    df2['debt'] = np.arange(5)  # Assign col values based on a function
    
    # Assign values with a Series; uses index to find where to put values
    val = Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
    df2['debt'] = val

####Making and Deleting columns

You can create columns by assigning them values (e.g. say `np.empty`).  You can delete columns with the `del` keyword.

    df2.columns  # See columns
    #Index([u'year', u'state', u'pop', u'debt'], dtype='object')
    
    df2['eastern'] = np.empty  # Create a new column
    df2.columns
    #Index([u'year', u'state', u'pop', u'debt', u'eastern'], dtype='object')
    
    del df2['eastern']
    df2.columns
    #Index([u'year', u'state', u'pop', u'debt'], dtype='object')

####Transposing

You can transpose a DataFrame using `T`.

    df2
    #       year   state  pop  debt
    #one    2000    Ohio  1.5   NaN
    #two    2001    Ohio  1.7  -1.2
    #three  2002    Ohio  3.6   NaN
    #four   2001  Nevada  2.4  -1.5
    #five   2002  Nevada  2.9  -1.7
    
    df2.T
    #        one   two three    four    five
    #year   2000  2001  2002    2001    2002
    #state  Ohio  Ohio  Ohio  Nevada  Nevada
    #pop     1.5   1.7   3.6     2.4     2.9
    #debt    NaN  -1.2   NaN    -1.5    -1.7



----

##OBJECT PROPERTIES

Series and DataFrame have an **index** and corresponding **values**.  The index appears on the left (accessible through `index)`) and the values are on the right (accessible through `values`).  There are also corresponding **names** (accessible through the `name` attribute).

##index

Indexes are **immutable** (can\'t be modified); the main thing to know is that later we will go into different types of indexes, including `DatetimeIndex`, which gives more functions for working with datetimes.  

    obj = Series([4, 7, -5, 3])  # Series without specifying index
    obj.index  #Int64Index([0, 1, 2, 3], dtype='int64')
    
    #Series with a specified index
    obj2 = Series([4, 7, -5, 3], index=['d', 'b', 'a', 'c'])
    obj2
    #d  4
    #b  7
    #a -5
    #c  3
    #dtype: int64

Some useful index methods and properties are:

*  `append` concatenates with additional Index objects making a new Index
*  `diff` gets the difference
*  `intersection` gets the intersection
*  `union` gets the union
*  `isin` creates boolean array indicating if each value in passed collection
*  `delete` removes the element at this index
*  `drop` deletes the passed value
*  `insert` adds a new element at this index
*  `is_unique` returns `True` if Index has no duplicate values
*  `unique` computes the array of unique values in the Index

####name

Series, DataFrame, and indexes have a **name** attribute.  This allows you to get and set indexes easier.

    obj2.name = 'Inches of Rain'  # name for Series
    obj2.index.name = 'state'  # name for index
    
    obj2
    #state
    #d    4
    #b    7
    #a   -5
    #c    3
    #Name: Inches of Rain, dtype: int64

####index.is_unique

    df.index.is_unique  #True

####index.intersection

    s1 = Series([10, 20, 30], index=[1, 2, 3])
    s2 = Series([40, 50, 60], index=[1, 2, 4])
    temp = s1.index.intersection(s2.index)
    temp
    #Int64Index([1, 2], dtype='int64')

####index.drop

You can drop entries from an axis

    obj = Series([4.5, 7.2, -5.3, 3.6], index= ['d', 'b', 'a', 'c'])
    new_obj = obj.drop(['d', 'a'])
    new_obj
    #b   7.2
    #c   3.6
    #dtype: float64
    

##reindex

**Reindex** creates a new object with the data conformed to the new index, even if there are no index values present.  For a scalar value, you can specify a `fill_value` (e.g. `0`), otherwise the default is a `NaN`.  You can also specify `method` to fill (e.g. `ffill` to  fill values forward).  To reindex columns, go see the `ix` method.

####reindex

    obj = Series([4.5, 7.2, -5.3, 3.6], index= ['d', 'b', 'a', 'c'])
    
    obj
    #d   4.5
    #b   7.2
    #a  -5.3
    #c   3.6
    #dtype: float64

####reindex (fill_value)

    obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'], fill_value=0)
    obj2
    #a  -5.3
    #b   7.2
    #c   3.6
    #d   4.5
    #e     0
    #dtype: float64

####reindex (method)

    obj3 = Series(['blue', 'green', 'yellow'], index=[0, 2, 4])
    obj3.reindex(range(6), method='ffill')
    obj3
    #0      blue
    #1      blue
    #2     green
    #3     green
    #4    yellow
    #5    yellow
    #dtype: object

##dtype, astype

Pandas uses many of the same `dtype` as NumPy, but there are additional types like `dtype=category`.  You can also forcefully assign type with the `astype` method.

    s = Series(['a', 'b', 'c', 'd', 'a', 'b'], dtype='category')
    s.dtypes # category

    df = DataFrame({'A': ['a', 'b', 'c', 'a'],
                    'B': ['z', 'z', 'y', 'd']})
    df.dtypes
    #A   object
    #B   object
    
    df['C'] = df['A'].astype('category')
    df.dtypes
    #A   object
    #B   object
    #C category

- - - -

####values

Values are always returned as a 2D `ndarray` and the `dtype` will be automatically chosen to match objects.

    obj = Series([4, 7, -5, 3])  #Simplest Series is an array
    obj.values  #array([ 4,  7, -5,  3])


####Missing Values (isnull, notnull)

A `NaN` or `NA` is returned if a value cannot be found (i.e. a missing value).  You can search your data for these missing values using `isnull` and `notnull` functions.

    pd.isnull(obj4)
    #California    True
    #Ohio         False
    #Oregon       False
    #Texas        False
    #dtype: bool

    pd.notnull(obj4)
    #California   False
    #Ohio          True
    #Oregon        True
    #Texas         True
    #dtype: bool

- - - -

##NUMERICAL OPERATIONS

####NumPy Operations

You can apply NumPy array operations (e.g. filtering, scalar multiplication, applying math functions) to our Series and DataFrames.

    obj2  # Setup Series
    #d  4
    #b  7
    #a -5
    c   3
    
    obj2[obj2 > 0]  # Filtering
    obj2
    #d  4
    #b  7
    #c  3
    #dtype: int64
    
    obj2 * 2  # Scalar Multiplication
    #d   8
    #b  14
    #a -10
    #c   6
    #dtype: int64
    
    np.sqrt(obj2)  # Apply ufunc
    #d  2.00000
    #b  2.64751
    #a      NaN
    #c  1.73205
    #dtype: float64

####Basic Arithmetic

One of the advantages of pandas is that data is automatically aligned on the index.  For example, even though obj4 has the index 'California' that obj3 does not have, we can still do arithmetic.

    obj3
    #Ohio    35000
    #Oregon  16000
    #Texas   71000
    #Utah     5000
    #dtype: int 64

    obj4
    #California   NaN
    #Ohio       35000
    #Oregon     16000
    #Texas      71000

    obj3 + obj4
    #California   NaN
    #Ohio       70000
    #Oregon     32000
    #Texas     142000
    #Utah         NaN
    #dtype: float64

####Arithmetic Methods

You can apply arithmetic methods between Series and DataFrame objects.  These methods let you send in additional arguments (like `fill_value`, `axis`)

*  `add` is the method for addition (+)
*  `sub` is the method for subtraction (-)
*  `div` is the method for division (/)
*  `mul` is the method for multiplication (*)

####add

Add together two DataFrames results in NA values in the locations that do not overlap.

    df1 = DataFrame(np.arange(12).reshape((3, 4)), columns=['a', 'b', 'c', 'd'])
    df2 = DataFrame(np.arange(20).reshape((4,5)), columns=['a', 'b', 'c', 'd', 'e'])
    
    df1
    #   a  b   c   d
    #0  0  1   2   3
    #1  4  5   6   7
    #2  8  9  10  11
    
    df2
    #    a   b   c   d   e
    #0   0   1   2   3   4
    #1   5   6   7   8   9
    #2  10  11  12  13  14
    #3  15  16  17  18  19

    df1 + df2
    #    a   b   c   d   e
    #0   0   2   4   6 NaN
    #1   9  11  13  15 NaN
    #2  18  20  22  24 NaN
    #3 NaN NaN NaN NaN NaN

    df1.add(df2, fill_value=0)  # using method allows fill_value
         a   b   c   d   e
    #0   0   2   4   6   4
    #1   9  11  13  15   9
    #2  18  20  22  24  14
    #3  15  16  17  18  19

----

##FUNCTIONS, APPLY, AND MAP

You can apply NumPy\'s **ufuncs** (element-wise array methods) on Pandas objects.  For example, we apply `np.abs` onto a DataFrame.

    df = DataFrame(np.random.randn(4, 3), columns=['a', 'b', 'c'],
                   index=['Utah', 'Ohio', 'Texas', 'Oregon'])
    df
    #               a         b         c
    #Utah    1.167988 -0.837221 -2.029371
    #Ohio   -0.727655  0.319954 -1.632084
    #Texas   0.752019 -0.417954 -1.139173
    #Oregon  0.108305 -0.588943  0.073157
    
    np.abs(df)
    #               a         b         c
    #Utah    1.167988  0.837221  2.029371
    #Ohio    0.727655  0.319954  1.632084
    #Texas   0.752019  0.417954  1.139173
    #Oregon  0.108305  0.588943  0.073157

####apply

Besides the ufuncs above, you can apply your own custom function to a column or row by using the DataFrame `apply` method.  You do not have to return a scalar value; you can also return a Series with multiple values.

    my_func = lambda x: x.max() - x.min()
    
    df.apply(my_func, axis=0)  #Default, on y axis
    #a    1.895643
    #b    1.157175
    #c    2.102528
    #dtype: float64
    
    df.apply(my_func, axis=1)  #on x axis
    #Utah      3.197359
    #Ohio      1.952038
    #Texas     1.891192
    #Oregon    0.697248
    #dtype: float64
    
    # You do not have to return a scalar value
    def my_func(x):
        return Series([x.min(), x.max()], index=['min', 'max'])
    df.apply(my_func)
    #            a         b         c
    #min -0.727655 -0.837221 -2.029371
    #max  1.167988  0.319954  0.073157

##map, applymap

If you do not want to apply based on the axis (i.e. column or row), you can instead apply your own functions across every element.  If this is a Series, then you use `map`.  If this is a DataFrame, then use `applymap`.

####map

    #For Series, use map
    my_format = lambda x: '%.2f' % x  #2 decimal places
    df['c'].map(my_format)
    #Utah      -2.03
    #Ohio      -1.63
    #Texas     -1.14
    #Oregon     0.07
    #Name: c, dtype: object

####applymap

    #For DataFrames, use applymap
    my_format = lambda x: '%.2f' % x  #2 decimal places
    df.applymap(my_format)
    df
    #            a      b      c
    #Utah     1.17  -0.84  -2.03
    #Ohio    -0.73   0.32  -1.63
    #Texas    0.75  -0.42  -1.14
    #Oregon   0.11  -0.59   0.07

----

##Sorting

You may want to sort by some criteria, either the index or the value.  To sort based on the index, use the `sort_index` method.  To sort by value, you use `order` method for a Series and for DataFrames you pass in parameter(s) to the argument `by`.

####Sort and Order with Series

For a Series, use `sort_index` to sort by index, `order` to sort by value.  You do not need to specify an axis since it is just an array.  You can pass in additional parameters like a boolean value for `ascending`

    obj = Series(range(4), index=['d', 'a', 'b', 'c'])
    obj
    #d    0
    #a    1
    #b    2
    #c    3
    #dtype: int64    
    
    obj.sort_index(ascending=True)  #sort by index
    obj
    #a    1
    #b    2
    #c    3
    #d    0
    #dtype: int64
    
    obj.order()  #sort by value
    #d    0
    #a    1
    #b    2
    #c    3
    #dtype: int64

####Sort and Order with DataFrame

For a DataFrame, you use `sort_index` for both sorting by index (where you can specify which axis to sort) or by values.  You can pass in additional parameters like a boolean value for `ascending`, what to do with `NaN` with `na_position`, or multiple columns to sort with `by`.

    df = DataFrame({'Song': ['Hey Jude', 'Help!', 'Do it', 'Let it be'],
    'Weeks': [24, 7, 2, 90], 'Plays': [20, 10, 1, 1]}, index=[3, 2, 4, 1])
    df
    #   Plays       Song  Weeks
    #3     20   Hey Jude     24
    #2     10      Help!      7
    #4      1      Do it      2
    #1      1  Let it be     90
    
    df.sort_index(axis=0, ascending=True)  # sort index on x axis (default)
    #   Plays       Song  Weeks
    #1      1  Let it be     90
    #2     10      Help!      7
    #3     20   Hey Jude     24
    #4      1      Do it      2
    
    df.sort_index(by=['Plays', 'Weeks'], ascending=[True, True])
    #   Plays       Song  Weeks
    #4      1      Do it      2
    #1      1  Let it be     90
    #2     10      Help!      7
    #3     20   Hey Jude     24

##Ranking

You can assign ranks from one through the number of valid data points.  This is useful for statistical methods.  By default, the `rank` method breaks ties by assigning each group the mean rank.  You can specify additional parameters like `ascending` and `method`.

    obj = Series([7, -5, 7, 4, 2, 0, 4])
    obj
    #0    7
    #1   -5
    #2    7
    #3    4
    #4    2
    #5    0
    #6    4
    
    obj.rank(ascending=True)
    #0    6.5
    #1    1.0
    #2    6.5
    #3    4.5
    #4    3.0
    #5    2.0

##Categories

There is a `pandas.Categorical` object that you can assign to a Series or DataFrame.  You pass in the categories as well as an optional boolean value to `Ordered`.  You can rename categories using `Categorical.rename_categories()` method.  To convert back to another type (say int), use `astype` method.

    my_choices = pd.Categorical(['Like', 'Like', 'Hate', 'Neutral'],
                                     categories=['Like', 'Neutral', 'Hate'],
                                     ordered=True)
    my_choices
    #[Like, Like, Hate, Neutral]
    #Categories (3, object): [Like < Neutral < Hate]

####categorical.add_cateogires(), categorical.remove_categories()

    my_choices = my_choices.add_categories(['Really Hate', 'Really Like', 'NA'])
    my_choices = my_choices.remove_categories(['NA'])
    my_choices
    #[Like, Like, Hate, Neutral]
    #Categories (5, object): [Like < Neutral < Hate < Really Hate < Really Like]

####categorical.reorder_categories()

    my_choices = my_choices.reorder_categories(['Really Hate', 'Hate', 
                                                'Neutral', 'Like', 'Really Like'])
    my_choices
    #[Like, Like, Hate, Neutral]
    #Categories (5, object): [Really Hate < Hate < Neutral < Like < Really Like]

####categorical.rename_categores()

    num_choices = my_choices.rename_categories([1, 2, 3, 4, 5])
    num_choices
    #[4, 4, 2, 3]
    #Categories (5, int64): [1 < 2 < 3 < 4 < 5]

----

##SUMMARY STATISTICS

Pandas has a lot of summary statistics as methods.  They include:

*  `count` counts the number of non-NA values
*  `describe` gives summary statistics
*  `min`, `max` calculates the minimum and maximum values
*  `quantile` calculates the quantile value (enter value ranging from 0 to 1)
*  `sum` calculates the sum
*  `mean` is the mean of values
*  `median` is the arithmetic median (50% quantile) of values
*  `mad` is the mean absolute deviation from mean value
*  `var` is the sample variance of values
*  `std` is the sample standard deviation of values
*  `skew` get the skew
*  `kurt` get the kurtosis
*  `cumsum` get the cumulative sum
*  `cumproduct` get the cumulative product
*  `diff` get the difference
*  `pct_change` get the percent change

####sum

    df = DataFrame({ 'Item': ['Hat', 'Sword', 'Armor', 'Shoes'],
                 'New_Price': [7, 35, 35, 10],
                 'Old_Price': [9, 30, 35, 15],
                 'Available': [1, 1, np.nan, np.nan]})
    df
    #   Available   Item  New_Price  Old_Price
    #0          1    Hat          7          9
    #1          1  Sword         35         30
    #2        NaN  Armor         35         35
    #3        NaN  Shoes         10         15
    
    df.sum(axis=0)  #default, sums up by columns
    #Available                     2
    #Item         HatSwordArmorShoes
    #New_Price                    87
    #Old_Price                    89
    #dtype: object
    
    df[['New_Price', 'Old_Price']].sum(axis=1)  #filter columns, sum rows
    #0    16
    #1    65
    #2    70
    #3    25

####describe

Gives summary statistics about the dataset.

           Available  New_Price  Old_Price
    count          2   4.000000   4.000000
    mean           1  21.750000  22.250000
    std            0  15.348724  12.257651
    min            1   7.000000   9.000000
    25%            1   9.250000  13.500000
    50%            1  22.500000  22.500000
    75%            1  35.000000  31.250000
    max            1  35.000000  35.000000

####quantile

Gives the quantile ranging from 0 to 1.

    df.quantile(.75)
    #Available     1.00
    #New_Price    35.00
    #Old_Price    31.25
    #dtype: float64

####var

Get the variance.

    df.var()
    #Available      0.000000
    #New_Price    235.583333
    #Old_Price    150.250000
    #dtype: float64

####std

Get the standard deviation of the value.

    df.std()
    #Available     0.000000
    #New_Price    15.348724
    #Old_Price    12.257651
    #dtyp#e: float64

----

##Correlation, Covariance

**Correlation** and **Covariance** is computed from pairs of arguments.  For correlation, use `corr()` (or `corrwith` method to compute pairwise correlations) and for covariance use `cov()`

    temp = Series([14.2, 16.4, 11.9, 15.2, 18.5, 22.1, 19.4, 25.1, 23.4, 18.1, 22.6, 17.2])
    ice_sales = Series([215, 325, 185, 332, 406, 522, 412, 614, 544, 421, 445, 408])
    df = DataFrame({ 'Temp': temp, 'Sales': ice_sales})
    
    df.cov()  #covariance
    #              Sales        Temp
    #Sales  15886.810606  484.093182
    #Temp     484.093182   16.089318
    
    df.corr()  #correlation with all variables (i.e. correlation matrix)
    #          Sales      Temp
    #Sales  1.000000  0.957507
    #Temp   0.957507  1.000000
    
    df.corrwith(temp)  #correlations with column 'temp'
    #Sales    0.957507
    #Temp     1.000000
    #dtype: float64

##Unique Values, Value Counts, isin

In a one-dimensional Series, you can get the unique objects using the `unique` method.  You can get the number of times an item occurs with the `value_counts` method.  You can also see if a value is in a passed sequence with `isin`.

    obj = Series(['c', 'a', 'd', 'a', 'a', 'b', 'b', 'c', 'c'])
    
    obj.unique()
    #array(['c', 'a', 'd', 'b'], dtype=object)
    
    obj.value_counts()
    
    obj.isin(['a','e'])  #usually can use this as a mask
    #0    False
    #1     True
    #2    False
    #3     True
    #4     True
    #5    False
    #6    False
    #7    False
    #8    False

##Missing Data

There are a few ways that you can deal with missing data, which appears as `np.nan` and Python\'s `None` data type.  Methods include:

*  `dropna` allows you to drop rows or columns based on missing values
*  `fillna` allows you to interpolate (i.e. fill in some value)
*  `isnull` returns boolean values indicating if missing or `np.nan` 
*  `notnull` is the negation of `isnull`

####dropna

**dropna** removes any values that are missing or `np.nan`.  You can specify `how` (e.g. `how=all` means to drop only the rows whose values are all `np.nan`; by default this drops the values if there is at least one `np.nan` or missing value).  You can specify the axis with `axis`.  You can also specify a `thresh` argument (i.e. keep only if there is a certain number of observations)

    #Series dropna
    data = Series([1, np.nan, 3.5, np.nan, 7])
    data.dropna()
    #0    1.0
    #2    3.5
    #4    7.0
    
    #DataFrame dropna
    data = DataFrame([[1., 6.5, 3., 2.4, 3],
                     [1., np.nan, np.nan, 3, np.nan],
                     [np.nan, np.nan, np.nan, np.nan, np.nan],
                     [np.nan, 2.3, 4.3, 2.1, np.nan]])
    data
    #    0    1    2    3   4
    #0   1  6.5  3.0  2.4   3
    #1   1  NaN  NaN  3.0 NaN
    #2 NaN  NaN  NaN  NaN NaN
    #3 NaN  2.3  4.3  2.1 NaN
    
    cleaned = data.dropna()
    #   0    1  2    3  4
    #0  1  6.5  3  2.4  3
    
    cleaned = data.dropna(how='all')
    #    0    1    2    3   4
    #0   1  6.5  3.0  2.4   3
    #1   1  NaN  NaN  3.0 NaN
    #3 NaN  2.3  4.3  2.1 NaN
    
    cleaned = data.dropna(axis=1)
    #Empty DataFrame
    #Columns: []
    #Index: [0, 1, 2, 3]
    
    data.dropna(thresh=2)  # needs at least 2 observations
    #    0    1    2    3   4
    #0   1  6.5  3.0  2.4   3
    #1   1  NaN  NaN  3.0 NaN
    #3 NaN  2.3  4.3  2.1 NaN

####fillna

**fillna** lets you interpolate values (i.e. fill in missing values with something).  You can specify the `axis`, `method`, `value` (i.e. a scalar or dict), `limit` (maximum number of consecutive periods to fill), and if `inplace`.

    data2 = DataFrame({ 'Month': np.arange(12),
                        'People': [1001, 1021, 1050, 1071, np.nan, np.nan, 
                        np.nan, 990, np.nan, 990, np.nan, 723],
                        'Cars': [np.nan, 432, np.nan, 322, 423, np.nan, 
                        924, 432, 468, 568, 433, 323]})
    data2.fillna(0)  # fill np.nan with scalar value
    #    Cars  Month  People
    #0      0      0    1001
    #1    432      1    1021
    #2      0      2    1050
    #3    322      3    1071
    #4    423      4       0
    #5      0      5       0
    #6    924      6       0
    #7    432      7     990
    #8    468      8       0
    #9    568      9     990
    #10   433     10       0
    #11   323     11     723
    
    data2.fillna({'Cars': -1, 'People': -5})  # Specify dict for fill
    #    Cars  Month  People
    #0     -1      0    1001
    #1    432      1    1021
    #2     -1      2    1050
    #3    322      3    1071
    #4    423      4      -5
    #5     -1      5      -5
    #6    924      6      -5
    #7    432      7     990
    #8    468      8      -5
    #9    568      9     990
    #10   433     10      -5
    #11   323     11     723

----

##Split-Apply-Combine (i.e. groupby)

**split-apply-combine** is a process for group operations.  This involes:

1.  Take data in a pandas object (Series, DataFrame) and **split** it into groups based on one or more keys.
2.  A function is **applied** to each group, producing a new value (e.g. sum up the values from each group)
3.  The results of all these function applications are **combined** into a result object.  The type of object returned depends on the previous operations.

####groupby

**groupby** accomplishes the first step of the split-apply-combine method; it splits the data into multiple groups and return a grouped object (which can be a `SeriesGroupBy` or `DataFrameGroupBy`).  Say we want to **split** by the key (e.g. `key2`) and we are interested in the value (`data1`), **apply** a function (e.g. `mean` method), and return this as a **combined** result.

    df = DataFrame({'key1': ['a', 'a', 'b', 'b', 'a'],
                    'key2': ['one', 'two', 'one', 'two', 'one'],
                    'data1': np.random.randn(5),
                    'data2': np.random.randn(5)})
    df
    #      data1     data2 key1 key2
    #0 -0.238342 -0.592247    a  one
    #1  0.187521  1.524641    a  two
    #2 -1.926102 -1.110540    b  one
    #3 -1.183664  0.211620    b  two
    #4 -0.519853 -0.754792    a  one
    
    #Step 1 of split-apply-combine; split data with key and value
    grouped = df['data1'].groupby(df['key1'])
    #<pandas.core.groupby.SeriesGroupBy object at 0x107638c90>
    
    #Step 2 of split-apply-combine; apply a function
    grouped.mean()
    #key1
    #a   -0.190224
    #b   -1.554883
    #Name: data1, dtype: float64
    
    #Step 3 of split-apply-combine; result is a Series
    type(grouped.mean())
    #<class 'pandas.core.series.Series'>

Usually the data you work with is in the same dataframe so you can just specify the columns to pass in as the group keys.  If you want to group by multiple levels, pass in a list.

    df.groupby('key1').mean()  # single key
    #         data1     data2
    #key1
    #a    -0.190224  0.059201
    #b    -1.554883 -0.449460
    
    df.groupby(['key1', 'key2']).mean()  # multiple keys
    #key1 key2
    #a    one  -0.379097 -0.673520
    #     two   0.187521  1.524641
    #b    one  -1.926102 -1.110540
    #     two  -1.183664  0.211620

####GroupBy using the index

You can index columns as another way of saying "select these columns" for aggregation.

    #SeriesGroupBy object
    df.groupby('key1')['data2']  # df['data2'].groupby(df['key1'])
    #<pandas.core.groupby.SeriesGroupBy object at 0x1076815d0>
    
    #DataFrameGroupBy object
    df.groupby('key1')[['data2']]  # df[['data2']].groupby(df['key1'])
    #<pandas.core.groupby.DataFrameGroupBy object at 0x107666490>
    
    #Get the means for just 'data2' column grouped by the keys, calculate mean
    df.groupby(['key1', 'key2'])[['data2']].mean()
    #              data2
    #key1 key2
    #a    one  -0.673520
    #     two   1.524641
    #b    one  -1.110540
    #     two   0.211620

####size

With a GroupBy object, you can count the number of occurrences using **size**, which is useful for categoricals.
    
    df.groupby(['key1', 'key2']).size()  # count number of occurrences
    #key1  key2
    #a     one     2
    #      two     1
    #b     one     1
    #      two     1
    #dtype: int64

####GroupBy iteration

You can iterate over a GroupBy object to return a sequence of 2-tuples containing the group name along with the chunk of data.

    #Iterate with a single key
    for name, group in df.groupby('key1'):
        print name  #a, b
        print group  #data1, data2, key1, key2
    
    #a
    #      data1     data2 key1 key2
    #0 -0.238342 -0.592247    a  one
    #1  0.187521  1.524641    a  two
    #4 -0.519853 -0.754792    a  one
    #b
    #      data1    data2 key1 key2
    #2 -1.926102 -1.11054    b  one
    #3 -1.183664  0.21162    b  two
    
    #Iterate with multiple keys
    for (k1, k2), group in df.groupby(['key1', 'key2']):
        print k1, k2  #(a, one), (a, two), (b, one), (b, two)
        print group  #data1, data2, key1, key2
    #a one
    #      data1     data2 key1 key2
    #0 -0.238342 -0.592247    a  one
    #4 -0.519853 -0.754792    a  one
    #a two
    #      data1     data2 key1 key2
    #1  0.187521  1.524641    a  two
    #b one
    #      data1    data2 key1 key2
    #2 -1.926102 -1.11054    b  one
    #b two
    #      data1    data2 key1 key2
    #3 -1.183664  0.21162    b  two
    
    #Compute a dict with the pieces of data
    pieces = dict(list(df.groupby('key1')))
    pieces['b']
    #      data1    data2 key1 key2
    #2 -1.926102 -1.11054    b  one
    #3 -1.183664  0.21162    b  two
    type(pieces['b'])
    #<class 'pandas.core.frame.DataFrame'>

