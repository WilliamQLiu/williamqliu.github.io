---
layout: post
title: Representational State Transfer (REST)
---

## {{ page.title }}

- - - -

##Summary

_Representational State Transfer (REST)_ is a software architecture style that relies on a stateless, client-server, cacheable communications protocol.  The idea is that client-server is separated for portability of code and ability to scale web services.  REST basically exposes application data through an API and with a web framework like django, it's easy to use django-rest-framework to implement a RESTful API.

##Commands

REST systems communicate over Hypertext Transfer Protocol (https) and uses the following commands to retrieve and send data.

* __GET__
    - Read an existing resource.  This is like `SELECT` in SQL
* __HEAD__
    - Similar to GET except server doesn't return a message-body in response. Instead, it gets only the metadata of an existing resource.
* __POST__
    - Creates a new resource.  This is like `INSERT` in SQL
* __PUT__
    - Updates an existing resource.  This is like `UPDATE` in SQL
* __PATCH__
    - Usually not implemented.  Updates part of an existing resource.  This is like `UPDATE` in SQL
* __DELETE__
    - Deletes an existing resource.  This is like `DELETE` in SQL

##Important HTTP Status Codes

* __200 OK__ means Success
    - GET returns resource
    - PUT provides status message or returns message
* __201 Created__ means Success
    - POST provides status message or returns newly created resource
* __204 No Content__ means Success
    - Completed, but nothing to return (because of no content)
* __304 Unchanged__ means Redirect
    - There's no changes since the last request (usually used to checking a field like 'Last-Modified' and 'Etag' headers, which is a mechanism for web cache validation)
* __400 Bad Request__ means Failure
    - PUT returns error message, including form validation errors
    - POST returns error message, including form validation errors
* __401 Unauthorized__ means Failure
    - Authentication required but user did not provide credentials
* __403 Forbidden__ means Failure
    - User attempted to access restricted content
* __404 Not Found__ means Failure
    - Resource was not found
* __405 Method Not Allowed__ means Failure
    - An invalid HTTP method was attempted
* __410 Gone__ means Failure
    - A method was attempted that is no longer supported.  E.g. mobile apps can test for this condition and if it occurs, tell the user to upgrade
* __500 Internal Server Error__ means Failure
    - The server encountered an unexpected condition

####Sample API URLs

* api/v1/resume
    - for GET and POST
* api/v1/resume/:slug/
    - for GET, PUT, DELETE
* api/v1/job
    - for GET and POST
* api/v1/job/:slug/
    - for GET, PUT, DELETE
* Same goes for say api/v1/education and api/v1/experience
* slug represents a variable (e.g. the resume id)

####Rate limiting

It is standard practice to rate limit access to an API.  At a minimum, include these headers.

* `X-Rate-Limit-Limit` - the number of allowed requests in the current period
* `X-Rate-Limit-Remaining` - the number of remaining requests in the current period
* `X-Rate-Limit-Reset` - the number of seconds left in the current period.  Note: do not use a UNIX timestamp (seconds since epoch) for this field.


####Considerations when making a RESTful API

* Version the API
    - If the API is still being used by someone, it doesn't force them to update their code.
    - Even if you think there's only going to be one version, someone will probably ask for version 2 so just put `/api/v1/` instead of just `/api/`
* Each state should have all the information necessary
    - Don't create just a direct link between resources and the model because this fails when you want to return a denormalized model.  
    - For example, `{'resume': 'will', education: [1, 2, 3]}` should be `{'resume': 'will', education: [ 'api/v1/education/1', 'api/v1/education/2', 'api/v1/education/3' ]}`
    - If we use the first example we don't know how to construct the url for education (we only have 1, 2, 3).
    - If we use the latter example we have the complete web URL
* Don't hardcode the format
    - For example, `?format=JSON, ?format=XML` allows you to specify the format; the output format should be determined from the HTTP 'Accept' header
* Consistent Naming (Plural or singular)
    - I think either is fine (as long as it's consistent) or go with whatever your company has already.  Some say use plural because lots of file structures are setup that way (e.g. Program Files in Windows).  Some say use singular because that's how database table names work.
* Documentation - Always have good public documentation.
    - My favorite so far is the stripe api.  Codecademy also has a list of API lessons where you can learn how to use the 'requests' library to interface with them.
* Security - Make all API requests over HTTPS (which is HTTP over SSL) for security purposes
    - People might be accessing the API through a coffee shop or airport wifi that isn't secure and the communication isn't encrypted.  Someone can eavesdrop or impersonate someone if the credentials are openly accessible
