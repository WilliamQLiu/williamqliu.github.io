---
layout: post
title: Backbone.js 
---

## {{ page.title }}

- - - -

##Table of Contents

*  [Summary](#summary)
*  [Dependencies](#dependencies)
*  [Models](#models)
  -  [Validating Models](#modelsvalidate)
  -  [Model id, cid, idAttribute](#modelsid)
*  [Collections](#collections)
  -  [Collections (get, set)](#collectionsgetset)
  -  [Collections (multiple Models)](#collectionsmultiple)
  -  [Collections Underscore functions](#collectionsunderscore)
*  [Events Mixin](#events)
*  [Views](#views)
  -  [el](#viewsel)
  -  [initialize](#viewsinitialize)
  -  [render](#viewsrender)
  -  [events](#viewsevents)
  -  [template](#viewstemplate)
*  [Routing with URLs](#routers)
*  [Non JS Template](#nonjstemplate)
*  [Hello World Example](#hwexample)
   [1. Create View with initialize](#hwview)
   [2. Bind DOM events to View methods](#hwevent)
   [3. Models and Collections](#hwmodelcollection)
   [4. Delegate Model to View](#hwmodelview)
   [5. Create Model Actions](#hwmodelaction)
*  [API Integration](#apiintegration)

##<a id="summary">Summary</a>

__Backbone.js__ is a JavaScript MV* for front-end web development.  It's basically a huge step up from pulling and pushing data (e.g. pull with AJAX GET, push with WebSockets using a persistent connection between client and server) to manipulate data (where you previously would have to write the glue code that looks at the DOM, finds an element with a specific id, and update the HTML manually).  Backbone is pre-configured to sync with a RESTful API and is great for building single page applications (don't have to wait for entire page to reload for every time we change the underlying data).

Note: For back-end/server stuff, Django is mainly a synchronous framework (a request goes in, we wait while the server computes stuff, then a response goes out).  If you need a persistent connection, change your back-end server to something like Tornado or Twisted (which complicates projects because of connections breaking).

The idea behind Backbone is that you represent your data with __Models__, which can be created, validated, destroyed, and saved to the server.  When a UI action causes an attribute to change, the model triggers a 'change' event.  The change event notifies the __Views__ that display the model's state and are able to respond accordingly by re-rendering themselves with the new information.

Backbone is a minimal way of separating business logic from user interface:

*  Data Structure
    -  Models (orchestrates data and business logic, loads and saves from server, emits events when data changes)
    -  Collections (a group of related models)
*  User Interface
    -  Views (listens for changes from events and renders UI, handles user input and interactivity, sends captured input to the model)
    -  Routing with URLs

##<a id="dependencies">Dependencies</a>

Backbone has a fixed dependency on __Underscore.js__ to help with filtering and sorting data.  Backbone uses __jQuery__ for manipulating the Document Object Model (DOM).

##<a id="models">Models</a>

Models contain interactive data and logic such as getters, setters, data initialization, and data validation.  Properties are dynamic (can be created on the spot) and don't have a specific type associated with it.

    var app = {};  // Create namespace for our app
    
    app.Todo = Backbone.Model.extend({
      defaults: {
          title: '',
          completed: false
      }
    });

To test Models in Chrome, you can go to the Console and do:

1. `var todo = new app.Todo({title: 'Learn Backbone.js', completed: false});`
2. `todo.get('title');` returns `"Learn Backbone.js"`
3. `todo.set('created_at', Date());` create a new object
4. `todo.get('created_at')` returns 'Tue Aug 11 2015'

####<a id="modelsvalidate">Models (validate)</a>

Backbone has model validation using `model.validate()`, which checks the attribute values before setting them.  By default, this occurs during a `save()` method or when `set()` is called if `{validate: true}` is passed as an argument.

    var Person = new Backbone.Model({name: 'Will'});
    
    // Validate the model name
    Person.validate = function(attrs) {
      if (!attrs.name) {
        return 'I need a name';
      }
    };
    
    // Change the name
    Person.set({name: 'Laura'});
    console.log(Person.get('name'));  // 'Laura'
    
    // Remove the name attribute, force validation
    Person.unset('name', {validate: true});  // false

####<a id="modelsid">Models (id, cid, idAttribute)</a>

When you exchange data between the client and the server, you need a way to uniquely identify models.  In Backbone, we have the `id`, `cid`, and `idAttribute` properties.

-  Each model has an `id`, a unique identifier that is either an integer or a string (e.g. a UUID).
-  Each model also has a client id `cid`, which is automatically generated by Backbone when the model is created.
-  You can use either the `id` or the `cid` to retrieve a model from a collection.  The difference is that the `cid` is generated by Backbone, which is helpful when you don't have a true id yet (e.g. if your model hasn't been saved to the server or you aren't saving it to a database).
-  The `idAttribute` is the id from the server (i.e. the `id` in your database).  This is like a mapper.  By default, it assumes `id`.

##<a id="collections">Collections</a>

Collections are ordered sets of models.  You can get and set models in the collection, listen for events when any element in the collection changes, and fetch data from the server and save the model's data to the database.  Collections require a reference, usually a __url__ parameter where the model's resource is located on the server (e.g. on an API).  If you want to work with local files, you can use the backbone.localStorage-min.js file.

    app.TodoList = Backbone.Collection.extend({
      model: app.Todo,
      localStorage: new Store("backbone-todo")
    });
    app.todoList = new app.TodoList();  // instance of the Collection

To test Collections in Chrome, you can go to the Console and do:

1. `var todoList = new app.TodoList()`
2. `todoList.create({title: 'Learn Backbone\s Collection'});`
3. `var lmodel = new app.Todo({title: 'Learn Models', completed: true});`
4. `todoList.add(lmodel);`
5. `todoList.pluck('title');`  // ["Learn Backbone's Collection", "Learn Models"]
6. `todoList.pluck('completed');`  // [false, true]
7. `JSON.stringify(todoList);`  // "[{"title":"Learn Backbone's Collection", "completed":false"}..., {"title":"Learn Models"...}]"

####<a id="collectionsgetset">Collections (get, set)</a>

By default, the Models stored inside Collections are enumerated (i.e. ordered) by their `id` property.  To get a specific model, you can use `collection.get(id)`, which will check the array for the existence of the model with the right `id`.  You can also try to reference a model with the `cid` or `idAttribute`.  This also applies to `collection.set(id)`

####<a id="collectionsmultiple">Collections (multiple Models)</a>

You can do the standard `collection.get()`, `collection.set()`, `collection.reset()` to affect the entire Collection instead of just a Model at a time.

####<a id="collectionsunderscore">Collections Underscore functions (forEach, sortBy(), map(), chain())</a>s

Since Backbone has a hard dependency on Underscore, you can use Underscore's utility functions directly on collections.  These include:

-  `forEach`: iterate over collections
-  `sortBy()`: sort a collection on a specific attribute
-  `map()`: iterate through a collection, map each value
-  `min()/max()`: retrieve an item with min or max value of an attribute
-  `filter()`: filter a collection (e.g. contains these ids)
-  `indexOf()`: return index of a particular item within a collection
-  `any()`: confirm if any of the values in a collection pass an iterator truth test
-  `size`: return size of a collection
-  `isEmpty()`: determines if a collection is empty
-  `keys()/values()`: gets a list of attribute names/keys and values

You can also use Underscore's `chain()` method to chain multiple methods (e.g. if you want to filter by age and map what is returned to another list)

##<a id="events">Events (a mixin)</a>

Events is a mixin you can use to listen for well... events.  Events have a few methods we're interested in like `on`, `off`, and `trigger` (similar to jQuery).  `on` has the format `object.on(event, callback, [context])`, which means to bind an object to an event and a callback.  When that event is triggered, it executes the callback.  E.g. `todoList.on('add', this.addAll, this);` would mean everytime a new item is 'add'ed to the Backbone.Collection, the event 'add' is triggered.  You can add events to Collections, Views, etc.

Events follow the publisher/subscriber behavior where publishers (aka senders/messages) do not sent messages directly to specific subscribers (aka receivers) and instead are sent to a message-oriented middleware system.  More specifically, events follow the __observer pattern__ where an object (the subject) has a list of dependents called observers that are notified automatically of any state changes (usually by calling one of their methods).

Events have the following format `{"<EVENT_TYPE> <ELEMENT_ID>": "<CALLBACK_FUNCTION>"}`.  For example: `events: {'keypress #new-todo': 'createTodoOnEnter'}`.  The jQuery equivalent would be `$('#new-todo').keypress(createTodoOnEnter);`.

Events can also have a simpler format: `object.on({click: action})`.  E.g.

    var Todo = Backbone.Model.extend({
      defaults: {
        title: '',
        completed: false
      }
    });
    
    var myTodo = new Todo();
    myTodo.set({title: 'Buy some cookies', completed:true});
    
    myTodo.on({
      'change:title': titleChanged,
      'change:completed': stateChanged
    });
    
    function titleChanged(){
      console.log('Title changed!');
    }
    
    function stateChanged(){
      console.log('State changed!');
    }
    
    myTodo.set({title: 'Get the groceries!'});  // Title changed!

Some more examples:

-  `object.on("change: something", function(stuff){ console.log("Stuff"); });`

##<a id="views">Views (Overview)</a>

Views are the user interface and tells us how data is displayed.  Backbone views are generally based on View Templates.  While rendering the UI, Views also listen to the events from the DOM.  Views have four basic properties (with an optional fifth 'template'):

1. `el`
2. `initialize`
3. `render`
4. `events`
5. `template`

####<a id="viewsel">Views (el)</a>

The el property stands for element and is the reference to the DOM.  Every view has an element associated with it where the view will inject content in.
  - `this.el` is created from the view's `el`, `tagName`, `className`, `id`, or `attributes` properties.  If none of these are specified, then it is an empty `div`.
  - `view.$el` is the cached jQuery object of the view's element (`view.el`)

####<a id="viewsinitialize">Views (initialize)</a>

`initialize` - the first function called when a view is instantiated.  You can pass parameters that will be attached to a model, collection or `view.el`

####<a id="viewsrender">Views (render)</a>

`render` - this function injects the markup into the elements.  This is not required; some views can call other view's render function.

####<a id="viewsevents">Views (events mixin)</a>

See Events.

####<a id="viewstemplate">Views (template)</a>

`template` - _.js templates have the following format `_.template(templateString, [data], [settings])` where `templateString` you can use the placeholders `<%= %>` (allows for HTML escape) and `<%- %>` (does not allow for HTML escape) to dynamically insert data.  Also there is `<% %>` to run any javascript code.  

##<a id="routers">Routers</a>

Routes reference a certain 'state' of the web application in the URL.  Routes are hash maps that match URL patterns to functions.  You can use parameter parts such as `todos/:id` or splats `file/*path` to match all the parameters from the splat on (make sure to make splat parameters last since they're greedy).

##<a id="nonjstemplate">Non-Javascript part of Template</a>

The non-js part of our template.

    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>title-backbonejs</title>
    </head>
    <body>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
      <script src="http://ajax.cdnjs.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
      <script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.2.1/backbone-min.js"></script>
      <script>
        <!-- Put Backbone.js stuff here or link to src-->
      </script>
    </body>
    </html>

##<a id="hwexample">Hello World Example</a>

####<a id="hwview">Declaration and Instantiation of a minimalist View with `initialize` and `render`</a>

Upon instantiation, we automatically call `initialize()`.  This handles all bindings except for UI events like clicks.  We then `render()` the view, in this case inside an existing element.

    (function($){  // creates a self-executing wrapper
      var ListView = Backbone.View.extend({  // our main app's view
        el: $('body'),  // attaches 'this.el' to an existing element
        
        initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
          _.bindAll(this, 'render'); // fixes loss of context for 'this' within methods
    
          this.render();  // not all views are self-rendering; this one is
        },
    
        render: function(){  // function to render the entire view in 'this.el'
          $(this.el).append("<ul> <li>hello world</li> </ul>");
        }
      });
      
      var listView = new ListView();  // instantiate main app view
    })(jQuery);

####<a id="hwevent">Binding of DOM events to View methods with `events`</a>

Views act like Controllers in a MVC and are used to bind DOM events to View methods.  Under 'events', you can see that we have a 'click' that triggers the custom 'addItem' function.

    (function($){  // creates a self-executing wrapper
      var ListView = Backbone.View.extend({  // our main app's view
        el: $('body'),  // attaches 'this.el' to an existing element
    
        events: {
            'click button#add': 'addItem'
        },
        
        initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
          _.bindAll(this, 'render', 'addItem'); // every function that uses 'this' as the current object should be here
    
          this.counter = 0;  // total number of items added so far
          this.render();  // not all views are self-rendering; this one is
        },
    
        render: function(){
          $(this.el).append("<button id='add'>Add list item</button>");
          $(this.el).append("<ul></ul>");
        },
    
        addItem: function(){
            this.counter++;
            $('ul', this.el).append("<li>hello world"+this.counter+"</li>");
        }    
      });
      
      var listView = new ListView();  // instantiate main app view
    })(jQuery);

##<a id="models">Models and Collections</a>

A Model is a JavaScript object (i.e. key-value pairs) with some helper functions to handle things like event triggering, persistence.  A Collection is a group of Models.

####<a id="hwmodelcollection">How to use a Collection of Models to store data and tie changes to a View</a>

    (function($){  // creates a self-executing wrapper
    
      var Item = Backbone.Model.extend({
        defaults: {
            part1: 'hello',
            part2: 'world'
        }
      });
      
      var List = Backbone.Collection.extend({
        model: Item
      });
    
      var ListView = Backbone.View.extend({  // our main app's view
        el: $('body'),  // attaches 'this.el' to an existing element
    
        events: {
            'click button#add': 'addItem'
        },
        
        initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
          _.bindAll(this, 'render', 'addItem', 'appendItem'); // every function that uses 'this' as the current object should be here
    
          this.collection = new List();
          this.collection.bind('add', this.appendItem);  // collection event binder
    
          this.counter = 0;  // total number of items added so far
          this.render();  // not all views are self-rendering; this one is
        },
    
        render: function(){
          var self = this;  // save reference to 'this' so it can be accessed from within the scope of the callback
          $(this.el).append("<button id='add'>Add list item</button>");
          $(this.el).append("<ul></ul>");
          _(this.collection.models).each(function(item){
            // in case collection is not empty
            self.appendItem(item);
          }, this);
        },
    
        // addItem now works with just the models/collections
        addItem: function(){
          this.counter++;
          var item = new Item();
          item.set({
            part2: item.get('part2') + this.counter  // modify item defaults
          });
          this.collection.add(item);  // add item to collection; view is updated via event 'add'
        },
        
        appendItem: function(item){
          $('ul', this.el).append("<li>"+item.get('part1')+" "+item.get('part2')+"</li>");
        }
    
      });
      
      var listView = new ListView();  // instantiate main app view
    })(jQuery);

####<a id="hwmodelview">Delegate rendering of a Model to a dedicated View</a>

    (function($){  // creates a self-executing wrapper
    
      var Item = Backbone.Model.extend({
        defaults: {
            part1: 'hello',
            part2: 'world'
        }
      });
      
      var List = Backbone.Collection.extend({
        model: Item
      });
    
      var ItemView = Backbone.View.extend({
        tagName: 'li', // name of (orphan) root tag in 'this.el'
        initialize: function(){
          _.bindAll(this, 'render');  // every function that uses 'this' as the current object should be here
        },
    
        render: function(){
          $(this.el).html('<span>'+this.model.get('part1')+' '+this.model.get('part2')+'</span>');
          return this;  // for chainable calls, like .render().el 
        }
      });
    
      var ListView = Backbone.View.extend({  // our main app's view
        el: $('body'),  // attaches 'this.el' to an existing element
    
        events: {
            'click button#add': 'addItem'
        },
        
        initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
          _.bindAll(this, 'render', 'addItem', 'appendItem'); // every function that uses 'this' as the current object should be here
    
          this.collection = new List();
          this.collection.bind('add', this.appendItem);  // collection event binder
    
          this.counter = 0;  // total number of items added so far
          this.render();  // not all views are self-rendering; this one is
        },
    
        render: function(){
          var self = this;  // save reference to 'this' so it can be accessed from within the scope of the callback
          $(this.el).append("<button id='add'>Add list item</button>");
          $(this.el).append("<ul></ul>");
          _(this.collection.models).each(function(item){
            // in case collection is not empty
            self.appendItem(item);
          }, this);
        },
    
        // addItem now works with just the models/collections
        addItem: function(){
          this.counter++;
          var item = new Item();
          item.set({
            part2: item.get('part2') + this.counter  // modify item defaults
          });
          this.collection.add(item);  // add item to collection; view is updated via event 'add'
        },
        
        appendItem: function(item){
          var itemView = new ItemView({
            model: item
          });
          $('ul', this.el).append(itemView.render().el);
        }
      });
      
      var listView = new ListView();  // instantiate main app view
    })(jQuery);

####<a id="hwmodelaction">Create Model actions</a>

We use `Backbone.sync` to override persistence storage (so we can do `Model.destroy()`).  In our `ItemView` we now have two clickable events for each `Item` (swap and delete).  

    (function($){  // creates a self-executing wrapper
    
      // `Backbone.sync` allows use of `Model.destroy()` without raising an error
      Backbone.sync = function(method, model, success, error){
        success();
      }
    
      var Item = Backbone.Model.extend({
        defaults: {
            part1: 'hello',
            part2: 'world'
        }
      });
      
      var List = Backbone.Collection.extend({
        model: Item
      });
    
      var ItemView = Backbone.View.extend({
        tagName: 'li', // name of (orphan) root tag in 'this.el'; tag to be created
        
        // ItemView now respond to two clickable actions for each item `swap` and `delete`
        events: {
          'click span.swap': 'swap',
          'click span.delete': 'remove'
        },
    
        initialize: function(){
          _.bindAll(this, 'render', 'unrender', 'swap', 'remove');  // every function that uses 'this' as the current object should be here
    
          this.model.bind('change', this.render);
          this.model.bind('remove', this.unrender);
        },
    
        render: function(){
          $(this.el).html('<span style="color:black;">'+this.model.get('part1')+' '+this.model.get('part2')+'</span> &nbsp; &nbsp; <span class="swap" style="font-family:sans-serif; color:blue; cursor:pointer;">[swap]</span> <span class="delete" style="cursor:pointer; color:red; font-family:sans-serif;">[delete]</span>');
          return this;  // for chainable calls, like .render().el 
        },
    
        unrender: function(){
          $(this.el).remove();
        },
    
        swap: function(){
          var swapped = {
            part1: this.model.get('part2'),
            part2: this.model.get('part1')
          };
          this.model.set(swapped);
        },
    
        remove: function(){
          this.model.destroy();
        }
      });
    
      var ListView = Backbone.View.extend({  // our main app's view
        el: $('body'),  // attaches 'this.el' to an existing element
    
        events: {
            'click button#add': 'addItem'
        },
        
        initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
          _.bindAll(this, 'render', 'addItem', 'appendItem'); // every function that uses 'this' as the current object should be here
    
          this.collection = new List();
          this.collection.bind('add', this.appendItem);  // collection event binder
    
          this.counter = 0;  // total number of items added so far
          this.render();  // not all views are self-rendering; this one is
        },
    
        render: function(){
          var self = this;  // save reference to 'this' so it can be accessed from within the scope of the callback
          $(this.el).append("<button id='add'>Add list item</button>");
          $(this.el).append("<ul></ul>");
          _(this.collection.models).each(function(item){
            // in case collection is not empty
            self.appendItem(item);
          }, this);
        },
    
        // addItem now works with just the models/collections
        addItem: function(){
          this.counter++;
          var item = new Item();
          item.set({
            part2: item.get('part2') + this.counter  // modify item defaults
          });
          this.collection.add(item);  // add item to collection; view is updated via event 'add'
        },
        
        appendItem: function(item){
          var itemView = new ItemView({
            model: item
          });
          $('ul', this.el).append(itemView.render().el);
        }
      });
      
      var listView = new ListView();  // instantiate main app view
    })(jQuery);

##<a id="apiintegration">API Integration</a>

Backbone is pre-configured to sync with a RESTful API.  For example, create a 'Collection' with the 'url' of your resource endpoint.

    var Books = Backbone.Collection.extend({
      url: '/books'
    });

####<a id="apimappings">API Mappings</a>

Here's how the __Collection__ and __Model__ components map to __REST__ resources.

    GET  /books/  ... collection.fetch();
    POST /books/  ... collection.create();
    GET  /books/1 ... model.fetch();
    PUT  /books/1 ... model.save();
    DEL  /books/1 ... model.destroy();

####<a id="apijson">API JSON data</a>

When fetching raw JSON data from an API, __Collection__ populates itself with data as an __array__ while __Model__ populates itself with data as an __object__.

    [{"id": 1}, {"id":2}]     ... a Collection with a couple of items
    {"id": 1, "name": "Will"} ... a Model with a couple of attributes

