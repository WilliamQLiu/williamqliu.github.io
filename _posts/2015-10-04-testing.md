---
layout: post
title: Testing
---

## {{ page.title }}

- - - -

##Table of Contents

*  [Summary](#summary)
    -  [Unit Tests](#unittests)
    -  [Integration Tests](#integrationtests)
    -  [Functional Tests](#functionaltests)
*  [Running Tests](#runtests)
*  [Loading Data](#loadingdata)
*  [Fixtures](#fixtures)
    -  [Dumping DB data into Fixtures](#dumpdata)
    -  [Loading Data from Fixtures](#loaddata)
    -  [Using Fixtures in Unit Tests](#fixturesunittest)
*  [Doubles](#doubles)
*  [Mocking](#mocking)
*  [Stubbing](#stubbing)

##<a id="summary">Summary</a>

Testing your code is important because it creates scaffolding for large projects.  When you build new features, you also ensure that you don't destroy something else accidentally.  There's a lot of different libraries including:

*  Unittest
*  Doctest
*  Nose
*  Unittest2
*  mock

Tests can be broken down into the following:

*  Unit Tests
*  Integration Tests
*  Functional Tests

####<a id="unittests">Unit Tests</a>

__Unit tests__ ensure that a small part of your code works in isolation.  Each of these should be able to run alone and within a test suite regardless of the order called.  This means that each test loads a fresh dataset using __setUp()__ and __tearDown()__ methods.  Dependencies are all mocked up.  These tests should be fast.

####<a id="functionaltests">Integration Tests</a>

Ensure that all the above unit tests work well together.

####<a id="functionaltests">Functional Tests</a>

__Functional tests__ (aka Acceptance Test, End-To-End Test, Black Box Test) tests many methods and may interact with dependencies like databases or web services.  You don't look at the code.  Examples include running selenium to simulate opening a browser, clicking on things.

##<a id="runtests">Run Tests</a>

Execute tests using the following commands:

*  `python manage.py test myfunctionaltests` assuming folder with 'myfunctionaltests' and 'test_functional.py' file
*  `python manage.py test myunittests` assuming folder with 'myunittests' and 'test_unit.py' inside folder
*  `python manage.py test` to run all tests

##<a id="loadingdata">Loading Data</a>

You can load data (into and out of databases, into test files, etc) a few different ways.  These include fixtures and mocks.

##<a id="fixtures">Fixtures</a>

To create a state for your database, we can create __fixtures__.  

####<a id="dumpdata">Dumping DB Data into Fixtures</a>

In Django, if your app has data in the database, you can create fixtures by using the `dumpdata` command:

    python manage.py dumpdata myapp --format=yaml > myapp/fixtures/db_data.yaml

This fixture is really just a serialization of your database data into a yaml file.  By default the fixture is in JSON format.  You can edit this feature in the text editor if you'd like.

####<a id="loaddata">Loading Data from Fixtures</a>

If you want to load your data (into the db or the command line) from your Fixtures, we call this __deserialization__.  You can do this with:

    from django.core.management import call_command
    call_command("loaddata", "' + db_data.yaml' + '", verbosity=8)

This is the same as (except this is from the command line):

    python manage.py loaddata db_data.yaml

####<a id="fixturesunittest">Using Fixtures in Unit Tests</a>

    from django.test import TestCase
    from myapp.models import Stuff
    
    class StuffTests(TestCase):
        # Note: this is the fixture
        # model: myapp.stuff
        # pk: 1
        # fields: {content: lots of stuff, query: test, title: test, url: 'test'}
        fixtures = ['mine']
    
        def testFlufflyAnimals(self):
            s = Stuff.objects.get(pk=1)
            self.assertEquals(s.query, 'test')
            s.query = 'who cares'
            s.save()

For more on testing the serializer and deserializer: http://django-testing-docs.readthedocs.org/en/latest/serialization.html

More specifically, you can use the DRF's APIRequestFactory for testing serializers and deserializers.

##<a id="doubles">Doubles</a>

When you're testing individual units, you'll realize that some parts rely on others.  This is where we get into __test doubles__, which are kinda like stunt doubles in movies.  While this isn't a real name, we can define what kind of test objects we have, which can include:

*  __Dummy__ objects are passed around, but never used (i.e. just used to fill parameter lists)
*  __Fake__ objects actually have working implementations, but take some shortcuts which makes them unsuitable for production environments (e.g. in memory database like sqlite)
*  __Stubs__ provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test.
*  __Mocks__ are objects programmed with expectations which form a specification of the calls they are expected to receive.

An example between _stubs_ and _mocks_ would be if we tested sending out an email.  Stubs would send out the fake email and verify it was sent.  Mocks would take it a step further and also check if we sent it to the right person, with the right contents, etc.

##<a id="mocking">Mocking</a>

By __mocking__ objects, you can simulate objects and mimic the behavior of real objects in a controlled way.  For example, you would create a mock object to test the behavior of some other object.  Some reasons for mocking an object include:

*  the object supplies non-deterministic results (e.g. the current time or temperature)
*  the state is difficult to reproduce (e.g. a network error)
*  it is slow (e.g. querying a complete database)
*  it does not yet exist (e.g. reliant on another object)

An example is if we mock an alarm clock going off at 7:00am, we wouldn't want to wait till 7:00am just to test.  Another example is if we post to facebook, we don't want to actually have to post to facebook.


