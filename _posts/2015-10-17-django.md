---
layout: post
title: Django Web Framework
---

## {{ page.title }}

- - - -

##Table of Contents

*  [Summary](#summary)
*  [Object Relational Mapper](#orm)
    -  [Shell Plus](#shellplus)
    -  [Object and QuerySets](#objectqueryset)
    -  [Object Fields](#ormobjectfields)
    -  [ORM Shortcut Combinations](#ormshortcuts)
    -  [Chaining QuerySets](#chainingquerysets)
    -  [Iterating through QuerySets](#ormiterable)
    -  [Complex Queries with Q](#complexqueriesq)
*  [Migrations](#migrations)
    -  [makemigrations command](#makemigrations)
    -  [migrate command](#migrate)
    -  [Migration Files](#migrationfiles)
    -  [Data Migration with `RunPython`](#datamigrations)
    -  [Squash Migrations with `squashmigrations` command](#squashmigrations)
*  [Views](#views)
    -  [requests](#requests)
    -  [render_to_response()](#rendertoresponse)
    -  [render()](#render)
*  [Templates](#templates)
    -  [Template Variables](#templatevariables)
    -  [Template Tags](#templatetags)
    -  [Custom Template Tags](#templatetagscustom)
    -  [Advanced Template Tags](#templatetagscustomadvanced)
    -  [Custom Template Filters](#templatefilterscustom)
*  [Forms](#forms)
    -  [HTML forms](#htmlforms)
    -  [GET and POST](#getpost)
    -  [Django HTML Forms Template](#djangoformshtmltemplate)
    -  [Django Form Process](#djangoformsprocess)
    -  [Django Forms Code](#djangoformscode)
*  [Context](#context)
    -  [Context Stack](#contextstack)
    -  [RequestContext](#requestcontext)
    -  [Context Processor](#contextprocessor)
*  [User Authentication and Authorization](#users)
    -  [Create Superuser](#createsuperuser)
    -  [Permissions](#permissions)
    -  [@login_required](#loginrequired)
    -  [@permission_required](#permissionrequired)
    -  [@user_passes_test](#userpassestest)
*  [Serializers](#serializers)
    -  [`dumpdata` command](#dumpdata)
    -  [`loaddata` command](#loaddata)
*  [Middleware](#middleware)
    -  [Middleware Order](#middlewareorder)
    -  [Middleware Folders](#middlewarefolders)
*  [Signals](#signals)
*   -  [Built-in Signals](#signalsbuiltin)
*   -  [Listening for Signals with Receivers](#signalslisten)  
*   -  [Sending Signals](#signalssend)



##<a id="summary">Summary</a>

__Django__ is a web framework in Python.  The idea is to be able to receive requests and send responses.

##<a id="orm">Object Relational Mapper</a>

Django has an __Object Relational Mapper (ORM)__ that takes database tables and represents this as Python objects.

*  One or more objects?

You can either __query__ for one object or if there are multiple objects, you'll get an iterable called a __QuerySets__ (which is a collection of objects from your database).  This is like a SELECT statement in SQL.

*  Filters

You can have zero, one, or more filters to narrow down your query results.  This is like the WHERE or LIMIT statements in SQL.

*  Manager

You interact with a Queryset with the Model's __Manager__.  Each model has at least one __Manager__ and it's called __objects__ by default.  Managers are only accessible via the model classes, not from the model instances.

    >>> Blog.objects
    <django.db.models.manager.Manager object at ...>

*  Lazy

QuerySets are lazy in that they don't do any database activity until the QuerySet is evaluated.

####<a id="shell">Shell and Shell_Plus</a>

You can interact with the ORM using `python manage.py shell`.  If you have the library `django-extensions`, you can use `python manage.py shell_plus` to automatically load in all your django models.  You can exit with the `exit()` command.

####<a id="objectqueryset">Difference between Object and QuerySet</a>

Here's the difference between an individual Object and a QuerySet (collection of objects).

    >>> me = User.objects.get(username='wliu')
    >>> me
    <User: wliu>
    >>> type(me)
    accounts.models.User
    
    >>> me = User.objects.all()[:1]
    >>> me
    [<User: admin>]
    >>> type(me)
    django.db.models.query.QuerySet


####<a id="ormget">ORM Get</a>

You can get specific objects from the database.

    >>> me = User.objects.get(username='will')

To get all the models in your database, do:

    >>> from django.apps import apps
    >>> apps.get_models()
    [django.contrib.admin.models.LogEntry,
     accounts.models.User,
     blog.models.BlogPost,
     blog.models.Comment
    ]

####<a id="ormobjectfields">ORM Object Fields</a>

To get all the fields in your model, do:

    >>> Comment._meta.fields  # does not include reverse relations
    [<django.db.models.fields.AutoField: id>,
     <django.db.models.fields.related.ForeignKey: blogpost>,
     <django.db.models.fields.TextField: content>,
     <django.db.models.fields.DateField: date_created',
     <django.db.models.fields.related.OneToOneField: user>]
    
    >>> Comment._meta.get_all_field_names()  # includes reverse relations
    ['blogpost',
    u'blogpost_id',
     'content',
     'date_created',
     'id',
     'user']

####<a id="ormselect">ORM Select All</a>

You can select objects from the database.  Suppose we have a model `Post` from our app `blogs`.

    >>> from blog.models import Post
    >>> Post.objects.all()
    [<Post: my post title>, <Post: another post title>]


####<a id="ormcreate">ORM Create</a>

You can create objects in the database.

     >>> from django.contrib.auth.models import User
     >>> Post.objects.create(author=me, title='Sample title', text='Test')

####<a id="ormfilter">ORM Filter</a>

You can filter objects.  You can use two `_` characters between a field name and a filter operation (e.g. title and contains).

    >>> Post.objects.filter(author=me)
    >>> Post.objects.filter(title__contains='title')

####<a id="ormrelational">ORM Relational</a>

So say you have a Blog model that has a field (_user_) that is related as a ForeignKey to a User model (that we're trying to access the _username_ field).  You can filter for the Blogs that are by that user using:

    >>> mypost = Blog.objects.filter(user__username__exact='william')

####<a id="ormpublish">ORM Publish</a>

You can publish items in the database.

    >>> mypost = Post.objects.get(title='Sample title')
    >>> mypost.publish()

####<a id="ormdelete">ORM Delete</a>

You can delete items in the database.

    >>> mypost = Post.objects.get(title='Sample title')
    >>> mypost.delete()

####<a id="ormupdate">ORM Update</a>

You can update items in the database.

    >>> mypost = Post.objects.filter(title='Sample title').update(is_active=False)

####<a id="ormorderby">ORM Order by</a>

You can order the list of objects.

    >>> Post.objects.order_by('created_date')
    >>> Post.objects.order_by('-created_date')

####<a id="ormlimit">ORM Limit</a>

You can limit the number of items.

    >>> Post.objects.all()[:5]  # return first 5 objects

####<a id="ormshortcuts">ORM Shortcut Combinations</a>

A lot of times you'll want to get an item and if it isn't there, do an action (like Create or return a 404 response).  This is a shortcut to doing the long way of Try/Except.

    # Long way
    try:
        obj = Person.objects.get(first_name='Will', last_name='Liu')
    except Person.DoesNotExist:
        obj = Person(first_name='Will', last_name='Liu')
        obj.save()
    
    # Shortcut
    obj, created = Person.objects.get_or_create(first_name='Will', last_name='Liu')

The `get_or_create` shortcut will return the object and whether it was created (True or False).  If multiple items appear, then error `MultipleObjectsReturned` is raised.

There's plenty of these shortcuts including:

*  `get_or_create`
*  `update_or_create`
*  `get_object_or_404`


####<a id="ormcopy">ORM Copying Objects</a>

You can copy objects by setting the __pk__ to _None_.    

     >>> mypost = Post(name='My Post', comment='This is my comment')
     >>> mypost.save()  # mypost.pk == 1
     >>> mypost.pk = None
     >>> mypost.save()  # mypost.pk == 2

####<a id="ormvalues">ORM to values</a>

Often you'll want to take a Model object and turn that into a dictionary.  You can specify field names by passing in the field names into values() as arguments.

    # this list contains Model objects
    >>> Blog.objects.filter(name__startswith='Beatles')
    <Queryset [<Blog: Beatles Blog>]>
    
    # this list contains a dictionary
    >>> Blog.objects.filter(name__startswith='Beatles').values()
    <QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest news'}]>

####<a id="chainingquerysets">Chaining QuerySets</a>

You can chain QuerySets together to write complex queries.

     >>> Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')

####<a id="ormiterable">Iterating through QuerySets</a>

Since QuerySets are iterables of multiple objects, you can iterate through the objects.

     >>> queryset = Post.objects.all()
     >>> print([x.somefield for x in queryset])
     >>> print([x.someotherfield for x in queryset])  # this is cached from evaluation earlier

####<a id="complexqueriesq">Complex Queries with Q</a>

A __Q object__ is an object used to encapsulate a collection of keyword arguments.

    >>> from django.db.models import Q
    >>> Q(question__startswith='Who') | Q(question__startswith='What')  # Who or What
    >>> ~Q(pub_date__year=2005) # not published on 2005
    >>> Poll.objects.get(Q(question__startswith='Who', ~Q(pub_date__year=2005) | Q(pub_date__year=2002))

##<a id="migrations">Migrations</a>

Migrations is how Django updates your database schema to fit in line with the current models of the app (on a per app basis).  This is done when you update a field, delete a model, etc.  The core commands are:

*  __makemigrations__ - creates new migrations based on changes you made to your model (usually the first step)
  __migrate__ - applies the migrations that you made above (usually the second step)
*  __sqlmigrate__ - displays the SQL statements for a migration (optional if you want to see the SQL)

####<a id="makemigrations">makemigrations command</a>

__makemigrations__ is done after you make changes to your models (e.g. add a field).  To run, do: `python manage.py makemigrations [your_app_here]`.  Note that you can specify / limit to a single app, but this may cause issues in schemas that have relationships (like ForeignKey, OneToOneField, ManyToManyField).

####<a id="migrate">migrate command</a>

This synchronizes unmigrated apps (i.e. adds or removes them if they're new or no longer there) and then it runs the migrations that have not been applied yet.

####<a id="migrationfiles">Migration files</a>

Migrations are actually just a Python file that list __dependencies__ (a list of the migration names that this depends on) and __operations__ (list of operations that define what this migration does, like what model was deleted, what field added).

####<a id="datamigrations">Data Migrations with `RunPython`</a>

You can use migrations to change the data in the database itself; this is called __data migrations__.  To do this, create an empty migrations file: `python manage.py makemigrations --empty`.  We then need to modify the migrations file and add in an operation called __migrations.RunPython__.  

    from django.db import models, migrations
    
    def combine_names(apps, schema_editor):
        Person = apps.get_model("yourappname", "Person")
        for person in Person.objects.all():
            person.name = "%s %s" % (person.first_name, person.last_name)
            person.save()
    
    class Migration(migrations.Migration):
        dependencies = [
            ('yourappname', '0001_initial'),
        ]
        operations = [
            migrations.RunPython(combine_names),
        ]

####<a id="squashmigrations">Squash Migrations with `squashmigrations`</a>

After enough migrations (say hundreds), you might want to reduce the number of migrations to just one file that represents the same thing.  Django extracts the operations and puts them all in a sequence (while taking into account if say we Create a Model, then Delete a Model).

To run this, do `python manage.py squashmigrations myappname 0004` to squash the migrations up to that migration number.  Be warned, this can create errors like __CircularDependencyError__.  You can also try with the flag: `--no-optimize`.  Note with older versions of Django using South, you may have to use `python manage.py migrate --fake myappname` so that it runs more than one initial migration.

After a migration is squashed successfully, make sure to:

*  Delete all the migration files it replaces
*  Remove the __replaces__ argument in the Migration class of the squashed migration file (this tells Django that it is a squashed migration)

##<a id="views">Views</a>

When the server gets a __request__, a __view__ decides what models and templates to use.  You can render views using `render` and `render_to_response`.  A view always returns either a `HttpResponse` or a 404.

####<a id="requests">requests</a>

When you get a request, there's important information in the __request.META__, which is a Python dictionary that has all the available HTTP Headers (e.g. user IP Address, user agent info like the web browser).  Do note that this information does not have to exist.  Useful header info includes:

*  __HTTP_REFERER__ - The referring URL, if any.
*  __HTTP_USER_AGENT__ - User's browser (e.g. Firefox)
*  __REMOTE_ADDR__ - The IP Address of the client

####<a id="rendertoresponse">render_to_response()</a>

You receive a request and this creates a response.  If you use this, your template is passed a __Context__ instance by default (not a __RequestContext__).

####<a id="render">render()</a>

The render shortcut is the same as `render_to_response()` except there is a __context_instance__ argument that forces the use of __RequestContext__.

##<a id="template">Template</a>

A template determines how to display information.  Technically, a template is a text file that can be any text format (e.g. HTML, CSV, XML).  These templates contain __variables__, which are replaced with values when the template is evaluated.  There are also __tags__, which control the logic of the template (e.g. for loop through a list of items).

The template engine's goal is meant to express presentation of data, not program logic.

####<a id="templatevariables">Template Variables</a>

Template variables look like `{{ my_variable }}`.  When a variable is encountered, the engine replaces the variable with the result.  Use the `_` if you need spacing and the `.` if you need to access attributes of the variable.

####<a id="templatetags">Template Tags</a>

Template tags can have for-loops and if/elif/else statements.  If any variables are invalid, they are seen as __None__.

__for-loops__

    <ul>
    {% for athlete in athlete_list %}
      <li>{{ athlete.name }}</li>
    {% endfor %}
    </ul>

__if, elif, else__

    {% if athlete_list %}
        Number of athletes: {{ athlete_list|length }}
    {% elif athlete_in_locker_room_list %}
        Athletes should be out of the locker room soon!
    {% else %}
        No athletes.
    {% endif %}

####<a id="templatetagscustom">Custom Template Tags</a>

If you want to make some custom presentation logic, you can create your own tags to really do anything.  For example, if you want an alert about any issues, you can define a custom tag that shows these alerts anywhere you put the tag.  Or you might want to show some debug information by simply putting a tag.  

You can either use some of the built-in helpers that Django has (e.g. simple_tag, assignment_tag, inclusion_tag) or you can make your own tag from scratch.

The general idea is that you can define these functions in your templatetags folder (same level as models.py, views.py), then make them available by using the `{% load %}` tag (e.g. `{% load mystuff_tags %}`) while making sure to restart your development server AND naming the file the same as the tag (e.g. `mystuff_tags.py`).

    from django import template
    
    register = template.Library()  # to be valid tag library, needs this variable

####simple_tag and assignment_tag

Here's how to use the built-in shortcut `simple_tag`, which calls the tag and accepts any number of arguments.  The idea is that you can do a custom tag to do any logic with Python (e.g. pass in a python list) and output some custom formatting in HTML all in a single tag.  There's another tag called `assignment_tag` that saves a variable into the context so you can use it later instead of directly outputting the results using `as` argument.

    import datetime
    from django import template
    
    register = template.Library()
    
    @register.simple_tag
    def current_time(format_string):
        return datetime.datetime.now().strftime(format_string)
    
    @register.simple_tag(takes_context=True)
    def current_time(context, format_string):
        timezone = context['timezone']
        return your_get_current_time_method(timezone, format_string)
    
    # {% current_time %}

Note that if we have a lot of variables, we can use: `takes_context=True` and store the values in the context.

####Inclusion tags

Inclusion tags displays some data by rendering another template.  This is good if you have a lot of different logic or CSS for say a button or object.

    # Template Tags
    @register.inclusion_tag('results.html')
    def show_results(posts):
        blog_posts = Blog.objects.all()
        return {'blog_posts': blog_posts}  # notice, has to be a dict
    
    # Template: results.html
    <ul>
    {% for blog_post in blog_posts %}
        <li> {{ blog_post }} </li>
    {% endfor %}
    </ul>
    
    # Template: main.html
    {% show_results mydata %}
    
    # What it looks like in main.html
    <ul>
        <li>First Post</li>
        <li>Second Post</li>
        <li>Third Post</li>
    </ul>

####<a id="templatetagscustomadvanced">Advanced Custom Template Tags</a>

To write an advanced custom tag, we have two steps: we need to specify how to __compile__ and then __render__ the templating system.

When Django compiles a template, the raw template text is split into __nodes__ where each node is an instance of __django.template.Node__ and has a `render()` method.  The compiled template is simply a list of __Node__ objects.

What we're doing is telling how the raw template tag is converted into a node (the compilation function) and what the node's render() method does.  For example:


    # Templatetags
    # Custom Template Tag: Compilation
    @register.tag
    def do_current_time(parser, token):
        try:
            # split_contents() knows not to split quoted strings
            tag_name, format_string = token.split_contents()
        except ValueError:
            raise template.TemplateSyntaxError("%r tag requires\
                exactly one argument" % token.contents.split()[0])
        if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
            raise template.TemplateSyntaxError("%r tag's argument should be \
                in quotes" % tag_name)
        return CurrentTimeNode(format_string[1:-1])
    
    # Custom Template Tag: Rendering
    class CurrentTimeNode(template.Node):
        def __init__(self, format_string):
            self.format_string = format_string
    
        def render(self, context):
            return datetime.datetime.now().strftime(self.format_string)
        
    register.tag(do_current_time)
    
    #Template to load custom tags, say main.html
    
    {% load blog_tags %})
    <p>The time is {% do_current_time "%Y-%m-%d %I:%M %p" %}.</p>

####<a id="templatefilterscustom">Custom Template Filters</a>

Custom filters are Python functions that take one or two arguments:

*  the value of the input variable (not necessarily a string)
*  the value of the argument (can be a default value or left out)

As an example, the filter `{{ var|foo:"bar" }}` the filter __foo__ would be passed the variable __var__ and the argument __"bar"__.

Example:

    from django import template
    
    register = template.Library()  # to be valid tag library, needs this variable
        
    @register.filter  # by default, Django will use the funciton's name to register
    def lower(value):  # only one argument
        """ converts a string into all lowercase """
        return value.lower()
    
    @register.filter(name='cut')
    def cut(value, arg):
        """ Removes all values of arg from the given string """
        return value.replace(arg, '')
    
    @register.filter(name='novowels')
    def novowels(value, arg):
        """ Remove any vowels from value """
        vowels = ['a', 'e', 'i', 'o', 'u']
        if any(word in value for word in vowels):
            single_letters = list(value)
            for i, value in enumerate(single_letters):
                if value in vowels:
                    single_letters.remove(value)
    
    return single_letters
    
    register.filter('novowels', novowels)
    register.filter('cut', cut)
    register.filter('lower', lower)
    
    # Use Case in Template
    #{{ somevariable|cut:"0" }}


##<a id="forms">Forms</a>

Forms allow you to accept input from users and processes how to respond.  

####<a id="htmlforms">HTML Forms</a>

In HTML, forms are a collection of elements inside the `<form> ... </form>` tags that allow users to enter text, select options, and basically provide user input (often using the HTML `<input>` elements).  Forms must specify:

*  __What__ data should be sent (usually defined by the `<input>` elements).  This is could be say an input of `<type="text">` for a text input box or `<type="submit">` for a button.
*  __Where__ to send the data (i.e. the URL endpoint).  This is normally under the form's __action__ attribute (e.g. route to the url for `/admin/`)
*  __How__ to send the data (i.e. what HTTP method, for Django forms this is either a __GET__ or __POST__).  

####<a id="getpost">Form GET and POST</a>

With Django's __GET__ method, a GET is used to send data that does not affect the state of the system and can be public (e.g. web search would appear as `website.com/search/?forms&release=1`).

With Django's __POST__ method, the browser gets all the form data together, encodes it to send, sends it to the server, then receives back a response.  POST is used to make changes in the database or for private data.

####<a id="djangoformshtmltemplate">Django HTML Form Template</a>

Here is a form that gets a user's name through the `<input>` tags, returns the form to the URL `/your-name/` with a POST method, displays a text field label indicating to the user to input their name, and pre-fills the `{{ current_name }}` if it exists.

    <form action="/your-name/" method="post">
        <label for="your_name">Your name: </label>
        <input id="your_name" type="text" name="your_name" value="{{ current_name }}">
        <input type="submit" value="OK">
    </form>

####<a id="djangoformsprocess">Django Form Process</a>

In Django, when we render an object, we typically do these steps:

*  Get the view (i.e. this tells us the template and model)
*  Pass the view the template context (i.e. a dictionary with keys and values)
*  Then expand it to HTML markup using template variables

Rendering a form has similar steps except when we instantiate a form, we have the possible options:

*  Create a form that is empty
*  Pre-populate the form from a saved model or some other data source (i.e. there's already data filled out)

####<a id="djangoformscode">Django Forms Code</a>

If we want to move away from the Django HTML Form Template and into Python code, we can do that with Django forms.

    # forms.py
    from django import forms
    
    class NameForm(forms.Form):
        your_name = forms.CharField(label='Your name', max_length=100)

This code takes the Form instance and does a `is_valid()` method check, which runs validation routines for all the fields.  When this is called, if all fields have valid data, it returns `True` and places the form's data in the __cleaned_data__ attribute.

    <label for="your_name">Your name: </label>
    <input id="your_name" type="text" name="your_name" maxlength="100">

Note that this does not include the `<form>` tags or a submit button, we'll need to manually provide these.

The form is sent to the view.

    #views.py
    from django.shortcuts import render
    from django.http import HttpResponseRedirect
    
    from .forms import NameForm
    
    def get_name(request):
        # if POST request, we need to process the form data
        if request.method == 'POST':
            # create a form instance and populate it with data from the request
            form = NameForm(request.POST)
            # check if form is valid
            if form.is_valid():
                # Process the data in form.cleaned_data
                # Then redirect to a new URL
                return HttpResponseRedirect('/thanks/')
        # if GET (or any other method) we create a blank form
        else:
             form = NameForm()
    
        return render(request, 'name.html', {'form': form})

The new HTML template would be the below, where `{{ form }}` unpacks the Python code into HTML:

    <form action="/your-name/" method="post">
        {% csrf_token %}
        {{ form }}
        <input type="submit" value="Submit" />
    </form>

Note that if you are creating an editable item and you want to edit existing content inside that object, you can instantiate it with the object.

     obj = MyStuff.objects.get(id=pk)
     form = MyStuffForm(instance=obj)

##<a id="context">Context</a>

Once you have a Template object, you can reuse the same template to render it several times with different contexts.  A __context__ is basically a dictionary with variables names as the key and the values as the value.  Normally you pass a fully populated dictionary to `Context()` and modify it using standard dictionary syntax.

The context class is under `django.template.Context` and takes a couple arguments (name of the application and a dictionary mapping of the variable names to variable values)

    >>> from django.template import Template, Context
    >>> template = Template("My name is {{ my_name }}.")
    >>> context = Context({"my_name": "Will"})
    >>> template.render(context)
    "My name is Will."
    >>> context = Context({"my_name": "Bill"})
    >>> template.render(context)
    "My name is Bill."

##<a id="contextstack">Context Stack: Push() and Pop()</a>

A Context object is a stack; this means you can __push()__ and __pop()__.  By default a Context has 'True', 'False', 'None' values defined.

    >>> c = Context()
    >>> c['foo'] = 'first level'
    [{'False': False, 'None': None, 'foo': 'first level'}]
    >>> c.push()
    {}
    >>> c
    [{'False': False, 'None': None, 'foo': 'first level', 'True': True}, {}]
    >>> c['foo'] = 'second level'
    [{'False': False, 'None': None, 'foo': 'first level', 'True': True}, {'foo': 'second level'}]

####<a id="requestcontext">RequestContext</a>

There's a special subclass of the Context class called a __RequestContext__ that instead of taking an application name, takes a __HttpRequest__.  This RequestContext takes in a __context_processors__ configuration option that returns a dictionary of items to be merged into the context.  This is under `django.template.RequestContext`.

####<a id="contextprocessor">Context Processor</a>

In Django, if you want to put the __context__ dictionary everywhere, you can create a __Context Processor__.  So remember that a context is just a dictionary of keys and values being mapped into a template.  A context processor is just a variable in your `settings.py` file (__TEMPLATE_CONTEXT_PROCESSORS__) where the purpose is that you don't need to specify what each context is, the key/values are automatically included in all your requests.  A use case would be to insert certain variables inside your template that you would like to use in everything (e.g. a User's location).  If you don't want to include these dictionaries everywhere, you can just specify for a specific instance by using only `RequestContext`.  You can also add an optional third argument called __processors__ to pass in some additional processors.

    # want context processors listed in settings.py as well as some more specific ones
    return render_to_response('template.html', {'foo':'bar'}, context_instance=RequestContext(request, processors=extra_processors))
    
    # want only context processors listed in settings.py
    return render_to_response('template.html', {'foo':'bar'}, context_instance=RequestContext(request))
    
    # no context processors
    return render_to_response('template.html', {'foo':'bar'})

##<a id="users">Users</a>

Django handles both user authentication and authorization.  __Authentication__ says that a user is who they claim to be (authentication is through `django.contrib.auth`).  __Authorization__ says what a user is allowed to do (permissions is through `django.contrib.contenttypes`.

    >>> from django.contrib.auth.models import User
    >>> user = User.objects.create_user(username='will', email='william.q.liu@gmail.com', password='mypassword')
    >>> user.set_password('newpassword')
    >>> user.save()

####<a id="createsuperuser">Create Superusers</a>

You can create superusers using `python manage.py createsuperuser --username=will --email=william.q.liu@gmail.com`

####<a id="permissions">Permissions</a>

Django can assign permissions to individual users and to groups of users in the admin site.  You can extend this to your site if you want.  Users have an __add__, __change__, and __delete__ permissions.

####<a id="loginrequired">Login Required</a>

So what can you do with users?  You can make certain views available only if the user is logged in using the `@login_required` decorator (`from django.contrib.auth.decorators import login_required)`.  If the user isn't logged in, it redirects them to `settings.LOGIN_URL`.

####<a id="permissionrequired">Permission Required</a>

To check if a user has a particular permission, we can use the `permission_required` decorator.

    from django.contrib.auth.decorators import permission_required
    
    @permission_required('polls.can_vote')
    def my_view(request):
        ....

####<a id="userpassestest">User Passes Test</a>

Additionally, you can have the logged in User pass a certain check (e.g. if email ends in @jobwaffle.com) before accessing a view.  Remember that users can be anonymous.

    from django.contrib.auth.decorators import user_passes_test
    
    def email_check(user):
        return user.email.endswith('@jobwaffle.com')
    
    @user_passes_test(email_check)
    def my_view(request):
        ...

##<a id="serializers">Serializers</a>

Django has a serialization framework that translates Django models into other usable formats like XML, JSON, or YAML.  Note that Django's serializers is different than the Python json library.

####<a id="dumpdata">`dumpdata` management command</a>

If you want to get data from your tables, you can run `python manage.py dumpdata`.  You can specify the format (e.g. JSON), the app, and/or database.

####<a id="loaddata">`loaddata` management command</a>

If you want to get data into tables, you can run `python manage.py loaddata`.  You can specify the format (e.g. JSON), the app, and/or database.  This is good for loading fixtures.

##<a id="middleware">Middleware</a>

Middleware hooks into Django's request and response cycle.  It's a plugin system for globally altering the input or output.  You can activate common middleware (like Authentication, CSRF protection, messaging, sessions), or you can write your own.  Middleware is defined in your `settings.py` as __MIDDLEWARE_CLASSES__.  

####<a id="middlewareorder">Middleware Order</a>

Remember that the order of the middleware matters because it'll determine when the middleware is processed.

*  During a __request__, middleware is applied top to bottom and we have the following hooks in this order.  Each function will either return __None__, which means it'll continue processing or a __HttpResponse__ object and Django will stop processing anything else.:
    -  __process_request()__ - called on each request before Django determines the view.
    -  __process_view()__ - called just before Django calls the view.
*  Once the request hooks pass through the middleware, it hits the __view__ function before the response hooks pass through the middleware.
*  During a __response__, middleware is applied bottom to top and we have the following hooks in this order:
    -  __process_exception()__ - only if the view raised an exception
    -  __process_template_response()__ - only for template responses
    -  __process_response()__

####<a id="middlewarefolders">Middleware Folders</a>

You normally setup your middleware in:

*  apps
    -  appspecific
        +  middleware
            *  `__init__.py`
            *  `my_middleware.py`

Then the actual middleware looks like:

     class MyMiddleWare(object):
         def process_request(self, request):
             print "My middleware has been accessed!"
             print request.path

##<a id="signals">Signals</a>

Django has __signals__ that help decoupled applications get notifications when something occurs.  There are __senders__ that send a __signal__ to alert __receivers__ that take some action has taken place.  In order to be decoupled from applications, I recommend placing a __signals__ folder right under your app name, then registering a __handlers.py__ and an __apps.py__.

####<a id="signalsbuiltin">Built-In Signals</a>

There are built-in senders that include:

*  send signal based on models `.save()` method with __pre_save__ and __post_save__
*  send signal based on models or querysets `.delete()` method with __pre_delete__ and __post_delete__

####<a id="signalslisten">Listening to Signals with Receivers</a>

In order to receive a signal, you have to make and register a __receiver__ function that gets called when a signal is sent.  We accomplish this with `Signal.connect()`.  

In this example, we make the receiver function (`my_callback`) that is called when a request is finished (using the built-in `request_finished` signal).

    from django.core.signals import request_finished, pre_save
    from myappname.models import MyModel
    
    # Receiver function
    def my_callback(sender, **kwargs):
        print "Request finished!"
    
    @receiver(pre_save, sender=MyModel)  # can use a decorator instead of connect()
    def my_callback_specific_model(sender, **kwargs):
        print "This is only called when MyModel does a pre_save"
        
    # connect signal, dispatch_uid is used to make sure no duplicate signals
    request_finished.connect(my_callback, dispatch_uid="my_unique_identifier")

####<a id="signalssend">Sending Signals</a>

You can send signals using two ways (`Signal.send(sender, **kwargs)` or `Signal.send_robust(sender, **kwargs)`) where `sender` is a Class.  THe difference between these two methods is that `send()` does not catch any exceptions raised by receivers while `send_robust()` catches errors and receives are notified.  These return a list of tuple pairs (`[(receiver, response), ...]`).  For example:

    import django.dispatch
    
    class PizzaStore(object):
    
        def send_pizza(self, toppings, size):
             pizza_done.send(sender=self.__class__, toppings=toppings, size=size)
    
    # creates a pizza_done signal that provide receivers with arguments for 'toppings' and 'size'
    pizza_done = django.dispatch.Signal(providing_args=["toppings", "size"])


