---
layout: post
title: Django
---

## {{ page.title }}

- - - -

##Table of Contents

*  [Summary](#summary)
*  [Object Relational Mapper](#orm)
    -  [Shell Plus](#shellplus)
    -  [Object and QuerySets](#objectqueryset)
    -  [Object Fields](#ormobjectfields)
    -  [ORM Shortcut Combinations](#ormshortcuts)
    -  [Chaining QuerySets](#chainingquerysets)
    -  [Iterating through QuerySets](#ormiterable)
    -  [Complex Queries with Q](#complexqueriesq)
*  [Views](#views)
    -  [requests](#requests)
    -  [render_to_response()](#rendertoresponse)
    -  [render()](#render)
*  [Templates](#templates)
    -  [Template Variables](#templatevariables)
    -  [Template Tags](#templatetags)
*  [Forms](#forms)
    -  [HTML forms](#htmlforms)
    -  [GET and POST](#getpost)
    -  [Django HTML Forms Template](#djangoformshtmltemplate)
    -  [Django Form Process](#djangoformsprocess)
    -  [Django Forms Code](#djangoformscode)
*  [Context](#context)
    -  [Context Stack](#contextstack)
    -  [RequestContext](#requestcontext)
    -  [Context Processor](#contextprocessor)
*  [User Authentication and Authorization](#users)
    -  [Create Superuser](#createsuperuser)
    -  [Permissions](#permissions)
    -  [@login_required](#loginrequired)
    -  [@permission_required](#permissionrequired)
    -  [@user_passes_test](#userpassestest)
*  [Serializers](#serializers)
    -  [`dumpdata` command](#dumpdata)
    -  [`loaddata` command](#loaddata)
*  [Middleware](#middleware)
    -  [Middleware Order](#middlewareorder)
    -  


##<a id="summary">Summary</a>

__Django__ is a web framework in Python.  The idea is to be able to receive requests and send responses.

##<a id="orm">Object Relational Mapper</a>

Django has an __Object Relational Mapper (ORM)__ that takes database tables and represents this as Python objects.

*  One or more objects?

You can either __query__ for one object or if there are multiple objects, you'll get an iterable called a __QuerySets__ (which is a collection of objects from your database).  This is like a SELECT statement in SQL.

*  Filters

You can have zero, one, or more filters to narrow down your query results.  This is like the WHERE or LIMIT statements in SQL.

*  Manager

You interact with a Queryset with the Model's __Manager__.  Each model has at least one __Manager__ and it's called __objects__ by default.  Managers are only accessible via the model classes, not from the model instances.

    >>> Blog.objects
    <django.db.models.manager.Manager object at ...>

*  Lazy

QuerySets are lazy in that they don't do any database activity until the QuerySet is evaluated.

####<a id="shell">Shell and Shell_Plus</a>

You can interact with the ORM using `python manage.py shell`.  If you have the library `django-extensions`, you can use `python manage.py shell_plus` to automatically load in all your django models.  You can exit with the `exit()` command.

####<a id="objectqueryset">Difference between Object and QuerySet</a>

Here's the difference between an individual Object and a QuerySet (collection of objects).

    >>> me = User.objects.get(username='wliu')
    >>> me
    <User: wliu>
    >>> type(me)
    accounts.models.User
    
    >>> me = User.objects.all()[:1]
    >>> me
    [<User: admin>]
    >>> type(me)
    django.db.models.query.QuerySet


####<a id="ormget">ORM Get</a>

You can get specific objects from the database.

    >>> me = User.objects.get(username='will')

To get all the models in your database, do:

    >>> from django.apps import apps
    >>> apps.get_models()
    [django.contrib.admin.models.LogEntry,
     accounts.models.User,
     blog.models.BlogPost,
     blog.models.Comment
    ]

####<a id="ormobjectfields">ORM Object Fields</a>

To get all the fields in your model, do:

    >>> Comment._meta.fields  # does not include reverse relations
    [<django.db.models.fields.AutoField: id>,
     <django.db.models.fields.related.ForeignKey: blogpost>,
     <django.db.models.fields.TextField: content>,
     <django.db.models.fields.DateField: date_created',
     <django.db.models.fields.related.OneToOneField: user>]
    
    >>> Comment._meta.get_all_field_names()  # includes reverse relations
    ['blogpost',
    u'blogpost_id',
     'content',
     'date_created',
     'id',
     'user']

####<a id="ormselect">ORM Select All</a>

You can select objects from the database.  Suppose we have a model `Post` from our app `blogs`.

    >>> from blog.models import Post
    >>> Post.objects.all()
    [<Post: my post title>, <Post: another post title>]


####<a id="ormcreate">ORM Create</a>

You can create objects in the database.

     >>> from django.contrib.auth.models import User
     >>> Post.objects.create(author=me, title='Sample title', text='Test')

####<a id="ormfilter">ORM Filter</a>

You can filter objects.  You can use two `_` characters between a field name and a filter operation (e.g. title and contains).

    >>> Post.objects.filter(author=me)
    >>> Post.objects.filter(title__contains='title')

####<a id="ormrelational">ORM Relational</a>

So say you have a Blog model that has a field (_user_) that is related as a ForeignKey to a User model (that we're trying to access the _username_ field).  You can filter for the Blogs that are by that user using:

    >>> mypost = Blog.objects.filter(user__username__exact='william')

####<a id="ormpublish">ORM Publish</a>

You can publish items in the database.

    >>> mypost = Post.objects.get(title='Sample title')
    >>> mypost.publish()

####<a id="ormdelete">ORM Delete</a>

You can delete items in the database.

    >>> mypost = Post.objects.get(title='Sample title')
    >>> mypost.delete()

####<a id="ormupdate">ORM Update</a>

You can update items in the database.

    >>> mypost = Post.objects.filter(title='Sample title').update(is_active=False)

####<a id="ormorderby">ORM Order by</a>

You can order the list of objects.

    >>> Post.objects.order_by('created_date')
    >>> Post.objects.order_by('-created_date')

####<a id="ormlimit">ORM Limit</a>

You can limit the number of items.

    >>> Post.objects.all()[:5]  # return first 5 objects

####<a id="ormshortcuts">ORM Shortcut Combinations</a>

A lot of times you'll want to get an item and if it isn't there, do an action (like Create or return a 404 response).  This is a shortcut to doing the long way of Try/Except.

    # Long way
    try:
        obj = Person.objects.get(first_name='Will', last_name='Liu')
    except Person.DoesNotExist:
        obj = Person(first_name='Will', last_name='Liu')
        obj.save()
    
    # Shortcut
    obj, created = Person.objects.get_or_create(first_name='Will', last_name='Liu')

The `get_or_create` shortcut will return the object and whether it was created (True or False).  If multiple items appear, then error `MultipleObjectsReturned` is raised.

There's plenty of these shortcuts including:

*  `get_or_create`
*  `update_or_create`
*  `get_object_or_404`


####<a id="ormcopy">ORM Copying Objects</a>

You can copy objects by setting the __pk__ to _None_.    

     >>> mypost = Post(name='My Post', comment='This is my comment')
     >>> mypost.save()  # mypost.pk == 1
     >>> mypost.pk = None
     >>> mypost.save()  # mypost.pk == 2

####<a id="ormvalues">ORM to values</a>

Often you'll want to take a Model object and turn that into a dictionary.  You can specify field names by passing in the field names into values() as arguments.

    # this list contains Model objects
    >>> Blog.objects.filter(name__startswith='Beatles')
    <Queryset [<Blog: Beatles Blog>]>
    
    # this list contains a dictionary
    >>> Blog.objects.filter(name__startswith='Beatles').values()
    <QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest news'}]>

####<a id="chainingquerysets">Chaining QuerySets</a>

You can chain QuerySets together to write complex queries.

     >>> Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')

####<a id="ormiterable">Iterating through QuerySets</a>

Since QuerySets are iterables of multiple objects, you can iterate through the objects.

     >>> queryset = Post.objects.all()
     >>> print([x.somefield for x in queryset])
     >>> print([x.someotherfield for x in queryset])  # this is cached from evaluation earlier

####<a id="complexqueriesq">Complex Queries with Q</a>

A __Q object__ is an object used to encapsulate a collection of keyword arguments.

    >>> from django.db.models import Q
    >>> Q(question__startswith='Who') | Q(question__startswith='What')  # Who or What
    >>> ~Q(pub_date__year=2005) # not published on 2005
    >>> Poll.objects.get(Q(question__startswith='Who', ~Q(pub_date__year=2005) | Q(pub_date__year=2002))

##<a id="views">Views</a>

When the server gets a __request__, a __view__ decides what models and templates to use.  You can render views using `render` and `render_to_response`.  A view always returns either a `HttpResponse` or a 404.

####<a id="requests">requests</a>

When you get a request, there's important information in the __request.META__, which is a Python dictionary that has all the available HTTP Headers (e.g. user IP Address, user agent info like the web browser).  Do note that this information does not have to exist.  Useful header info includes:

*  __HTTP_REFERER__ - The referring URL, if any.
*  __HTTP_USER_AGENT__ - User's browser (e.g. Firefox)
*  __REMOTE_ADDR__ - The IP Address of the client

####<a id="rendertoresponse">render_to_response()</a>

You receive a request and this creates a response.  If you use this, your template is passed a __Context__ instance by default (not a __RequestContext__).

####<a id="render">render()</a>

The render shortcut is the same as `render_to_response()` except there is a __context_instance__ argument that forces the use of __RequestContext__.

##<a id="template">Template</a>

A template determines how to display information.  Technically, a template is a text file that can be any text format (e.g. HTML, CSV, XML).  These templates contain __variables__, which are replaced with values when the template is evaluated.  There are also __tags__, which control the logic of the template (e.g. for loop through a list of items).

The template engine's goal is meant to express presentation of data, not program logic.

####<a id="templatevariables">Template Variables</a>

Template variables look like `{{ my_variable }}`.  When a variable is encountered, the engine replaces the variable with the result.  Use the `_` if you need spacing and the `.` if you need to access attributes of the variable.

####<a id="templatetags">Template Tags</a>

Template tags look like `{% tag %}`.  They can have for-loops and if/elif/else statements.  If any variables are invalid, they are seen as __None__.

__for-loops__

    <ul>
    {% for athlete in athlete_list %}
      <li>{{ athlete.name }}</li>
    {% endfor %}
    </ul>

__if, elif, else__

    {% if athlete_list %}
        Number of athletes: {{ athlete_list|length }}
    {% elif athlete_in_locker_room_list %}
        Athletes should be out of the locker room soon!
    {% else %}
        No athletes.
    {% endif %}

##<a id="forms">Forms</a>

Forms allow you to accept input from users and processes how to respond.  

####<a id="htmlforms">HTML Forms</a>

In HTML, forms are a collection of elements inside the `<form> ... </form>` tags that allow users to enter text, select options, and basically provide user input (often using the HTML `<input>` elements).  Forms must specify:

*  __What__ data should be sent (usually defined by the `<input>` elements).  This is could be say an input of `<type="text">` for a text input box or `<type="submit">` for a button.
*  __Where__ to send the data (i.e. the URL endpoint).  This is normally under the form's __action__ attribute (e.g. route to the url for `/admin/`)
*  __How__ to send the data (i.e. what HTTP method, for Django forms this is either a __GET__ or __POST__).  

####<a id="getpost">Form GET and POST</a>

With Django's __GET__ method, a GET is used to send data that does not affect the state of the system and can be public (e.g. web search would appear as `website.com/search/?forms&release=1`).

With Django's __POST__ method, the browser gets all the form data together, encodes it to send, sends it to the server, then receives back a response.  POST is used to make changes in the database or for private data.

####<a id="djangoformshtmltemplate">Django HTML Form Template</a>

Here is a form that gets a user's name through the `<input>` tags, returns the form to the URL `/your-name/` with a POST method, displays a text field label indicating to the user to input their name, and pre-fills the `{{ current_name }}` if it exists.

    <form action="/your-name/" method="post">
        <label for="your_name">Your name: </label>
        <input id="your_name" type="text" name="your_name" value="{{ current_name }}">
        <input type="submit" value="OK">
    </form>

####<a id="djangoformsprocess">Django Form Process</a>

In Django, when we render an object, we typically do these steps:

*  Get the view (i.e. this tells us the template and model)
*  Pass the view the template context (i.e. a dictionary with keys and values)
*  Then expand it to HTML markup using template variables

Rendering a form has similar steps except when we instantiate a form, we have the possible options:

*  Create a form that is empty
*  Pre-populate the form from a saved model or some other data source (i.e. there's already data filled out)

####<a id="djangoformscode">Django Forms Code</a>

If we want to move away from the Django HTML Form Template and into Python code, we can do that with Django forms.

    # forms.py
    from django import forms
    
    class NameForm(forms.Form):
        your_name = forms.CharField(label='Your name', max_length=100)

This code takes the Form instance and does a `is_valid()` method check, which runs validation routines for all the fields.  When this is called, if all fields have valid data, it returns `True` and places the form's data in the __cleaned_data__ attribute.

    <label for="your_name">Your name: </label>
    <input id="your_name" type="text" name="your_name" maxlength="100">

Note that this does not include the `<form>` tags or a submit button, we'll need to manually provide these.

The form is sent to the view.

    #views.py
    from django.shortcuts import render
    from django.http import HttpResponseRedirect
    
    from .forms import NameForm
    
    def get_name(request):
        # if POST request, we need to process the form data
        if request.method == 'POST':
            # create a form instance and populate it with data from the request
            form = NameForm(request.POST)
            # check if form is valid
            if form.is_valid():
                # Process the data in form.cleaned_data
                # Then redirect to a new URL
                return HttpResponseRedirect('/thanks/')
        # if GET (or any other method) we create a blank form
        else:
             form = NameForm()
    
        return render(request, 'name.html', {'form': form})

The new HTML template would be the below, where `{{ form }}` unpacks the Python code into HTML:

    <form action="/your-name/" method="post">
        {% csrf_token %}
        {{ form }}
        <input type="submit" value="Submit" />
    </form>

Note that if you are creating an editable item and you want to edit existing content inside that object, you can instantiate it with the object.

     obj = MyStuff.objects.get(id=pk)
     form = MyStuffForm(instance=obj)

##<a id="context">Context</a>

Once you have a Template object, you can reuse the same template to render it several times with different contexts.  A __context__ is basically a dictionary with variables names as the key and the values as the value.  Normally you pass a fully populated dictionary to `Context()` and modify it using standard dictionary syntax.

The context class is under `django.template.Context` and takes a couple arguments (name of the application and a dictionary mapping of the variable names to variable values)

    >>> from django.template import Template, Context
    >>> template = Template("My name is {{ my_name }}.")
    >>> context = Context({"my_name": "Will"})
    >>> template.render(context)
    "My name is Will."
    >>> context = Context({"my_name": "Bill"})
    >>> template.render(context)
    "My name is Bill."

##<a id="contextstack">Context Stack: Push() and Pop()</a>

A Context object is a stack; this means you can __push()__ and __pop()__.  By default a Context has 'True', 'False', 'None' values defined.

    >>> c = Context()
    >>> c['foo'] = 'first level'
    [{'False': False, 'None': None, 'foo': 'first level'}]
    >>> c.push()
    {}
    >>> c
    [{'False': False, 'None': None, 'foo': 'first level', 'True': True}, {}]
    >>> c['foo'] = 'second level'
    [{'False': False, 'None': None, 'foo': 'first level', 'True': True}, {'foo': 'second level'}]

####<a id="requestcontext">RequestContext</a>

There's a special subclass of the Context class called a __RequestContext__ that instead of taking an application name, takes a __HttpRequest__.  This RequestContext takes in a __context_processors__ configuration option that returns a dictionary of items to be merged into the context.  This is under `django.template.RequestContext`.

#### <a id="contextprocessor">Context Processor</a>

In Django, if you want to put the __context__ dictionary everywhere, you can create a __Context Processor__.  So remember that a context is just a dictionary of keys and values being mapped into a template.  A context processor is just a variable in your `settings.py` file (__TEMPLATE_CONTEXT_PROCESSORS__) where the purpose is that you don't need to specify what each context is, the key/values are automatically included in all your requests.  A use case would be to insert certain variables inside your template that you would like to use in everything (e.g. a User's location).  If you don't want to include these dictionaries everywhere, you can just specify for a specific instance by using only `RequestContext`.  You can also add an optional third argument called __processors__ to pass in some additional processors.

    # want context processors listed in settings.py as well as some more specific ones
    return render_to_response('template.html', {'foo':'bar'}, context_instance=RequestContext(request, processors=extra_processors))
    
    # want only context processors listed in settings.py
    return render_to_response('template.html', {'foo':'bar'}, context_instance=RequestContext(request))
    
    # no context processors
    return render_to_response('template.html', {'foo':'bar'})

## <a id="users">Users</a>

Django handles both user authentication and authorization.  __Authentication__ says that a user is who they claim to be (authentication is through `django.contrib.auth`).  __Authorization__ says what a user is allowed to do (permissions is through `django.contrib.contenttypes`.

    >>> from django.contrib.auth.models import User
    >>> user = User.objects.create_user(username='will', email='william.q.liu@gmail.com', password='mypassword')
    >>> user.set_password('newpassword')
    >>> user.save()

#### <a id="createsuperuser">Create Superusers</a>

You can create superusers using `python manage.py createsuperuser --username=will --email=william.q.liu@gmail.com`

#### <a id="permissions">Permissions</a>

Django can assign permissions to individual users and to groups of users in the admin site.  You can extend this to your site if you want.  Users have an __add__, __change__, and __delete__ permissions.

#### <a id="loginrequired">Login Required</a>

So what can you do with users?  You can make certain views available only if the user is logged in using the `@login_required` decorator (`from django.contrib.auth.decorators import login_required)`.  If the user isn't logged in, it redirects them to `settings.LOGIN_URL`.

#### <a id="permissionrequired">Permission Required</a>

To check if a user has a particular permission, we can use the `permission_required` decorator.

    from django.contrib.auth.decorators import permission_required
    
    @permission_required('polls.can_vote')
    def my_view(request):
        ....

#### <a id="userpassestest">User Passes Test</a>

Additionally, you can have the logged in User pass a certain check (e.g. if email ends in @jobwaffle.com) before accessing a view.  Remember that users can be anonymous.

    from django.contrib.auth.decorators import user_passes_test
    
    def email_check(user):
        return user.email.endswith('@jobwaffle.com')
    
    @user_passes_test(email_check)
    def my_view(request):
        ...

## <a id="serializers">Serializers</a>

Django has a serialization framework that translates Django models into other usable formats like XML, JSON, or YAML.  Note that Django's serializers is different than the Python json library.

#### <a id="dumpdata">`dumpdata` management command</a>

If you want to get data from your tables, you can run `python manage.py dumpdata`.  You can specify the format (e.g. JSON), the app, and/or database.

#### <a id="loaddata">`loaddata` management command</a>

If you want to get data into tables, you can run `python manage.py loaddata`.  You can specify the format (e.g. JSON), the app, and/or database.  This is good for loading fixtures.

## <a id="middleware">Middleware</a>

Middleware hooks into Django's request and response cycle.  It's a plugin system for globally altering the input or output.  You can activate common middleware (like Authentication, CSRF protection, messaging, sessions), or you can write your own.  Middleware is defined in your `settings.py` as __MIDDLEWARE_CLASSES__.  

#### <a id="middlewareorder">Middleware Order</a>

Remember that the order of the middleware matters because it'll determine when the middleware is processed.

*  During a __request__, middleware is applied top to bottom and we have the following hooks in this order.  Each function will either return __None__, which means it'll continue processing or a __HttpResponse__ object and Django will stop processing anything else.:
    -  __process_request()__ - called on each request before Django determines the view.
    -  __process_view()__ - called just before Django calls the view.
*  Once the request hooks pass through the middleware, it hits the __view__ function before the response response hooks pass through the middleware.
*  During a __response__, middleware is applied bottom to top and we have the following hooks in this order:
    -  __process_exception()__ - only if the view raised an exception
    -  __process_template_response()__ - only for template responses
    -  __process_response()__


