---
layout: post
title: Golang
---

## {{ page.title }}


- - - -

##<a id="summary">Summary</a>

__Go__ is an open source programming language that focuses on __concurrency__ (i.e.  instead of sequentially/one after another).

###Why Go?

There's __sequential computing__, which runs one command first, then another as soon as the first is completed.  __Concurrent computing__ is different in that it has many computations executing during overlapping time periods.  

__Concurrent computing__ is commonly confused with __Parallel computing__, but it doesn't mean the same thing.  Parallel computing is like if you have multiple cpu cores, multiple computations occur at the same time. Concurrent is like if you have multiple threads and your cpu switches between these threads.

##<a id="install">Install</a>

* Mac: Install Go with homebrew doing: `brew install go`.
* Ubuntu: Install with apt-get doing: `sudo apt-get install golang-go`

##<a id="tools">Go Tools</a>

Go comes with a bunch of tools for managing Go code. You can access by typing in `go`. 
Some of these tools can you help `build` (compile code), `install` packages and dependences and run programs.

###<a id="goget">Go Get</a>

You can get source code by using `go get`.  For example, using `go get golang.org/x/tour/gotour`.

###<a id="goinstall">Go Install</a>

You compile and install packages and dependencies using `go install`.

###<a id="workspace">Workspace Directory Tree</a>

So now you have some code, it should look something like this format:

    bin/
        hello  # an executable file (e.g. $hello) runs the file
    pkg/
        darwin_amd64/
            github.com/
                williamqliu/
                    go-examples  # a package that we made
                        string
                        string.a  # package object
            golang.org  # a package that we got using go get
                x/
                    net/
                    tools/
                    tour/... # goes down further to more package objects
    src/
        github.com/
            williamqliu/
                go-examples/
                    hello/
                        hello.go  # our source code
                        hello_test.go  # test code (must have _test in name)
        golang.org
            ...

###<a id="packages">Packages</a>

Every Go program is made up of packages.
Packages start running in package `main`.
A sample progam looks like:

    package main
    
    import(
        "fmt"
        "math/rand"
    )
    
    func main() {
        fmt.Println("My favorite number is", rand.Intn(10))
    }

You need the package name as `main` and the func as `main`.  
You can have additional functions (e.g. say add), but you also have to define `main`.

A name is exported if it begins with a capital letter.  
E.g. if you write a function `Pi` in the `math` package, you can access this as `math.Pi`.

###<a id="samplecode">Sample Code</a>

Okay let's see some sample code already.

    package main
    
    import (
        "fmt"
        "math/rand"
        "time"
    )
    
    var c, python, java bool  // the 'type' (e.g. bool) goes after the variable name
    var d, e int = 1, 2  // you can initialize variables
    
    const Pi = 3.14  // you can make a constant with =. constants cannot be used with := syntax
    
    func add(x, y int) int {  // same as: x int, y int
        return x + y
    }
    
    func swap(x, y string) (string, string) {
        return y, x
    }
    
    func split(sum int) (x, y int) {  // pass in a named variable 'sum'
        x = sum * 4 / 9
        y = sum - x
        return  // a 'naked' return (i.e. no arguments) returns the named values
    }
    
    func main() {
        fmt.Printf("Hello, world\n")  // Default format with Printf
        fmt.Println("My favorite number is", rand.Intn(10))  // Print line
    
        k := 3  // := is used in place of a 'var' declaration, creates with an implicit type

        for i:=0; i < 10; i++ {
            sum += i
        }
        fmt.Println(sum)

        fmt.Println("These two numbers added together are:", add(42, 13))  // using the 'add' function we made
    
        a, b := swap("First", "Second")  // using the 'swap' function we made
        fmt.Println(a, b)
    
        fmt.Println(split(17))  // using the 'split' function we made
    
        var i int
        fmt.Println(i, c, python, java)  // by default, things are 0 or false (depending on type)
    
        var c, python, java = true, false, "No!"  // you can initialize variables
        fmt.Println(d, e, c, python, java)
    
        k := 3  // a short variable declaration means let Go figure out the type
        fmt.Println(k)
    
        w := 42  // same as: var w int = 42
        x := float64(w)  // doing a type conversion from int to float64, same as: var f float64 = float64(i)
        y := uint(x)  // a uint is a 'byte', same as: var u uint = uint(f)
        z := rune(y)  // a rune is an `int32`, mainly for Unicode code point
        fmt.Println(z)  // If you declare a variable, you have to use it or else it's an error!
        fmt.Println("Pi is", Pi)

        fmt.Println("The time is", time.Now())
    }

You can then run the program with:

* `go build`
* `go run hello.go`

## Control Flow

### For loops

Similar to other for loops with an init, a condition expression (evaluated 
before every iteration), and a post statement (evaluated at end of every 
iteration). Notice there are no parenthesis surrounding the components of 
these for loops. The `init` and `post` statements are optional (this means 
that `while` is `for` in Go)

    sum := 0
    for i :=0; i < 10; i++ {
        sum += i
    }
    fmt.Println(sum)

    // no need to setup init and post sections
    sum :=1
    for ; sum < 1000; {
        sum += sum
    }
    fmt.Println(sum)
    
    // for-loop is the while loop
    sum := 1
    for sum < 1000 {
        sum += sum
    }
    fmt.Println(sum)

    // if you omit everything, an infinite loop is created
    for {
    }

### if statements

Just like for-loops, you do not need parenthesis `()` around an if statement,
but `{}` are required.

    if x < 0 {
        fmt.Println("Hey")
    }

    // You can do a short statement to execute before the condition that is 
    // only in scope until the end of the if statement
    func pow(x, n, lim float64) float64 {
        if v := math.Pow(x, n); v < lim {
            return v
        } else {
            fmt.Printf("%g >= %g\n", v, lim)
        }
        return lim
    }
    fmt.Println(pow(3, 2, 10))

### switch statemnets

Switch statements are pretty normal, parsing from top to bottom. If no 
condition is given, then same as `switch true`, which helps save long 
if-else statements.

    switch os := runtime.GOOS; os {
    case "darwin":
        fmt.Println("OS X")
    case "linux":
        fmt.Println("Linux")
    default:
        fmt.Printf("%s", os)
    }

   
    // switch without a condition
    t := time.Now()
    switch {
    case t.Hour() < 12:
        fmt.Println("Good morning!")
    case t.Hour() < 17:
        fmt.Println("Good afternoon.")
    default:
        fmt.Println("Good evening.")
    } 

### Defer

A defer statement defers the execution of a function until the surrounding 
function returns. Deferred call's arguments are evaluated immediately, but 
the function call is not executed until the surrounding funtion returns.

    defer fmt.Println("world")
    fmt.Println("hello")

Deferred function calls are pushed onto a stack. When a function returns, its
deferred calls are executed in last-in-first-out order.

    fmt.Println("counting")
    for i := 0; i < 10; i++ {
        defer fmt.Println(i)
    }
    fmt.Println("done")
