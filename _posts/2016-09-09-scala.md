---
layout: post
title: Scala
---

## {{ page.title }}


- - - -

#Summary

These are my notes from taking the Coursera course **Functional Programming Principles in Scala** taught by Martin Odersky himself. The course teaches you about functional programming and we just happen to use Scala.

#Week 1 (Lesson 1)

##Programming Paradigms

There's three main programming paradigms (these describe distinct concepts or thought patterns in programming). They are:

* imperative programming (e.g. Java, C)
* functional programming
* logic programming
* note: object-oriented programming is orthogonal to these and can be combined with both imperative and functional programming

###What is Imperative Programming?

* modifies mutable variables,
* using assignments
* and control structures such as if-then-else, loops, break, continue, return

####Von Neumann Computer
Wait, what? So most computers are under this model called the __Von Neumann computer__ (aka **Princeton Architecture**); the idea is that we have a **CPU** connected to **Memory** via a **Bus**, where the width of the Bus is about one machine word (e.g. 32bit, 64bit). The CPU processes instructions while the Memory holds more instructions and/or data.

####Von Neumann Bottleneck
With this architecture, computers can either read data that's in memory OR pass the next instruction; they can't do both at the same time and this is a bottleneck called the **von Neumann bottleneck**.

This setup has affected how we program.

* Mutable variables corresponds with memory cells
* Variable deferences corresponds with load instructions
* Variable assignments corresponds with store instructions
* Control structures corresponds with jumps

With this setup, we're conceptualizing programs word by word and that's bad for performance (when we try to scale up). Instead we want to define high-level abstractions such as collections, shapes, documents, etc. What we need are **theories**.

####Theories
What we want out of these theories is a way to create high-level abstractions for different data types. These theories consist of data types and the operations on these data types; a theory does NOT allow **mutations** (e.g. you can't define a variable as a specific value, then change that variable's value). Let's think about it; if you do mutations, it destroys the point of having these high-level concepts. Here's an example of imperative programming using classes (a way to abstract) doing mutations by assigning a coefficient to the Class.

    class Polynomial { double[] coefficient; }
    Polynomial p = ...;
    p.coefficient[0] = 42;

###What is Functional Programming?

You can think of functional programming as a glass half full or half empty.

* Glass Half Empty - Functional programming means programming without mutable variables, assignments, loops, and other imperative control structures
* Glass Half Full - Functional programming means focusing on how functions and how their values can be produced, consumed, and composed. This means functions are **first-class citizens**; you can define functions anywhere (even inside other functions, pass functions as parameters, etc) just like you can define and pass a string anywhere in imperative programming.

#Week 1 (Lesson 2 and 3)

##Scala REPL

Scala's REPL (Read-Eval-Print-Loop) is an interactive shell that can be started with either one of the commands `scala` or `sbt console` (for the scala build tool).

##What are Functions?

Good question. We have a lot of primitive expressions that defines the simplest elements of the language (say this is a string, that is a number). Well, functions just wrap all of that together nicely.  

##How functions are evaluated

One of the most important things with Scala is how you evaluate functions; think back in elementary school when you learned about PEMDOS and how it applies rules of precedence for Math, but this is for programming. Well, this is just like simple algebra. We call this the **Substitution Model** and we apply these steps one by one so that `all evaluation does is reduce an expression to a value`.

1. Take the leftmost operator
2. Evaluate its operands (left before right)
3. Apply the operator to the operands.

##Parameters

You can define a Function with parameters. Notice how the variable type (e.g. Double) comes after the variable name (e.g. x)

    def square(x: Double) = x * x
    def sumOfSquares(x: Double, y: Double) = square(x) + square(y)

##Evaluation Strategies

There's two ways you can evaluate functions, through **call-by-value (CBV)** and **call-by-name (CBN)**. Both strategies end up reducing to the same final values, but its important because depending on the function, some may terminate (to get a final value) while others (when CBV is used) sometimes goes into an infinite loop! Performance is also different; CBV calls a function argument once, but sometimes some function arguments don't need to be called; the reverse can be true and some CBN can evaluate the function argument multiple times. 

###Call by Value (CBV)

CBV evaluates every function argument only once. Each function argument is reduced to a value before rewriting the function. Here's an example:

    sumOfSquares(3, 2+2)
    square(3) + square(2+2) # keep right hand side, pass 2+2 as an expression
    3 * 3 + square(2+2)
    9 + square(2+2)
    9 + (2+2) * (2+2)
    25

###Call by Name (CBN)

CBN evaluates a function argument lazily (i.e. we'll evaluate the code only when it's called). Here's an example:

    def test(x: Int, y: Int) = x * x  # we pass in x, but y isn't needed so its not evaluated
    test(3+4, 8)
    (3+4) * (3+4)
    7 * (3+4)
    7 * 7
    49

###Forcing Evaluation Strategies

By default, Scala uses Call by Value (CBV) because usually this is much more efficient. However, CBV also has the issue that sometimes using this evaluation method will result in an infinite loop (whereas using CBN might not get into an infinite loop). If you want Scala to force use CBN (the non default), then add in `=>`.

#Week 1 (Lesson 4)

##Conditionals and Value Definitions

Scala has conditional expressions like `if-else` to help choose between two things. Notice that we say **expression** instead of **statement**.

###Expressions versus Statements

There's a key difference between these two; a **statement** is where you set a variable AND THEN return a variable. An **expression** (sometimes called **predicates**) is where you just return a value without needing to set a variable. 

###Boolean Expressions

    true, false # Constants
    !x # Negation
    b && b # Conjunction, i.e. AND
    b || b # Disjunction, i.e. OR

###Value and Definition Forms

**Definitions** (i.e. `def`) in a sense are CBN (because the right hand of the definition is evaluated on each use) while **Values** (i.e. `val`) is CBV  (because its a value).

#Week 1 (Lesson 5)

##Sample code doing Square Roots with Newtons Method

We want to create a function that calculates the square root of parameter x. The idea is to start with any positive initial estimate, then repeatedly improve our estimate by taking the mean of y and x/y.

    def sqrtIter(guess: Double, x: Double): Double =
        if (isGoodEnough(guess, x)) guess
        else sqrtIter(improve(guess, x), x)
    
    def isGoodEnough(guess: Double, x: Double) =
        abs(guess * guess - x) / x < 0.001
    
    def improve(guess: Double, x: Double) =
        (guess + x / guess) / 2
    
    def sqrt(x: Double) = sqrtIter(1.0, x)

#Week 1 (Lesson 6)

##Fight Name space pollution with Blocks

You can avoid name space pollution by using **blocks**, which means enclosing code with `{` and `}`. For example:

    def sqrt(x: Double) = {
        def sqrtIter(...)
        def isGoodEnough(...)
        def improve(...)
    } 

###Block Rules

* Definitions inside a block are only visible from within the block
* Definitions inside a block shadow definitions of the same names outside the block; this means that you can reuse outer method definitions without needing to explicitly pass those in

##Line Continuation
* Semicolons are optional (unless you want to put multiple statements in one line
* Expression (Line Continuation) can be done with either using **Parenthesis** or an **infix operator** on the previous line

###Parenthesis Example
    (someLongExpression
     + someOtherLongExpression)

###Infix Operator Example
    someLongExpression +
        someOtherLongExpression

#Week 1 (Lesson 7)

##Sample code doing Recursion

Try to create the 'Greatest Common Divisor' of two numbers; use an implementation using Euclid's algorithm.

###Attempt 1

While this works, you might get a Stackoverflow if the JVM keeps doing a deep recursive chain on a function that is not tail-recursive.

    def gcd(a: Int, b: Int): Int =
        if (b == 0) a else gcd(b, a %b)  # is a 'tail-recursive' call
    
    def factorial(n: Int): Int =
        if (n==0) 1 else n * factorial(n-1)  # not a 'tail-recursive' call, still have to compute n
 
###Attempt 2 (Refactored)

We want to attempt this implementation as a **tail-recursive** call, meaning that a function calls itself as its last action so that the function's stack frame can be reused. Now we won't get a stackoverflow.

    object exercise {
        def factorial(n: Int): Int = {
            def loop(acc: Int, n: Int) =
                if (n==0) acc
                else loop(acc * n, n-1)
            loop(1, n)
        }
    }

#Additional Notes

* `val` is a constant; you can't change it after being declared; try to keep things as `val` if possible
* `var` can change after declaration
* `.` calls a function and in Scala, functions are everywhere! Type in `.` with pressing `tab` to see methods are available
* Everything is a method. `a.+(b)` is the same as `a + b`. `1.to(10)` is the same as `1 to 10`
* You can import with `import scala.math._` where `_` is a wildcard. You can also omit the `scala` prefix so it's just `import math._`
* You can use the overloaded form of the `()` operator. E.g. the method `apply()


#Week 2 (Lesson 1)

##Higher-Order Functions

Functional languages treat functions as **first-class values**. This means that functions can be passed as a parameter and returned as a result. When a function takes other functions as parameters or return a function as a result, then they are **higher order functions**. This is similar to how other languages can pass around strings or numbers as parameters and results. Here's some examples:

    // Take the sum of the integers between a and b 
    def sumInts(a: Int, b: Int): Int = 
        if (a > b) 0 else a + sumInts(a + 1, b)
    
    // Take the sum of the cubes of all the integers between a and b
    def cube(x: Int): Int = x * x * x
    def sumCubes(a: Int, b: Int): Int = 
        if (a > b) 0 else cube(a) + sumCubes(a + 1, b)
    
    // Take the sum of the factorials of all the integers between a and b
    def sumFactorials(a: Int, b: Int): Int =
        if (a > b) 0 else fact(a) + sumFactorials(a + 1, b)

##Finding Patterns in Higher-Order Functions

Scala is a lot like Math (in particular Algebra). In Algebra, when you look at equations, you can do factoring. With the above examples, you can start seeing a pattern and find the common factor (i.e. what's in all of these expressions). We can sumInts, sumCubes, sumFactorials, or really sum anything. We want to ask ourselves, what is this common factor between all of these functions?

    // This sum method is our common factor
    def sum(f: Int => Int, a: Int, b: Int): Int =
        if (a > b) 0
        else f(a) + sum(f, a + 1, b)
    
    // We can now rewrite these methods like this
    def sumInts(a: Int, b: Int) = sum(id, a, b)
    def sumCubes(a: Int, b: Int) = sum(cube, a, b)
    def sumFactorials(a: Int, b: Int) = sum(fact, a, b)
    
    // We need some auxiliary functions
    def id(x: Int): Int = x
    def cube(x: Int): Int = x * x * x
    def factorial(x: Int): Int = if ( x == 0) 1 else fact(x-1)

##Function Types

The type `A => B` is the type of a function that takes an argument type A and returns a result of type B. An example would be `Int => Int` is the type of functions that map a Integers to Integers.

##Anonymous Functions

Earlier we created some auxiliary functions (e.g. `def id(x: Int): Int = x`). Instead of auxiliary functions, we can create anonymous functions for us to avoid having to define and name functions using def. A common example is that we don't need to define a string using def and then print it; we could just print the string.

    // Rewriting our examples as anonymous functions where we can define x inside the function
    def sumInts(a: Int, b: Int) = sum(x => x, a, b)
    def sumCubes(a: Int, b: Int) = sum(x => x * x * x, a, b)
    def sumFactorials(a: Int, b: Int) = sum(fact, a, b)
    
    // No need to do this
    def str = "abc"; println(str)
    
    // Instead we can directly write because strings are literals
    println("abc")


#Week 2 (Lesson 2)

##Currying

So now that we know about higher order functions, we want to look at **currying**, which is a special way of writing higher order functions. The idea is that your returned function might expect parameters, but they don't need to be explicitly passed in; what this solves is getting rid of repetition in your parameter list. For example, in our functions above (e.g. Lesson 1's Higher Order Functions, Anonymous Functions), we still need to pass in `a, b` into the parameter list.

We can rewrite __sum__ as a function that returns another function. __sum__ now only takes a single parameter `f` and it returns a function. The returned function `sumF` applies the given function parameter `f` and sums the results.

    def sum(f: Int => Int): (Int, Int) => Int = {
        def sumF(a: Int, b: Int): Int =
            if (a > b) 0
            else f(a) + sumF(a +1, b)
        sumF
    }

##Stepwise Applications

Now that sum is a function that returns another function, we can then define our sumInts, sumCubes, and sumFactorials using our new sum function.

    def sumInts = sum(x=> x)
    def sumCubes = sum(x => x * x * x)
    def sumFactorials = sum(fact)

You can apply these functions in turn like this:

    sumCubes(1, 10) + sumFactorials(10, 20)

##Consecutive Stepwise Applications

We can even avoid the sumInts, sumCubes, sumFactorials by writing consecutive stepwise applications, like this:

    sum (cube) (1, 10)

What this does is:

* sum(cube) applies __sum__ to __cube__ and returns the __sum of cubes__ function
* sum(cube) is equivalent to __sumCubes__
* This function is then applied to the arguments: (1, 10)
* Function application associates to the left so that `sum (cube) (1, 10) == (sum (cube)) (1, 10)

##Multiple Parameter Lists

Functions that returns functions has a special syntax. These two are equivalent:

    // Previous way of writing sum (as three parameters)
    def sum(f: Int => Int): (Int, Int) => Int = {
        def sumF(a: Int, b: Int): Int =
            if (a > b) 0
            else f(a) + sumF(a +1, b)
        sumF
    }

    // sum as multiple parameter lists; you can then write: sum (cube) (parameter list)
    def sum(f: Int => Int)(a: Int, b: Int): Int =
        if (a>b) 0 else f(a) + sum(f)(a+1, b)

###Expansion of Multiple Parameter Lists

These two are equivalent and is an example of **currying**.

    def f (args 1) ... (args n-1) (args n) = E
    
    // f has n nested anonymous functions
    def f = (args 1 => (args 2 => ... (args n => E) ... ))

##Function Types

Function types associate to the right. Say we have this sum function:

    def sum(f: Int => Int)(a: Int, b: Int): Int = ...

The type of sum is calculated like this:

    (Int => Int) => (Int, Int) => Int
    Int = > Int => Int
    Int => (Int => Int)  // we put parenthesis for function types on the right 

##Examples

    object exercise {
    
        //product function that calculates the product of the values for the points on a given interval
        def product(f: Int => Int)(a: Int, b: Int): Int =
            if (a > b) 1
            else f(a) * product(f)(a +1, b)
         
         //Can test product with this, gets the product between 3 and 4
         product(x => x * x)(3, 4)  // Int = 144
    
         //factorial in terms of product; multiplication of all numbers been 1 and n
         def fact(n: Int) = product(x => x)(1, n)
         
         //Can test factorial with this, gets the factorial
         fact(5)  // Int = 120
         
         //a general function for product and sum
         def mapReduce(f: Int => Int, combine: (Int, Int) => Int, zero: Int)(a: Int, b: Int): Int =
             if (a > b) zero
             else combine( f(a), mapReduce(f, combine, zero)(a + 1, b))
    
         //mapReduce version of product
         def product(f: Int => Int)(a: Int, b: Int): Int = mapReduce(f, (x, y) => x * y, 1)(a, b)
         //Can test mapReduce version of product function with this
         product(x => x * x)(3, 4)  // Int = 144 
    }

#Week 2 (Lesson 3)

##An example of Higher Order Function with Currying

We're creating an example to calculate the 'fixed point' of a function; a number **x** is called a **fixed point** of a function **f** if `f(x) = x`. We then apply f in a repetitive way, like `x, f(x), f(f(x)), f(f(f(x)))`. An example is `x = 1 + x/2` where we keep applying the function in a way that as it approaches the value (2), there isn't any significant change.

    import math.abs
    
    object exercise {
        val tolerance = 0.0001
        def isCloseEnough(x: Double, y: Double) = 
            abs((x - y) / x) /x < tolerance  // isCloseEnough (x: Double, y: Double) Boolean
        def fixedPoint(f: Double => Double)(firstGuess: Double) = {
            def iterate(guess: Double): Double = {
                val next = f(guess)
                if (isCloseEnough(guess, next)) next
                else iterate(next)
            }
            iterate(firstGuess)
        }
        fixedPoint(x => 1 + x/2)(1)  // Double = 1.99975
    
        // need averageDamp function or else will sqrt will oscillate between 1 and 2
        def averageDamp(f: Double => Double)(x: Double) = 
            (x + f(x))/2
    
        // averageDamp is a function that takes a function (square root) and returns another function
        def sqrt(x: Double) =
            fixedPoint(averageDamp(y => x / y))(1)
    
        sqrt(2) // Double = 1.4142
    }

##Notes on abstraction

Functions are essential abstractions because they allow us to introduce general methods to perform computations. We've seen that these abstractions can be combined with higher-order functions to create new abstractions.

The highest level of abstraction is not always the best. Know when to use abstractions.

#Week 2 (Lesson 4)

##Scala Syntax in Extended Backus-Naur form (EBNF)

So far we've covered elements to express Types, Expressions, and Definitions.

* `|` means an alternative
* `[...]` an option (0 or 1)
* `{...}` a repetition (0 or more)

##Types

So far we've seen two forms of types, **Simple Type** (e.g. **Numeric Type**, **String Type**, **Boolean Type**) and **Function Type**.

* **Numeric Type** can be an Int, Double, Byte, Short, Char, Long, Float
* **Boolean Type** with values `true` or `false`
* **String Type**
* **Function Type** like `Int => Int`, `(Int, Int) => Int`

##Expressions

Categories of expressions can be:

* an **identifier** such as x, isGoodEnough
* a **literal**, like 0, 1, 0, "abc"
* a **function application**, like `sqrt(x)``
* an **operator application**, like `-x`, `y + x`
* a **selection**, like `math.abs`
* a **conditional expression**, like `if (x < 0) -x else x`
* a **block**, like `{ val x = math.abs(y) ; x * 2 }`
* an **anonymous function**, like `x => x + 1`

##Definitions and Parameters

So far we've seen two types of **definitions**, a **Function Definition** and a **Value Definition**. We've also seen that **parameters** can be **call-by-value parameter** or **call-by-name parameter**.

* a **definition** can be:
    - a **function definition**, like `def square(x: Int) = x * x`
    - a **value definition**, like `val y = square(2)`
* a **parameter** can be:
    - a **call-by-value parameter**, like `(x: Int)`
    - a **call-by-name parameter**, like `(y: => Double)`

#Week 2 (Lesson 5)

##Functions and Data

We're going to introduce objects and classes, which means we'll use functions to create and encapsulate data structures. An example is if we want to represent Rational Numbers (say two integers x and y where its represented by numerator x / denominator y).

###Example implementation of Rational Numbers (Bad)

We could implement Rational Numbers with what we know right now and it would look like this, but it's really clunky trying to manage so many numerators and denominators.

    # Ewww
    def addRationalNumerator(n1: Int, d1: Int , n2: Int, d2: Int): Int
    def addRationalDenominator(n1: Int, d1: Int, n2: Int, d2: Int): Int

##Classes

Instead of using functions for Rational Numbers, we can instead define a **class** to better encaspulate our data.

    class Rational(x: Int, y: Int) {
        def numer = x
        def denom = y
    }

The class now introduces two entities:

* It creates a new **type**, named `Rational` that we can use going forward
* A **constructor** `Rational` to create elements of this type
* Note: Scala keeps the names of **types** and **values** in different **namespaces** so there's no conflict between the two definitions of Rational.

###Types and Objects

A **type** is essentially a set of values. The values that belong to a class type is called an **object**. We create an object by prefixing with the keyword `new`.

    val temp = new Rational(1, 2)
    temp.numer // 1
    temp.denom // 2

###Example: Rational class as a Pure Data Type with arithmetic methods outside class

One way we can implement Rational arithmetic is by keeping Rational as a pure data type. This gives us the data and we define functions outside of the class. Here's how that could be done:

    // Doing Rational arithmetic with Rational as a pure data type
    def addRational(r: Rational, s: Rational): Rational = 
        new Rational(r.numer * s.denom + s.numer * r.denom, r.denom * s.denom)
    
    // Helper Function to print Rational nicely; notice outside Rational class
    def makeString(r: Rational) =
        r.numer + "/" + r.denom
    
    makeString(addRational(new Rational(1, 2), new Rational(2, 3)))  // 7/6

###Example: Rational class with arithmetic methods defined inside the class

Another way of implementing Rational arithmetic is by putting the arithmetic functions inside the Rational class. Note that when a function is inside a class, its now called a **method**. This is helpful since you can look at a class and immediately see what methods are available (e.g. multiply, substract, add, neg)

    class Rational(x: Int, y: Int) {
        def numer = x
        def denom = y
    
        def add(that: Rational) = 
            new Rational(numer * that.denom + that.number * denom, denom * that.denom)
    
        def neg: Rational = new Rational(-numer, denom)
    
        def subtract(that: Rational) = add(that.neg)
        
        override def toString = numer + "/" + denom        
    }

#Week 2 (Lesson 6)

##Data Abstraction

We're going to talk about the idea of **data abstraction**, which is the ability to choose different implementations of data without affecting how the clients see the data. For example, we'll go over a few ways of creating a Rational class that returns a simplified value.

###Data Abstraction with creating private methods and members (calls gcd calculation method just once during class construction)

We now want our rational numbers to be simplified. We could add a simplification step in each one of our methods (e.g. at the end of multiply, subtract, add, neg, etc), but the issue with that is it violates **DRY** (Don't Repeat Yourself) and it would be easy to forget to add this step. Instead, let's perform the simplification just once during the initialization of the object (i.e. when the object is constructed). Let's see how we can do that:

    class Rational(x: Int, y: Int) {
        private def gcd(a: Int, b: Int): Int = 
            if (b == 0) a else gcd(b, a % b)
        private val g = gcd(x, y)  // private member
        def numer = x / g
        def denom = y / g
    
        def add(that: Rational) =
            new Rational(numer * that.denom + that.numer * denom, denom * that.denom)
        // ... additional methods
    }

What we're doing is creating **private** members (e.g. `private val g`); they're fields that can only be accessed from inside the Rational class. Notice that we're calculating `gcd` immediately so that it can be re-used in the calculations of _numer_ and _denom_ without need to recalculate each time _numer_ or _denom_ is called.

###Data Abstraction with calculating gcd each time method is called

If we wanted to, we could change it so that gcd is calculated every time the function is called (in case this calculation changes based on other values). We also have one less variable `g`. The advantage to this is if _numer_ and _denom_ are not called frequently.

    class Rational(x: Int, y: Int) {
        private def gcd(a: Int, b: Int): Int = 
            if (b == 0) a else gcd(b, a % b)
        def numer = x / gcd(x, y)
        def denom = y / gcd(x, y)
    }

###Data Abstraction with values instead of methods

If we replaced _numer_ and _denom_ as a `val` instead of a `def`, this ensures that values are only computed once. The advantage to this is if the functions _numer_ and _denom_ are called often.

    class Rational(x: Int, y: Int) {
        private def gcd(a: Int, b: Int): Int = 
            if (b == 0) a else gcd(b, a % b)
        def numer = x / gcd(x, y)
        def denom = y / gcd(x, y)
    }

##Class `this`

In the inside of a class, the keyword `this` represents the current object. Note, some other object oriented languages call this `self`.

    class Rational(x: Int, y: Int) {
        ...
        def less(that: Rational) = numer * that.denom < that.numer * denom
        def max(that: Rational) = if (this.less(that)) that else this
    }

##Preconditions

We can set **preconditions** using either **requirements** or **assertions**. The difference between the two is the **intent**.

* `require` is used to enforce a precondition on the caller of the function (e.g. make sure user doesn't put in something stupid)
* `assert` is used to check the code of the function itself (e.g. a unit test)

###Requirements with `require`

An example is if we tried to divide by zero on a Rational.

    class Rational(x: Int, y: Int) {
        require(y > 0, "denominator must be positive")
        ...
    }

The `require` function is a predefined function that takes a condition and an optional message. If the condition fails to pass, an `IllegalArgumentException` is thrown with the message. Here, if the denominator `y` is equal or less than 0, then the message "denominator must be positive" gets returned.

###Assertions with `assert`

Assertions are another precondition. If the condition fails to pass, an `AssertionError` is returned.

    val x = sqrt(y)
    assert(x >= 0)

##Constructors

A class automatically implicitly introduces a **constructor** called the **primary constructor** of the class. The primary constructor:

* takes the parameters of the class
* executes all statements in the class body (e.g. the `require` function, the `val` defintion) 

###Secondary Constructors

So what's an example of a regular **constructor** (that isn't the **primary constructor**)? We can create a Rational constructor that assumes a denominator of 1 if no second parameter (denominator) is passed in.

    class Rational(x: Int, y: Int) {
        require(y !=0, "denominator must be positive")
        def this(x: Int) = this(x, 1)  // our second constructor if there is no y passed
    }

We can then use our new constructor with `new Rational(2)` and it returns a Rational of 2.

#Week 2 (Lesson 7)

##Classes and Substitution Model

Previously we went over how functions are evaluated, now how does the Substitution Model work on Classes and Objects (instead of a function now)?

###Evaluating a new Class

Say we have a new class `new C(e1, ... en)`. The expression `e1 ... en` are evaluated like the arguments of a normal function. The new resulting expression is then `new C(v1 ... vn)` where they are already values.

###Evaluating a new Class with methods

Say we have a new class like this:

    class C(x1, ..., xn) {
        def f(y1, ..., yn) = ...
    }

We would then do the following three substitutions:

* substitute `y1, ..., yn` of the function `f` by the arguments `w1, ..., wn`
* substitute `x1, ..., xn` of the class `C` by the class arguments `v1, ..., vn`
* substitute of the self reference `this` by the value of the object `new C(v1, ..., vn)`

The result would be:

    [w1/y1, ..., wn/yn][v1/x1, ..., vn/xn][new C(v1, ..., vn)/this]b

###Example: Evaluating a new Class with methods

Let's look at some examples of how Substitution works with Classes and methods.

####Example 1

    class Rational(x, y){
        def numer = x
        def denom = y
        def less(that: Rational) = ...
    } 
    
    new Rational(1, 2).numer
    // [1/x, 2/y][][new Rational(1, 2)/this]x
    // = 1

There's three substitutions at play; the first part is the class parameter (1 replaces `x`, 2 replaces `y`), the second part is empty `[]` because the _numer_ method doesn't have any parameters, and the third part replaces `this` with a new occurrence of the object `new Rational(1, 2)` . The definition for numer is just x.

####Example 2

    new Rational(1, 2).less(new Rational(2, 3))
    // [1/x, 2/y][new Rational(2, 3)/that][new Rational(1, 2)/this]
    // = this.numer * that.denom < that.numer * this.denom
    // = new Rational(1, 2).numer * new Rational(2, 3).denom <
    //     new Rational(2, 3).numer * new Rational(1, 2).denom
    // = 1 * 3 < 2 * 2
    // = true

We have three substitutions at play again. The first part is the class parameter (1 replaces `x`, 2 replaces `y`) substitution. The second part is the substitition of the argument (`new Rational(2, 3)` for the `that` parameter in the `less` method). The third part is the substitition that replaces the `this` in the body with `new Rational(1, 2)`.

##Operators

So what's the difference between writing `x + y` (if x and y are integers), but then we're writing `r.add(s)` if r and s are rational numbers? We should change that because we should be able to use operators like `+` on our Rational numbers.

###Step 1: Infix Notation

Scala allows any method with a parameter to be used like an **infix operator**.

    r add s  // same as: r.add(s)
    r less s // same as: r.less(s)
    r max s // same as: r.max(s)

###Step 2: Relaxed Identifiers

Operators can be used as identifiers. An identifier can be:

* __Alphanumeric__: starting with a letter, followed by a sequence of letters or numbers
* __Symbolic__: starting with an operator symbol, followed by other operator symbolds
* the underscore character **-** counts as a letter
* Alphanumeric identifiers can also end in an underscore, followed by some operator symbols

###Example: Using Identifiers for class Rational

    class Rational(x: Int, y: Int) {
        def < (that: Rational) = numer * that.denom < that.numer * denom
        def max (that: Rational) = if (this < that) that else this
        def + (that: Rational) = new Rational(
            numer * that.denom + that.numer * denom, denom * that.denom)
        def unary_- : Rational = new Rational(-numer, denom)  // prefix operator of - 
        def - (that: Rational) = this + -that  // infix operator of -
        
    }

A few things to note is that we can replace most method names from a string to our relaxed identifiers (e.g. `less` is now `<`, `add` is now `+`). The main difference is that the **prefix operator** of `-` is much different than the infix operator of `-` so we need to add the keyword `unary_` (followed by operator and a space).

##Precedence of Operator Rules

The **precedence** of an operator is determined by its first character. Here's the lowest precedence to highest:

* (all letters)
* |
* ^
* &
* < >
* = !
* :
* + -
* / %
* (all other special characters)

#Week 3 (Lesson 1) - Class Hierarchies

So far we've learned about instances of a single class so now we're interested in how multiple classes work together. There's class hierarchies, which means that classes can extend each other.

##Abstract Classes

__Abstract Classes__ are notable because:

* Abstract classes can contain members that are missing an implementation (e.g. `incl` and `contains` methods)
* We cannot create instances of an abstract class with the operator `new`

Here's an example of an _abstract class_ called `IntSet`, which will be a set of classes that implements sets of integers (both class `Empty` and class `NonEmpty` extends `IntSet`).

    // since this is an abstract class, we don't need body for methods
    abstract class IntSet {
        def incl(x: Int): IntSet
        def contains(x: Int): Boolean
    }
    ... continued below

##Class Extensions

Let's consider implementing sets as binary trees. There are two possible trees: 1.) A tree for the empty set, and 2.) a tree consisting of an integer and two sub-trees. Here's their implementations:

    ... continued from above
    // Class Extension Examples of Empty and NonEmpty extending IntSet
    
    class Empty extends IntSet {
        def contains(x: Int): Boolean = false
        def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)
    
        override def toString = "."  // just showing as empty with a .
    }
    
    class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
        def contains(x: Int): Boolean = 
            if (x < elem) left contains x
            else if (x > elem) right contains x
            else true
    
        def incl(x: Int): IntSet = 
            if (x < elem) new NonEmpty(elem, left incl x, right)
            else if (x > elem) new NonEmpty(elem, left, right incl x)
            else this
    
        override def toString = "{" + left + elem + right + "}"
    }
    
    object intsets {
        println("Testing our IntSet")
        val t1 = new NonEmpty(3, new Empty, new Empty)  // NonEmpty = {.3.}
        val t2 = t1 incl 4  // IntSet = {.3{.4.}}
    }   
    


##Base Classes and Subclasses

So with Class extensions, we now have **superclass** (IntSet) and **subclass** (e.g. Empty and NonEmpty)

* `Empty` and `NonEmpty` both **extend** the class `IntSet`
* `IntSet` is called the **superclass** of classes Empty and NonEmpty.
* Classes `Empty` and `NonEmpty` are **subclasses** of class `IntSet`.
* Any user-defined class can extend another class
* If no superclass is given, the standard class `Object` in the Java package `java.lang` is assumed
* The direct or indirect superclasses of a classs C are called **base classes** of C; this means the base class of `NonEmpty` are `IntSet` and `Object`.

###Implementation and Overriding

Here is another example of another Base Class and Subclass. Notice how if you try to **override** a method in a Subclass that does not exist in the Base Class you will get an error (because there is nothing to override). 

    object overrides {
        println("Welcome to the Scala worksheet")
    }
    
    abstract class Base {
        def foo = 1
        def bar: Int
    }
    
    class Sub extends Base {
        override def foo2 = 2  // When you write override, it'll return error because there was no foo2
        def bar = 3
    }    

##Object Definition vs Class Definition

Objects are just Classes except instead of a class, you specify access. For example, if we don't need to create many instances, we don't need a Class, but can instead just create a **singleton object**. For example, why will there be many instances of an Empty class? It's just empty.

    object Empty extends IntSet {
        def contains(x: Int): Boolean = false
        def incl(x: Int): IntSet = new NonEmpty(x, Empty, Empty)
    }

##Standalone Programs

When we make programs, we can create standalone applications in Scala. Each application contains an `object` and a `main` method, like the below:

    object Hello {
        def main(args: Array[String]) = println("hello world")
    }

To run a program: 

1. You can create this as a 'Scala Object' in your editor
2. Run it as a 'Scala Application'
3. On the console, you'll see "hello world" printed out

##Dynamic Binding

Object Oriented Languages (including Scala) implements **dynamic method dispatch**. This means that the code invoked by a method call depends on the runtime type of the object that contains the method.

###Dynamic Binding Example

We apply our substitution rules.

    // Empty contains 1
    object Empty {
        def contains(y) = false
    }
    
    // (new NonEmpty(7, Empty, Empty)) contains 7
    if (x < elem) this.left contains x
      else if (x > elem) this.right contains x else true
    
    = if (7 < 7) new NonEmpty(7, Empty, Empty).left contains 7
        else if (7 > 7) new NonEmpty(7, Empty, Empty).right
          contains 7 else true

#Week 3 (Lesson 2)

#Class Hierarchies

Now that we know about Classes, we should consider how we organize many Classes together through packages.

##Packages

Classes and objects are organized into **packages**. To place a class or object inside a package, use a package clause at the top of your source file.

    // Say this is in: progfun.examples file
    package progfun.examples
    
    object Hello { ... }

You can then run with `> scala progfun.examples.Hello`

###Example of making and using Packages

Assume we make a package called `week3` using **package**

    package week3
    
    class Rational(x: Int, y: Int) {
        ...
    }

###Imports

There's a few ways you can import either the package or objects; the first two forms are **named imports** and the last form is a **wildcard import**:

    import week3.Rational  // imports just Rational
    import week3.{Rational, Hello} // imports both Rational and Hello
    import week3._ // imports everything in package week3

###Automatic Imports

Some packages are imported automatically. These include:

* all members of package **scala**
* all members of package **java.lang**
* all members of the singleton object **scala.Predef**

##Traits

In Scala (and Java), a class can only have one **superclass**, this means its a **single inheritance** language. This is a bit constraining in that say you want to inherit behavior from multiple superclasses. Instead, you use **traits**, which are declared like an **abstract class**.

    trait Planar {
        def height: Int
        def width: Int
        def surface = height * width
    } 

###Example: Traits

    class Square extends Shape with Planar with Movable ...

Traits resemble _interfaces_ in Java, but are more powerful because they can contain _fields_ and _concrete methods_ (opposed to _interfaces_ that can only contain _abstract methods_).

###Traits vs Classes

The difference between _Classes_ and _Traits_ are that a _Class_ can have value parameters while _traits_ cannot. For example, in our Rational class, we ask for x:Int (numerator) and y:Int (denominator) as parameters. Traits can't do this.

##Scala's Class Hierarchy

* __scala.Any__ is the super class of every class
* two subtrees of classes: **scala.AnyVal** and **scala.AnyRef** (which is really java.lang.Object)

###Scala Top Types

* __Any__ is the base type of all types
* __AnyRef__ is the base type of all references (alias of `java.lang.Object`)
* __AnyVal__ is the base type of all primitive types

###Nothing Type

`Nothing` is at the bottom of Scala's type hierarchity. It is a subtype of every other type. There is no value of type *Nothing*. *Nothing* is used to signal a couple of things:

* Signal abnormal termination
* As an element type of empty collections

###Exceptions

Scala and Java use the expression of `throw Exc` as a way to abort evaluation with the exception `Exc`.

    import week3._
    
    object scratch {
        new Rational(1, 2)
    
        def error(msg: String) = throw new Error(msg)  // error: (msg: String) Nothing
    
        error("test")  // would throw java.lang.Error
    }

###Null

Every reference class type also has null as a value. The type of *null* is *Null*. *Null* is a subtype of every class that inherits from *Object*; it is incompatible with subtypes of *AnyVal*.

    val x = null  // x : Null
    val y: String = null  // y: String
    val z: Int = null  // error: type mismatch

###Non matching types

Given this expression, whatever has more information will pick that data type.

    if (true) 1 else false  // res1: AnyVal = 1

If true then will be int 1, else its false boolean. Both of these values are under the supertype (`AnyVal` has more info than `Any`) and then the type checker did `AnyVal`.

##Scaladoc

www.scala-lang.org/api/current

#Week 3 (Lesson 3) - Polymorphism

We're going to talk about **Types** and **Polymorphism**. Types are how the compilers see functions and classes. The key is **type parameterization**, which means that classes and methos can can have types as parameters.

###Background info on Data Structure, the immutable list `Cons-List` (an immutable linked list)

A fundamental data structure in many functional languages is the immutable linked list. This is made up of two basic pieces:

1. `Nil`, the empty list
2. `Cons` a cell containing an element and the remainder of the list

###Example for Cons-List

    // a simple list
    List(1, 2, 3)
       1 
      / \
     1   1
        / \
       2   1
          / \
         3   Nil
    
    // A list containing two nested lists
    List(List(true, false), List(3))
              - 1 -
            /        \
          1            1
         / \          / \
      true  1        1   Nil
           /  \     / \
       false  Nil  3   Nil

How would we write these as `Cons-Lists` in Scala? We use type parameters to solve the problem of having to define lists of only type Int or type Double or type String, etc.

##Type Parameters

**type parameters** allow you to fill in a type instead of having to put in a specific type (e.g. Int, Double, String). All type parameters use brackets `[]`.

###Example of a Cons-List

    package week4
    
    trait List[T]
    class Cons[T](val head: T, val tail: List[T] extends List[T])
    class Nil[T] extends List[T]

###Example Implementation of trait List[T]

    package week4
    
    trait List[T] {
        def isEmpty: Boolean
        def head: T
        def tail: List[T]
    }
    
    class Cons[T](val head: T, val tail: List[T] extends List[T]) {
        def isEmpty = false
    }
    
    class Nil[T] extends List[T] {
        def isEmpty = true
        def head: Nothing = throw NoSuchElementException("Nil.head")
        def tail: Nothing = throw NoSuchElementException("Nil.tail")
    }

###Generic Functions

Like classes, functions can also have type parameters. A function that creates a list consisting of a single element:

    def singleton[T](elem: T) = new Cons[T](elem, new Nil[T])
    
    // we can then write
    singleton[Int](1)  // list looks like: [1, Nil]
    singleton[Boolean](true)  // list looks like: [true, Nil]

###Type Inference

Scala compiiler can usually tell the correct type parameters from the value parameters of a function call so in most cases, type parameters can be left out.

    singleton(1)
    singleton(true)

###Types and Evaluation

Type parameters do not affect evaluation in Scala because of **type erasure**, which removes all type parameters and type arguments before evaluating the program. A lot of other langauges use type erasure including Java and Haskell. Programs that keep type parameters at run time include C++, C#.

##Polymorphism

**Polymorphism** means that a function comes in **many forms**. This means that:

* the function can be applied to arguments of many types OR
* the type can have instances of many types

###Forms of Polymorphism

There are two principal forms of polymorphism:

1. __subtyping__ means instances of a subclass can be passed to a base class
2. __generics__ means instances of a function or class are created by type parameterization

###Exercise

Write a function nth that takes an integer n and a list and selects the n'th element of the list. Elements are numbered from 0. If index is outside the range from 0 up the length of the list minus one, an IndexOutOfBoundsException should be thrown.

    import week4._
    
    object nth {
        def nth[T](n: Int, xs: List[T]): T =
            if (xs.isEmpty) throw new IndexOutOfBoundsException
            if (n == 0) xs.head
            else nth(n - 1, xs.tail)
        
        val list = new Cons(1, new Cons(2, new Cons(3, new Nil)))
    
        nth(2, list)  // Int = 3 
        nth(4, list)  // IndexOutOfBoundsException
        nth(-1, list)  // IndexOutOfBoundsException
    }

#Week 4 (Lesson 1) - Objects Everywhere

