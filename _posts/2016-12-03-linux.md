---
layout: post
title: Linux OS
---

## {{ page.title }}


- - - -

#Summary

These are notes for the Linux OS.

* [Overview](#overview)
    - [Hardware](#hardware)
    - [Kernel](#kernel)
        * [Memory Management Unit (MMU)](#mmu)
        * [CPU Allocation](#cpuallocation)
        * [System calls (syscalls) with fork() and exce(program)](#systemcalls)
* [Users](#users)
    - [root is a superuser](#root)
* [Shells](#shells)
    - [Bourne Shell](#bourneshell)
    - [bash](#bash)
* [Standard Streams](#standardstreams)
    - [Standard Input (stdin)](#standardinput)
    - [Standard Output (stdout)](#standardoutput)
    - [Standard Error (stderr)](#standarderror)
* [Basic Unix commands](#basicunixcommands)
    - [ls](#ls)
    - [cp](#cp)
    - [mv](#mv)
    - [touch](#touch)
    - [rm](#rm)
    - [echo](#echo)
    - [head](#head)
    - [tail](#tail)
    - [sort](#sort)
    - [less](#less)
    - [diff](#diff)
    - [file](#file)
* [Navigating Directories and Files](#navigatedirectoriesfiles)
    - [/ the root dir](#root)
    - [pathname](#pathname)
    - [/ for absolute pathname](#absolutepathname)
    - [does not start with / for relative pathname](#relativepathname)
    - [.. for parent directory](#parentdirectory)
    - [. for current directory](#currentdirectory)
    - [cd](#cd)
    - [mkdir](#mkdir)
    - [rmdir](#rmdir)
    - [pwd](#pwd)
* [Shell Globbing](#shellglobbing)
    - [globbing with asterisk](#globasterisk)
    - [globbing with ?](#globquestionmark)
* [Searching](#searching)
    - [grep](#grep)
    - [find](#find)
    - [locate](#locate)
* [Shell Basics](#shellbasics)
    - [Shell Keyboard Shortcuts](#shellkeyboardshortcuts)
    - [Configuration Files (Dot Files)](#configurationfiles)
    - [Shell variables](#shellvariables)
    - [Environment variables](#environmentvariables)
    - [$PATH](#path)
* [man pages and info](#maninfo)
* [Redirecting Standard Streams](#redirectstandardstreams)
    - [`>` to redirect stdout (create new)](#redirectstdout)
    - [`>>` to redirect stdout (append)](#redirectstdoutappend)
    - [`|` piping](#piping)
    - [`2>` to redirect stderr to separate stream](#redirectstderr)
    - [`>&` to redirect stdout and stderr to same file](#redirectstdoutstderr)
    - [`<` to redirect to stdin](#redirectstdin)
* [Kill Process](#killprocess)
    - [More Job Control](#jobcontrol)
* [Linux Directory Hierarchy](#directoryhierarchy)
    - [usr](#usr)
* [File Permissions](#filepermissions)
    - [`chmod` to modify file permissions](#chmod)
    - [common permissions](#commonpermissions)
* [Symbolic Links](#symboliclinks)
    - [creating symbolic links](#createsymboliclinks)
* [Archiving and Compressing Files](#archivecompress)
    - [gzip to compress/uncompress .gz files](#gzip)
    - [tar to archive .tar files](#tar)
    - [combine .tar.gz for compressed archives](#targz)
    - [zcat](#zcat)
    - [bzip2](#bzip2)

- - - -

##<a id="overview">Overview</a>

The Linux Operating System has three main levels:

1. Physical Hardware, e.g. memory (lots of 1s and 0s) and CPU (reads and writes from and to memory)
2. Kernel, the software sitting in memory that tells the CPU what to do (unrestricted access to hardware)
3. User Processes, software that user runs (restricted acess to hardware) 

##<a id="kernel">Kernel</a>

The Kernel is the interface between hardware and the user software. In order to managem the CPU and memory, the Kernel has unrestricted access to hardware. Its main jobs are:

* Manage the memory - State is how all the 1s and 0s look in memory (an image). Kernel splits up memory and looks at each group to check their status (e.g. taken, free)
* Allocates CPU time to User Processes
* Interfaces with hardware, e.g. devices (usb, printer), usually through a uniform interface of device drivers
* Gets **system calls** from User processes and handles those requests

###<a id="mmu">Kernel's MMU (Memory Management Unit)</a>

The Kernel manages memory with the help of a **memory management unit** (MMU), that uses a memory management scheme (to enable virtual memory). Some details about memory:

* Kernel needs its own private memory
* User Processes have their own memory (aka **user space**, **userland**); these memory blocks can be private or public
* User Processes can share memory with other User Processes
* Some memory from User Processes are Read Only
* System can use more memory than available by using disk space
* **Page Table** is an implementation of a memory address map

###<a id="cpuallocation">Kernel CPU Allocation</a>

So what exactly is the relationship between the Kernel and the CPU? The Kernel helps with allocating CPU time for processes with these steps:

1. Kernel passes User Processes over to the **CPU**
2. CPU has an internal timer that interrupts the User Process once its used up its "time slice"
3. CPU switches back from the User Process to Kernel Mode and hands control back to Kernel
4. Kernel records the CPU and the process' state in Memory kinda like a quick save
5. Kernel does its own processes, e.g. handle input/output
6. Kernel looks at a list of processes to see what's ready
7. Kernel prepares the CPU (how long should this process take) and prepares the Memory (where is there room to store state)
7. Kernel passes the User Process the CPU to use

Rinse and Repeat.

###<a id="systemcalls">System Calls (syscall) with fork() and exec(program)</a>

A system call (aka **syscall**) is when a User Process can't do a process (either can't access or have ability), so the process requests from the Kernel. There are two types of syscalls:

* **fork()** is when the Kernel creates a nearly identical copy of the process
* **exec(program)** is when the Kernel starts the program and then replaces the process 

So what does this mean? Other than **init**, all User Processes start as a result of fork(). Most of the time, fork() then calls exec(program) to start a new program instead of running a copy of an existing program.

Note, system alls are written in **C**, which is why the syntax has parenthesis.

##<a id="users">Users</a>

Linux defines a User as 'someone that can run processes and own files'. As a User:

* **username** - assigned name of user
* **userid** - assigned an id for the user
* A User cannot terminate another User's processes
* A User can share files with other Users through user **groups**
* `passwd` to change the password

###<a id="root">root is a superuser</a>

The username **root** is a **superuser**, meaning it has access to escalated permissions to allow terminating other Users' processes. You don't want to normally run as root since it can be easy to make mistakes. Even though root is powerful, root still runs in 'user space' (and not in Kernel mode)

##<a id="shells">Shells</a>

A **shell** is a program that runs commands. **Shell Scripts** are files that contain many shell commands. There are many types of shells, but they mainly originate from the **bourne shell** and the most common is the **bourne again shell** (aka **bash**).

You can usually find what shell is being used by going to `/bin/sh` and peaking in there to see the link to the shell.

**chsh** to change a shell.

###<a id="bourneshell">Bourne Shell</a>

The original shell is the **bourne shell**. To see a modern shell, see below for **Bourne Again Shell** (aka **bash**)

###<a id="bash">bash</a>

**bash** is an enhanced version of the bourne shell and is the standard shell on most Linux distributions. Most of the below notes are for bash.

##<a id="standardstreams">Standard Streams</a>

Linux processes use **input and output steams** to read and write data. For example, an input stream might be a device and the output stream might be a file or terminal. So what do you mean?

1. Type in the command `cat` in bash
2. Bash turns into an interactive stream; when you type in text, the text comes out to the terminal
3. The reasoning is that since we didn't specify either a standard input or standard output steam, it used the default.

There's three types of Standard Streams:

* **Standard Input (stdin)**
* **Standard Output (stdout)**
* **Standard Error (stderr)**

###<a id="standardinput">Standard Input (stdin)</a>

Basic Input.

###<a id="standardoutput">Standard Output (stdout)</a>

Where output goes. By default, the Stream ID is 1.

###<a id="standarderror">Standard Error (stderror)</a>

Where errors go. By default, the Stream ID is 2.

##<a id="basicunixcommands">Basic Unix Commands</a>

**Unix** is a flavor of Linux. You can use unix in many other systems so they will be your staple commands.

* `cat` outputs the contents of one or more files
* `ls` lists the contents of a directory
* `cp` copies files, e.g. `cp file1 file2` copies file1 to file2
* `mv` moves a file (really just renaming it), e.g. `mv filea fileb` renames filea to fileb
* `touch` creates a file `touch file1`
* `rm` removes a file (or directory by specifying the correct options), e.g. `rm file1` or `rm -rf dir1` to remove a directory
* `echo` prints its arguments to standard output, a useful way to find out values, variables, or results of pattern matching
* `head` gets the first few lines of a file
* `tail` gets the last few lines of a file
* `sort` sorts a file (default alphabetical), use `-n` for numerical order, `-r` for reverse order
* `less` to return large file contents in a paginated format (one page at a time), e.g. `less largefile1`. Usually used with other commands like `grep stuff /usr/share | less`
* `diff` to return the differences between two files, often used with `-u` to return in a friendlier format for tools, e.g. `diff -u file1 file2`
* `file` to get a guess on what the filetype is, e.g. `file file1`

##<a id="navigatedirectoriesfiles">Navigating Directories and Files</a>

In order to navigate around Linux in the command line, you will need to know how directories and files are referenced and how to move across these paths.

* `/` is the root directory;, we never use a `\` in Linux
* **pathname** is the path to a file
* **absolute pathname** (aka full pathname) is when the pathname starts with a `/`, e.g. `/etc/blah/something.txt`
* **relative pathname** is when a pathname does NOT start with a `/`, e.g. `static/js/something.txt`
* `..` using two dots means referencing the **parent directory**, e.g. if you're in `/usr/bin`, `../bin` to refer to `bin`
* `.` means the current directory; not really used

These commands and terms are useful to navigate around paths:

* **Current Working Directory** is where a process is currently running
* `cd` changes directories, e.g. `cd dir1` will change to `dir1` (or if None, returns to home dir)
* `~` references the **home directory**
* `mkdir` creates a directory, e.g. `mkdir dir1` creates `dir1`
* `rmdir` to remove a directory, e.g. `rmdir dir1` to delete the `dir1`. If dir has files, use `rm -rf dir1` to recursively (`-r`) delete a dir `-d` and all its contents
* `pwd` to print the current working directory; this will be useful when working with **symbolic links**, usually `pwd -P` to find the true path

##<a id="shellglobbing">Searching Directories in Shell using Globbing (Wildcards)</a>

**Globbing** (aka **Wildcards**) is the process of matching files and directories to a pattern in the shell.

* Important to note, globbing only applies to shell and shell scripting.
* Shell globbing is not the same as **regular expressions** (regex)
* E.g. The Shell uses `?` to match one arbitrary character, where regex uses `.`

###<a id="expansion">Globbing Expansion Steps</a>

So what happens after a match is made? The shell does a process called **expansion**, which means:

1. A glob matches a file or directory name
2. The glob **substitutes** those names
3. The glob then runs the rest of the shell command

Some Notes:

* Use single quotes around your command if you do not want expansion, e.g. echo `*` simply prints out `*`

###<a id="globasterisk">Globbing with `*`</a>

`*` is used in shell globbing to match any arbitrary set of characters. Here's sample ways of using `*`:

* `*at` matches anything that ends with `at`
* `at*` matches anything that starts with `at`
* `*at*` matches anything with `at` in the string

###<a id="globquestionmark">Globbing with `?`</a>

`?` is used in shell globbing to match one arbitrary character.

* `b?at` would match `boat` and `brat`, but not `brrat`

##<a id="grep">Grep</a>

Grep prints the lines that matches an expression/a pattern. Grep understands patterns called **regular expressions**. Example uses include:

* `grep root /etc/passwd` to find the text `root` in the directory `/etc/passwrd`
* `grep -i stuff etc/*` to find the word `stuff` (`-i` for case insensitive) in the directory `/etc/`
* `grep -v stuff etc/*` to find the inverse of stuff (does not match) in `/etc/`

##<a id="filesearch">File Search</a>

To search inside a file (not in the shell), use `/` and `?`.

* `/` to search forward from the cursor
* `?` to search backwards from the cursor
* `n` to go to next match once search results are found

##<a id="shellbasics">Shell Basics</a>

Let's take a look at how our shell is configured and how to move around using shortcuts.

###<a id="shellkeyboardshortcuts">Shell Keyboard Shortcuts</a>

Shell keyboard shortcuts can be helpful:

* `^C` is often used to reference `Ctrl + C`
* `^P` to get previous command
* `^B` to move back a step
* `^F` to move forward a step
* `^A` to move to beginning of the line
* `^E` to move to end of the line 
* `^W` to erase preceding word
* `^U` to erase from cursor to beginning of the line
* `^K` to erase from cursor to end of the line
* `^Y` to paste erased text (e.g. from `^U`)

###<a id="configurationfiles">Dot (Configuration) Files</a>

**Dot files** are files that start with a `.`. These configuration files and directories are normally hidden by default and usually hold config settings.

* `ls` normally doesn't show configuration files and directories by default (otherwise things print messy)
* `ls -a` to see all the directory files, including the configuration files
* `.*.` pattern to make shell globs search through configuration files, otherwise will ignore these files by default
* `.bashrc` and `.login` are common configuration files, `.ssh` is a common dot directory

###<a id="shellvariables">Shell Variables</a>

**Shell variables** are temporary variables being stored by the shell. These can contain simple strings or some variables to control the way the shell behaves.

* `STUFF=blah` to assign the value `blah` to the shell variable `STUFF`
* `echo $STUFF` to use the shell variable (referencing with `$`)

###<a id="environmentvariables">Environment Variables</a>

**Environment variables** are slightly different than shell variables in that they get passed to the programs that the shell runs. These are used in configuration and option settings.

* `STUFF=blah` to assign the value `blah` to the variable `STUFF` (at this point, it's not an environment variable yet)
* `export STUFF` to make environment variable STUFF (key is to use `export` to make environment variable)

###<a id="pathvariable">PATH variable</a>

The **PATH** variable is a special **environment variable** that contains the **command path**; its purpose is to list the directories that the shell searches to locate a command.

* `echo $PATH` to show PATH, with `$` to reference the PATH variable
* If multiple PATHS are found, the first is used
* Contents are separated by `:`
* `PATH=somedir:$PATH` to add a directory to the beginning of the PATH
* `PATH=$PATH:somedir` to add a directory to the end of the PATH
* Example PATH might look like: `/usr/local/bin:/usr/bin:/bin`

##<a id="maninfo">`man` pages and `info`</a>

`man` stands for **Manual Pages**, which are built in docts that are split into these 8 sections:

1. User Commands
2. System Calls
3. Higher-level Unix programming library documentation
4. Device Interface and Driver Information
5. File descriptions (system configuration files)
6. Games
7. File formats, conventions, and encodings (ASCII, suffixes, and so on)
8. System commands and Servers

###<a id="useman">How to use man pages</a>

Type in `man <number> <search>` where number is one of the sections above (1-8) and a search term

* `man 5 passwd` to get the file description of `/etc/password` (as opposed to system command)
* `<command> --help` to get help on a specific command, e.g. `ls --help`
* `man -k <keyword>` to search a manual page by keyword, e.g. `man -k keyword`

###<a id="info">

To get additional information, try out `info <command>`, e.g. `info grep`

* `/usr/share/doc` is where some packages dump their available documentation

##<a id="redirectstandardstreams">Redirecting Standard Streams</a>

You can redirect standard input, standard output, and standard error streams.

* `>` to redirect Standard Output to another location by creating or replacing a file, e.g. `command > file1`
* '>>' to redirect Standard Output to another location by appending to file, e.g. `command >> file1`
* `|` (aka **piping**) to redirect Standard Output to Standard Input of another command, e.g. `command1 | command2`, `head /proc/cpuinfo | tr a-z A-z`
* `2>` to redirect Standard Error to a separate stream, e.g. `command > file_a 2> file_b`
  - Steam ID of 1 by deafult means Standard Output (to file_a), Steam ID of 2 by default means Standard Error (to file_b)
* `>&` to redirect Standard Output and Standard Error to the same file, e.g. `command > file_a 2>&1
* `<` is an uncommon scenario to take file and redirect to Standard Input, e.g. `command < file_a`

##<a id="processes">List and Manipulate Processes</a>

A **process** is a running program. Here's how to read process details:

* `ps` to list processes
* **PID** is each process' numeric id
* **TTY** is the terminal device that the process is running on
* **STAT** is the process Status, e.g. `S` for sleeping, `R` for running
* **TIME** is the time that the process has been running
* **COMMAND** is the last command that called the process (can change over time)

Common process commands are:

* `ps x` to show the running (executing) processes
* `ps ax` to show all running processes (not just yours)
* `ps u` to show detailed info on processes
* `ps w` to show full command nmaes (not just what fits in a line)
* `ps aux` to show all running (executing) processes in detail


###<a id="kill">Kill Processes</a>

`kill` to signal to kill a process

* `kill <pid>` to kill a specific process (based on PID)
* `kill -STOP <pid>` to STOP a specific process (based on PID)
* `kill -CONT <pid>` to continue a process (based on PID)
* `kill <pid1> <pid2> <pid3>` to kill multiple processes 
* If a job is currently active in the prompt, you can `^C` to kill the running job

###<a id="jobcontrol">More Job Control</a>

As you saw in Kill, you can manage shell jobs by sending TSTP signals (similar to STOP) and CONT signals. You can also send a job to the background or foreground.

* `jobs` command to see what jobs are currently running
* `^Z` to send a **TSTP** signal to SUSPEND a process
* `fg` to start the process again (bring to foreground)
* `bg` to move the process to the background
* `&` to detach a process from the shell and put it in the `background`so you have the prompt back, e.g. `gunzip file.gz &` to unzip a large file in bg
* `^L` to redraw the entire screen
* `^R` to redraw the current line, but be careful, can put you in reverse isearch mode if in bash prompt already (Esc to quit)


##<a id="directoryhierarchy">Linux Directory Hierarchy</a>

The details of the Linux Directory Hierarchy can be found in the Filesystem Hierarchy Standard (FHS) at http://www.pathname.com/fhs/

The overview looks like this for the main directories:

* /
* /bin/ - has read-to-run programs (**executables**), including most of the basic Unix commands like `ls` and `cp`
* /dev/ - contains device files
* /etc/ - has core system configuration directory (pronounced eht-see), e.g. user password, boot, device, networking files; usually specific to that machine's hardware, e.g. `etc/X11` has graphics cards configs
* /home/ - has personal directories for regular users
* /lib/ - short for library, has library files containing code that **executables** in /bin/ can use. Two types of libraries (`static` and `shared`); this only has shared libraries 
* /sbin/ - place for system executables, relates to system management; regular users should not have have /sbin components. Most utilities here require root access
* /tmp/ - a storage area for smaller, temporary files. Any user can read and write from here, but may not have access to other user files. a storage area for smaller, temporary files. Any user can read and write here, but may not have access other user files. Sometimes cleared so do not put important info here.
* /var/ - the variable subdirectory, where programs record runtime information like system logging (`/var/log/`), user tracking, caches, and other files that system programs create and manage
* /proc/ - provides system statistics through a browsable directory-and-file interface. Contains info about currently running processes and some kernel parameters
* /boot - has kernel loader files, only useful for the very first stage of Linux startup procedure
* /media/ - base attachment point for removable media like flash drives
* /opt/ - additional third-party software, many systems don't have this directory
* /usr/ - does NOT have user files; this is a large directory hierarchy, including most of the Linux system. Has many of the same files as root directory (e.g. `usr/bin`, `usr/lib`). This is where most of the user-space programs and data sit


###<a id="usr">usr</a>

The `/usr` directory is where most of the user-space programs and data sites.

    - `/usr/bin/`
    - `/usr/man/` has man pages
    - `/usr/info/` has info pages
    - `/usr/include` holds header files used by the C compiler
    - `/usr/lib/`
    - `/usr/local/` where administrators can install their own software; should look like that of `/` and `/usr`
    - `/usr/sbin/`
    - `/usr/share/` has files that should work on other kinds of Unix machines; sometimes `/man` or `/info` are here

##<a id="filepermissions">File Permissions</a>

Every Unix file has a set of permissions that say whether you can read, write, or execute the file.

* `ls -l` to display the permissions
* E.g. `-rw-r--r-- 1 juser somegroup 7041 Mar 26 19:34 endnotes.html`
* The file has a **mode**
* The first character of the mode (in this case, `-`) determines the **file type**. `-` for regular file, `d` for directory
* Next comes three sections: "User Permissions", "Group Permissions", "Other permissions" (e.g. User has `rw-`, etc) 

###<a id="chmod">chmod to change file permissions</a>

Use `chmod` to change file permissions. There's also `umask` to set a predefined set of permissions for any new files you create.

* `chmod g+r file1` to add file permissions
* `chmod g-r file2` to remove file permissions
* `chmod 664 file3` to change permissions with numbers (an **absolute change) since it changes all permission bits at once
* `umask` shell command to set a predefined set of permissions to any new file you create

###<a id="commonpermissions">Common Permissions</a>

Some of the most common modes:

* `644` - user: read/write; group, other: read, e.g. used for files
* `600` - user: read/write; group; other: none 
* `755` - user: read/write/execute; group, other: read/execute. e.g. used for directories, programs
* `700` - user: read/write/execute; group, other: none. e.g. used for directories, programs
* `711` - user: read/write/execute; group, other: execute. e.g. used for directories

##<a id="symboliclinks">Symbolic Links</a>

A **symbolic link** is a file that points to another file or directory.

    lrwxrwxrwx 1 ruser users 11 Feb 27 13:52 somedir -> /home/origdir

In this example, when you try to access `somedir`, you get `/home/origdir`, i.e. a shortcut.

Links can get pretty confusing because:

* the destination (`/home/origdir`) doesn't even need to exist
* there might be **chained symbolic links**, basically your system might have links that point to other links
* you might not know a symbolic link exists
* you might forget to add the `-s` option when creating a symbolic link, which means you create a **hard link**
* check command twice that you didn't switch up the target and the linkname

###<a id="createsymboliclinks">Creating Symbolic Links</a>

`ln -s target linkname` so that the linkname argument is the name of the symbolic link. The target arg is the path of the file or directory that the link points to. The `-s` flag specifies a symbolic link.

##<a id="archivecompress">Archiving and Compressing Files</a>

We want to be able to zip/unzip files (i.e. do compression / uncompress files) and to handle archives (pack / unpack multiple files and directories into one file).

###<a id="gzip">Gzip</a>

To compress and uncompress files, we'll use the program `gzip`. Files end with `.gz`

* `gzip my_file` to compress the file
* `gunzip my_file.gz` to uncompress the file

###<a id="tar">tar</a>

To pack multiple files and directories into one file, we want to create an archive with `tar`. We can also unarchive (take one file and put back into multiple files and directories). Files end with `.tar`

A lot of this depends on the modes:

* `c` flag activates create mode
* `x` flag means to put tar into extract/unpack mode
* `t` flag to check contents with `table-of-contents` mode

Then we can add additional flags:

* `tar cvf my_archive.tar file_1 file_2 file_3`
* `v` flag prints details such as file size and permissions
* `f` flag means the file option

Example Commands:

* `tar xvf my_archive.tar` to unpack a `.tar` file

##<a id="targz">Compressed Archives with .tar.gz</a>

Archives are normally found compressed, so you'll see a filename ending in `.tar.gz`. Work from the right side to the left.
Uncompress, then Unarchive.

1. Unzip first with `gunzip my_file.tar.gz`
2. Tar to unarchive with `tar xvf my_file.tar`

TODO: 
[zcat](#zcat)
[bzip2](#bzip2)


