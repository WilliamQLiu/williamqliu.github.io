---
layout: post
title: Chef
---


# {{ page.title }}

## Summary

__Chef__ is a configuration management tool written in Ruby and Erlang.
It uses a __domain-specific language__ (__DSL__) for writing system configuration __recipes__.
Chef helps solve the problem of configuring and maintaining (configure/manage) a company's servers.
Chef utilizes a __declarative__ approach, meaning we specify what the final configuration should be
and not have to specify exactly all the steps needed to make it happen.

## Infrastructure As Code

Chef falls under the whole __Infrastructure as Code__ idea. Benefits include:

* Lowers cost - we can reduce the human time required to provision and manage infrastructure
* Improves speed of provisioning - the machine can run the steps faster than a human can type
* Improves __stability__ and __security__ - allowing us to know exactly what is installed and how it is configured

## Chef Components

Chef Infra is a systems and cloud infrastructure automation framework. Each organization is made up of
one or more ChefDK Installations, a single Chef server, and every node that will be configured and maintained
by Chef Client. Cookbooks (and recipes) are used to tell Chef Client how to do the actual configuration.


* __Chef DK (Development Kit)__ - package that contains everything that is needed to start using Chef
    * __Food Critic__ - a lint tool for static analysis of recipe code
    * __Kitchen__ - integration testing framework that tests cookbooks across platforms
    * __ChefSpec__ - unit testing framework that tests resources locally
    * __InSpec__
    * __Recipes__
    * __Cookbooks__
* __Chef Server__ (aka __Chef Infra Server__)
    * __API__
    * __Data Storage__
    * __Search__
    * __High Availability__
    * __Cookbooks__
    * __Supermarket__
    * __Runlist__
    * __Policy__
* __Chef Client__ (aka __Chef Infra Client__)
    * __Clients__ - Each client runs its own chef client to pull down recipes

## Tools

Some important tools in ChefDK are:

* __Berkshelf__ - a dependency manager for cookbooks
* __chef__ - a workflow tool for Chef
* __chef-vault__ - used to encrypt data bag items using the public keys of a list of nodes
* __CookStyle__ - a Rubocop-based style-checking tool for writing clean cookbooks
* __Delivery CLI__ - a command-line tool for continuous delivery workflow - used to setup and execute phase jobs
                     on  a Chef Automate server
* __Fauxhai__ - gem for mocking Ohai data in ChefSpec tests


## Desired State

Chef cares about the end result, not the steps to get there.

* Chef does a 'Test and Repair' approach that allows Chef to only make changes necessary to get a server back
to the desired state configuration.
* If a server already has the desired configuration/state, no changes happen

So what does this all mean? There's two ways to define our configuration, either __Imperative__ vs __Declarative__.

### Imperative Configuration

An imperative configuration might look like:

    yum install -y nginx
    systemctl start nginx
    systemctl enable nginx

We have to be very specific about what happens.

### Declarative Configuration (using Chef DSL)

A declarative configuration might look like:

    package "nginx"

    service "nginx" do
      action [:enable, :start]
    end

The above doesn't care if we're running systemd.

## Chef Workflow

ChefDK defines a common workflow for cookbook development as:

1. Create a skeleton cookbook - basically a cookbook with the standard files already included
   The package manager is usually __Berkshelf__, which is part of the ChefDK. We also install a revision
   control system (usually __Git__). Berkshelf helps manage cookbooks and cookbook dependencies
2. Create a virtual machine environment using __Test Kitchen__. This is the environment used to develop
   the cookbook, including the location that does automated testing and debugging of what cookbook will be
   done as it is being developed
3. Write the recipes for the cookbook and debug those recipes as they are being written
4. Perform acceptance tests on a full Chef Server (not a local development environment) that mimics a production
   environment as much as possible
5. When the cookbooks pass acceptance tests and have been verified to work in the correct mannger, deploy
   the cookbooks to the production environment

## Installation

### Install Chef Server

1. Download chef-server-core
2. Install chef-server-core (e.g. `rpm -Uvh chef-server-core.rpm`) to install Chef Server and provide a few utilities
3. Run `chef-server-ctl reconfigure` to configure its own services
4. Run `chef-server-ctl service-list` to see what services the chef server manages
   E.g. okshelf
        nginx
        oc_bifrost
        oc_id
        opscode-chef-mover
        opscode-erchef
        postgresql
5. Create a user `chef-server-ctl user-create USER_NAME FIRST_NAME LAST_NAME EMAIL 'PASSWORD' --filename FILE_NAME`
   E.g. `chef-server-ctl user-create will Will Liu william.q.liu@gmail.com 'mypassword' --filename /home/user/will.pem`
   where we will output an RSA key used to interact with the Chef server from a workstation later on
6. Create an organization `chef-server-ctl org-create SHORT_ORG_NAME 'FULL_ORG_NAME' --association_user USER_NAME --filename FILE_NAME`
   E.g. `chef-server-ctl org-create myorg 'My Organization' --association_user will --filename my-validator.pem
   where the `--association_user` flag takes an existing user's username and associates it with the `admin` security group
   The `--filename` flag stores the organization's validator pem
7. Optional: Install __chef-manage__ web ui (an add-on that gives a web-based way to see all the chef related info
   regarding our node information, cookbook versions) using `chef-server-ctl install chef-manage`
   Then run `chef-server-ctl reconfigure` and then `chef-manage-ctl reconfigure`

### Install ChefDK

ChefDK is the development kit that we will install on our workstation (e.g. our labtop)

1. Download chefdk.rpm
2. Install `rpm -Uvh chefdk.rpm`
3. Now we have access to different tools for developing and testing our Chef code; check version with `chef --version`
    chef --version
    Chef Development Kit Version: 2.5.3
    chef-client version: 13.8.5
    delivery version: master (73ebb72a6c42b3d2ff5370c476be800fee7e5427)
    berks version: 6.3.1
    kitchen version: 1.20.0
    inspec version: 1.51.21
4. Make sure you have the right ruby `which ruby`
5. Use the Chef specific version of ruby `eval "$(chef shell-init bash)"`
6. Generate a chef-repo that will hold our cookbooks and dependencies among the team with `chef generate repo generated-chef-repo`
   When we use a chef generator, it makes it easier to follow standard Chef development practices
7. The main tool we will use to connect to the Chef server is the `knife` utility. Configure it with `knife configure`
8. Run knife commands (e.g. `knife node list`, `knife ssl fetch`)
9. Optional: Instead of setting up a chef-repo, we can also download a chef-starter kit

### Install Chef Node

A Chef Node is the server that we will configure using chef. We won't ssh into this server and will basically
just run knife commands on it.

1. Create a server (e.g. say its at myserverlocation.someplace.com)
2. On your workstation, run `knife` with `-x` (for ssh USERNAME), `-N` (pass in a node name), `-P` (for password)
   In our chef-repo, we will run `knife bootstrap myserverlocation.someplace.com -N web-node-1 -x user -P 'mypassword' --sudo`
3. This runs a few steps, including creating a new client for 'web-node-1'
4. Now that a node is registered, we can run `knife node list` and you should see `web-node-1`
5. What this does is that Chef uses a pull-based approach for configuration changes using `chef-client` and we've now
   setup `chef-client` to run on our 'web-node-1'

### The `chef-client` process:

1. Get configuration data - read information from `client.rb` file and Ohai attributes
2. Authenticate w/ Chef server - Uses RSA key and node name to authenticate with Chef server. Will generate
   a new RSA key if this is the first connection
3. Get/rebuild the node object - Pull `node` object from Chef server if this isn't the first `chef-client` run.
   After the pull, the node object is rebuilt based on the node's current state.
4. Expand the `run-list` - compiles the list of roles and recipes to be applied
5. Synchronize cookbooks - Request and download all of the files from cookbooks on the Chef server that are necessary
   to converge the run list and are different from the files already existing on the node
6. Reset node attributes - rebuild the attributes on the node object
7. Compile the resource collection - load the necessary ruby code to converge the `run-list`
8. Converge the node - execute the `run-list`
9. Update the node object, process exception & report handlers - Update the node object on the Chef server after the
   `chef-lcient` run finishes successfully. Also execute the exception and report handlers in the proper order.
10. Stop, wait for the next run - the `chef-client` waits until the next time it is executed

## Supermarket

The __Chef Supermarket__ is basically like the pypy, rubygems, or dockerhub, except we have a lot of cookbooks
and plugins. Even though there is a __public supermarket__, you can run the supermarket code and deploy a
__private supermarket__.

There is __Berkshelf__ (kinda like Ruby's Bundler) to install and manage cookbook dependencies and versions (aka dependency manager)
There is also __Stove__ used to version and publish cookbooks to a supermarket (either public or private)

## Cookbooks

Chef Cookbooks are the unit of configuration and policy distribution. A cookbook defines a scenario
and contains everything that is required to support that scenario.

* __Recipes__ specify the resources to use and the order in which they are to be applied
* __Attribute values__ - an attribute can be defined in a cookbook (or a recipe) and then used to override
  the default settings on a node. Attributes in the `default.rb` file are loaded first and then additional
  attribute files (if present) are loaded in lexical sort order

## Knife

### Knife Data Bag

Data bags store global variables as JSON data.
Data bags can be loaded by a cookbook or accessed during a search.




