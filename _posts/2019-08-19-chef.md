---
layout: post
title: Chef
---


# {{ page.title }}

## Summary

__Chef__ is a configuration management tool written in Ruby and Erlang.
It uses a __domain-specific language__ (__DSL__) for writing system configuration __recipes__.
Chef helps solve the problem of configuring and maintaining (configure/manage) a company's servers.
Chef utilizes a __declarative__ approach, meaning we specify what the final configuration should be
and not have to specify exactly all the steps needed to make it happen.

## Infrastructure As Code

Chef falls under the whole __Infrastructure as Code__ idea. Benefits include:

* Lowers cost - we can reduce the human time required to provision and manage infrastructure
* Improves speed of provisioning - the machine can run the steps faster than a human can type
* Improves __stability__ and __security__ - allowing us to know exactly what is installed and how it is configured

## Chef Components

Chef Infra is a systems and cloud infrastructure automation framework. Each organization is made up of
one or more ChefDK Installations, a single Chef server, and every node that will be configured and maintained
by Chef Client. Cookbooks (and recipes) are used to tell Chef Client how to do the actual configuration.


* __Chef DK (Development Kit)__ - package that contains everything that is needed to start using Chef
    * __Food Critic__ - a lint tool for static analysis of recipe code
    * __Kitchen__ - integration testing framework that tests cookbooks across platforms
    * __ChefSpec__ - unit testing framework that tests resources locally
    * __InSpec__
    * __Recipes__
    * __Cookbooks__
* __Chef Server__ (aka __Chef Infra Server__)
    * __API__
    * __Data Storage__
    * __Search__
    * __High Availability__
    * __Cookbooks__
    * __Supermarket__
    * __Runlist__
    * __Policy__
* __Chef Client__ (aka __Chef Infra Client__)
    * __Clients__ - Each client runs its own chef client to pull down recipes

## Tools

Some important tools in ChefDK are:

* __Berkshelf__ - a dependency manager for cookbooks
* __chef__ - a workflow tool for Chef
* __chef-vault__ - used to encrypt data bag items using the public keys of a list of nodes
* __CookStyle__ - a Rubocop-based style-checking tool for writing clean cookbooks
* __Delivery CLI__ - a command-line tool for continuous delivery workflow - used to setup and execute phase jobs
                     on  a Chef Automate server
* __Fauxhai__ - gem for mocking Ohai data in ChefSpec tests


## Desired State

Chef cares about the end result, not the steps to get there.

* Chef does a 'Test and Repair' approach that allows Chef to only make changes necessary to get a server back
to the desired state configuration.
* If a server already has the desired configuration/state, no changes happen

So what does this all mean? There's two ways to define our configuration, either __Imperative__ vs __Declarative__.

### Imperative Configuration

An imperative configuration might look like:

    yum install -y nginx
    systemctl start nginx
    systemctl enable nginx

We have to be very specific about what happens.

### Declarative Configuration (using Chef DSL)

A declarative configuration might look like:

    package "nginx"

    service "nginx" do
      action [:enable, :start]
    end

The above doesn't care if we're running systemd.

## Chef Workflow

ChefDK defines a common workflow for cookbook development as:

1. Create a skeleton cookbook - basically a cookbook with the standard files already included
   The package manager is usually __Berkshelf__, which is part of the ChefDK. We also install a revision
   control system (usually __Git__). Berkshelf helps manage cookbooks and cookbook dependencies
2. Create a virtual machine environment using __Test Kitchen__. This is the environment used to develop
   the cookbook, including the location that does automated testing and debugging of what cookbook will be
   done as it is being developed
3. Write the recipes for the cookbook and debug those recipes as they are being written
4. Perform acceptance tests on a full Chef Server (not a local development environment) that mimics a production
   environment as much as possible
5. When the cookbooks pass acceptance tests and have been verified to work in the correct mannger, deploy
   the cookbooks to the production environment

## Installation

### Create the Chef Server

1. Download chef-server-core
2. Install chef-server-core (e.g. `rpm -Uvh chef-server-core.rpm`) to install Chef Server and provide a few utilities
3. Run `chef-server-ctl reconfigure` to configure its own services
4. Run `chef-server-ctl service-list` to see what services the chef server manages
   E.g. okshelf
        nginx
        oc_bifrost
        oc_id
        opscode-chef-mover
        opscode-erchef
        postgresql
5. Create a user `chef-server-ctl user-create USER_NAME FIRST_NAME LAST_NAME EMAIL 'PASSWORD' --filename FILE_NAME`
   E.g. `chef-server-ctl user-create will Will Liu william.q.liu@gmail.com 'mypassword' --filename /home/user/will.pem`
   where we will output an RSA key used to interact with the Chef server from a workstation later on
6. Create an organization `chef-server-ctl org-create SHORT_ORG_NAME 'FULL_ORG_NAME' --association_user USER_NAME --filename FILE_NAME`
   E.g. `chef-server-ctl org-create myorg 'My Organization' --association_user will --filename my-validator.pem
   where the `--association_user` flag takes an existing user's username and associates it with the `admin` security group
   The `--filename` flag stores the organization's validator pem
7. Optional: Install __chef-manage__ web ui (an add-on that gives a web-based way to see all the chef related info
   regarding our node information, cookbook versions) using `chef-server-ctl install chef-manage`
   Then run `chef-server-ctl reconfigure` and then `chef-manage-ctl reconfigure`

