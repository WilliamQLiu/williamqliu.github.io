---
layout: post
title: Chef
---


# {{ page.title }}

## Summary

__Chef__ is a configuration management tool written in Ruby and Erlang.
It uses a __domain-specific language__ (__DSL__) for writing system configuration __recipes__.
Chef helps solve the problem of configuring and maintaining (configure/manage) a company's servers.
Chef utilizes a __declarative__ approach, meaning we specify what the final configuration should be
and not have to specify exactly all the steps needed to make it happen.

## Infrastructure As Code

Chef falls under the whole __Infrastructure as Code__ idea. Benefits include:

* Lowers cost - we can reduce the human time required to provision and manage infrastructure
* Improves speed of provisioning - the machine can run the steps faster than a human can type
* Improves __stability__ and __security__ - allowing us to know exactly what is installed and how it is configured

## Chef Components

Chef Infra is a systems and cloud infrastructure automation framework. Each organization is made up of
one or more ChefDK Installations, a single Chef server, and every node that will be configured and maintained
by Chef Client. Cookbooks (and recipes) are used to tell Chef Client how to do the actual configuration.


* __Chef DK (Development Kit)__ - package that contains everything that is needed to start using Chef
    * __Food Critic__ - a lint tool for static analysis of recipe code
    * __Kitchen__ - integration testing framework that tests cookbooks across platforms
    * __ChefSpec__ - unit testing framework that tests resources locally
    * __InSpec__
    * __Recipes__
    * __Cookbooks__
* __Chef Server__ (aka __Chef Infra Server__)
    * __API__
    * __Data Storage__
    * __Search__
    * __High Availability__
    * __Cookbooks__
    * __Supermarket__
    * __Runlist__
    * __Policy__
* __Chef Client__ (aka __Chef Infra Client__)
    * __Clients__ - Each client runs its own chef client to pull down recipes

## Tools

Some important tools in ChefDK are:

* __Berkshelf__ - a dependency manager for cookbooks
* __chef__ - a workflow tool for Chef
* __chef-vault__ - used to encrypt data bag items using the public keys of a list of nodes
* __CookStyle__ - a Rubocop-based style-checking tool for writing clean cookbooks
* __Delivery CLI__ - a command-line tool for continuous delivery workflow - used to setup and execute phase jobs
                     on  a Chef Automate server
* __Fauxhai__ - gem for mocking Ohai data in ChefSpec tests


## Desired State

Chef cares about the end result, not the steps to get there.

* Chef does a 'Test and Repair' approach that allows Chef to only make changes necessary to get a server back
to the desired state configuration.
* If a server already has the desired configuration/state, no changes happen

So what does this all mean? There's two ways to define our configuration, either __Imperative__ vs __Declarative__.

### Imperative Configuration

An imperative configuration might look like:

    yum install -y nginx
    systemctl start nginx
    systemctl enable nginx

We have to be very specific about what happens.

### Declarative Configuration (using Chef DSL)

A declarative configuration might look like:

    package "nginx"

    service "nginx" do
      action [:enable, :start]
    end

The above doesn't care if we're running systemd.

## Chef Workflow

ChefDK defines a common workflow for cookbook development as:

1. Create a skeleton cookbook - basically a cookbook with the standard files already included
   The package manager is usually __Berkshelf__, which is part of the ChefDK. We also install a revision
   control system (usually __Git__). Berkshelf helps manage cookbooks and cookbook dependencies
2. Create a virtual machine environment using __Test Kitchen__. This is the environment used to develop
   the cookbook, including the location that does automated testing and debugging of what cookbook will be
   done as it is being developed
3. Write the recipes for the cookbook and debug those recipes as they are being written
4. Perform acceptance tests on a full Chef Server (not a local development environment) that mimics a production
   environment as much as possible
5. When the cookbooks pass acceptance tests and have been verified to work in the correct mannger, deploy
   the cookbooks to the production environment

