---
layout: post
title: Godot
---


# {{ page.title }}

Look up "Godot Tutorials" on YouTube for the basic tutorial series.

## Game Loop (Over simplified)

Keep in mind your game will run at say 60 Frames Per Second so
don't run big for loops, complex calculations in your script lifecycles.

While(userNotQuitOrCrash):
    updatePhysics()
    Scene.updateScenePicture()  # Update images you're shown
    passToNodeScripts(userInput)
    performanceUpdate()  # Most game engines will handle this for you
    userNotQuitOrCrash = updateAppState()

Look at the `MainLoop.cpp` and `Main.cpp` file for details on this game loop.

## Nodes and Resources

Top main classes are 'Nodes' and 'Resources'

### Nodes

Node classes are functionality and behavior.

* Nodes represent behavior
* Nodes give you functionality (draw a sprite, simulate physics, manager player speed)
* Nodes have Class Inheritance

Example Nodes

* Spatial (a 3D game object)
* CanvasItem -> Node2D (a 2D game object)

### Resources

In the FileSystem (bottom left default), you can create a new 'Resource' class.
A resource is saved to the disk (file system).

* Resources are Data Containers
* All they do is hold data. Nodes rely on the data contained in resources

Example Resources

* Scenes
* GDScripts

## Script Lifecycle

Our game objects go through a life cycle of:

* Create/Start
* Exist
* Destroy/End

Lifecycle details:

1. "Enter Tree" - A scence is loaded from disk or created by a script
2. "Ready" - The root node of the newly instantiated scene is added as a child of the root viewport
  or to any child of it
3. "Player Input" - Every node of the newly added scene will receive the `enter_tree()` notification in top
  to bottom order
4. "Physics Processing" - The `ready()` notification is called when a node and all its children are inside the active scence
5. "Process" - While the object is active in the scence, callbacks such as the
   `_input()`, `_process()`, `_physics_process()` are called if used
6. "Exit Tree" - When a scene is removed, they receive the `exit scene` notification in bottom to top order
   So all the children will exist scene before the root node can exit

## Virtual Methods

__Virtual Methods__ allow subclasses of the base class type that has the virtual method to
override the method. If there is `virtual`, Godot will handle virtual method calls if they are
overridden. For example, a Node class has the following methods:

Node Methods

* void `_enter_tree()` virtual
* void `_exit_tree()` virtual
* String `_get_configuration_warning()` virtual
* void `_input(InputEvent event)` virtual
* void `_physics_process(float delta)` virtual
* void `_process(float delta)` virtual
* void `_ready()` virtual
* void `_unhandled_input(InputEvent event)` virtual

We can override these following virtual methods

### `_enter_tree()`

The `_enter_tree()` method is __always called__ when a scene (gameobject) enters the SceneTree.
The notification is Top-to-Bottom order.

How `_enter_tree()` plays:

```
root
  Parent
    Child1
      GrandChild1
    Child2
```
the order will be:

* Parent has entered the SceneTree
* Child1 has entered the SceneTree
* GrandChild1 has entered the SceneTree
* Child2 has entered the SceneTree

Before our scene is loaded, it'll be an inactive Node to an active Node.

E.g.
```
      SceneTree
          |
      Root Viewport
          |
Inactive: Node -> Active: Node (`_enter_tree()` is when a Node becomes Active)
```

When do you need to use `_enter_tree()`?

* If you don't know if you should be using it, then you most likely don't need it
* If you need property values reset and/or some type of action to happen immediately
  (every time the Node is active on the SceneTree)
* Good for Scenes (Gameobjects) that will be active and inactive, and never released from memory
* `_enter_tree()` is very specialized; prioritize `_ready()` over `_enter_tree()` when setting initial property values

### `_ready()` method

* The `_ready()` function can be used by any class that inherits from the Node class
* The Root Nodes's `_ready()` function is called last (i.e. __calls lowest children first__)
* The `_ready()` method is __called only once__
* If you remove a node and add it back to the scene, it will NOT call the `_ready()` method again

Example

```
Root
  Child1
    GrandChild1
      GreatGrandChild1
    AnotherGrandChild1
  Child2
    GrandChild2

will call:

GreatGrandChild1 _ready() method is called
GrandChild1 _ready() method is called
AnotherGrandChild1 _ready() method is called
Child1 _ready() method is called
GrandChild2 _ready() method is called
Child2 _ready() method is called
Root _ready() method is called
```

Does the Root have children? If so, go to Child. If not, did the `_ready()` method get called?

Note: Just because a node has been deleted/set to inactive (no longer there in the SceneTree),
it doesn't mean it's been removed from memory.

When to use?

* Use the ready function when you only want to initialize default property values once when
  an object is created/added to the scene
* Default Player health, points, items, etc.

### Delta Time w/ `_process()`

__Delta Time (elapsed time)__ is a concepted used by programmers in relation to hardware and network responsiveness.
In Godot, delta time is a __float__ value. For game programming, we refer to the elapsed time between the last frame
that was drawn and the current frame that is drawn.

Issues between different computer speeds:

F1 -> delta time -> F2 -> delta time -> F3 -> delta time -> F4

Say we have a game running 4FPS and one with 60FPS.

We have a __framerate dependent__ calculation
* 4FPS = 100 pixels/s = 25 pixels/frame
* 60FPS = 60 pixels * 25 pixels / frame = 1500 pixels / second

We can have a __framerate independent__ by using __delta time__

* For any __movement__, use delta time
* Any physics dealing with time, we want to use delta time

Godot gives you two virtual methods to handle delta time:

```
_process(delta):
    pass

_physics_process(delta):
    pass
```

#### `_process(delta)` method

* Gives us the ability to be __frame independent__ (i.e. not synced to the hardware, runs same on all hardware fast and slow)
* If overridden by Node, it will run at every frame possible

When to use:

* When you need an action called, or something updated as the __fastest possible rate (real time)__
* Smoothest movement possible that the physics process virtual method is unable to output (i.e. do not use for movement)

When not to use:

* The delta value is not reliable, it prefers speed over consistency
* The default settings for New Projects sometimes has `_process(delta)` run slower than `_physics_process(delta)`

Never remove `vsync` (default on); if you do, then our `_process(delta)` method is called as quickly as possible
and we will not be frame independent anymore.

#### `_process_physics(delta)` method

* Gives us the ability to be __frame independent__
* If overridden by Node, delta will be capped at 1/60 (Default), 60 frames per second, 0.1 seconds per 6 frames (delta is constant)
* Frame rate is synced to the physics
* Frame rate is a constant

When to use:

* Dealing with physics, such as movement
* Custom Timers (Not using the Timer Node)
* Ideal for Game Logic (Path Finding, updating positions)

When not to use:

* Delta is capped at 1/60 (cannot go faster)
* You may not get the smoothest "visual" animations (varies)

#### physics vs physics_process opinions

* Start out with `_physics_process(delta)`
* If it feels weird, then upgrade to `_process(delta)`
* If the game is slow and bottleneck is `_process(delta)`, switch back to `_physics_process(delta)`

### Player Input

Player Input includes:

* Mouse Movements
* Mouse Clicks
* Keyboard Inputs
* Controller Inputs

The easiest way for Godot to handle keyboard input is through the Application's "Input Map Tab"

4 common input virtual methods from Node Class:

* `func _input(event):`
* `func _gui_input(event):`
* `func _unhandled_input(event):`
* `func_unhandled_key_input(event):`

How does this fit in?

```
User Input -> OS -> Scene Tree -> Root ViewPort ->
  1. Input
  2. Control Node (GUI Input)
  3. Unhandled Input
```

Input works __Bottom to Top__ order with by first looking to see if the `_input(event)` method was called on any of the
nodes, then bottom to top again on `_gui_input(event)`, then `_unhandled_input(event)`, etc.

Just keep in mind you have to exit the InputEvent otherwise the input event will be passed along.

#### Control Class

Control < CanvasItem < Node < Object

#### `func _unhandled_input(InputEvent event):`

* unhandled input is the third input event handler to be called
* You want your player input controls here; that way player controls don't interfere with Control Node input handlers

#### So what does this mean?

You don't want player input at higher levels (e.g. `_input`, `_gui_input`) because you want priority to go to
say "Pausing the Game". You don't want a player to shoot their gun while the game is paused.

#### `func_unhandled_key_input(event):`

This will only get called if a key press was/is detected (mouse movement does not activate this function).
Consider using this for input dealing with key presses.

#### `CollisionObject._input_event()`

* Fourth input handler to be called
* Collision Object is a Node Class, inherited by Area and Physics Body

#### Viewport

* Last to be called
* If input chain has been unhandled, the input event will be passed to the next viewport on the tree
* When events are propagated, we must stop it through the Root Viewport Singletonn, meaning we have to manually call:
  `self.get_tree().get_root().set_input_as_handled()`

#### InputEvent Class

* InputEvent class is the base class for all sorts of Input Data
* Godot 'under the hood' will convert the user input data and pass down a class that holds the relevant data, usually
  a subclass of the InputEvent class
* If you look up the InputEvent class, you see that it inherits 'Resources' < 'Reference' < 'Object'
* InputEvent class is inherited by a few classes including: `InputEventWithModifiers` (keyboard, mice, trackpad)


