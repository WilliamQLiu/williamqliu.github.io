<!DOCTYPE html>
<html>
<head>
   <title>Python Basics</title>
   <meta name="William Liu" content="William Liu" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- LaTeX support -->
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
     MathJax.Hub.Config({
     extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
    });
   </script>

</head>

<body>
  <div class="site">
    <div class="title">
      <a href="/">William Liu</a>
    </div>

    <div id="post">
<h2 id="python-basics">Python Basics</h2>

<hr />

<p><strong>About Python</strong></p>

<p>Python is a general purpose programming language that focuses on code readability.  This is a quick summary of what you will need to know about Python data types and control flow.</p>

<p><strong>BEGINNER</strong></p>

<ul>
  <li><a href="#numbers">Numbers (int, float)</a></li>
  <li><a href="#sequencetypes">Sequence Types (i.e. can slice)</a>
    <ul>
      <li><a href="#strings">Strings (str) and Unicode (unicode)</a></li>
      <li><a href="#lists">Lists (list, stacks, queues, list comprehension)</a></li>
      <li><a href="#tuples">Tuples</a></li>
      <li><a href="#sequencemethods">Sequence Methods (e.g. enumerate)</a></li>
      <li><a href="#sequencesort">Sorting Sequences</a></li>
    </ul>
  </li>
  <li><a href="#hashtables">Hash Table (i.e. key-value pair)</a>
    <ul>
      <li><a href="#dict">Dict</a></li>
      <li><a href="#set">Set</a></li>
    </ul>
  </li>
  <li><a href="#controlflow">Control Flow</a>
    <ul>
      <li><a href="#ifelse">if else statement</a></li>
      <li><a href="#for">for statement</a></li>
      <li><a href="#range">range(), xrange()</a></li>
      <li><a href="#lambda">lambda expression</a></li>
    </ul>
  </li>
</ul>

<p><strong>ADVANCED</strong></p>

<ul>
  <li><a href="#debug">Debugging Functions</a>
    <ul>
      <li><a href="#help">help()</a></li>
      <li><a href="#dir">dir()</a></li>
      <li><a href="#globals">globals()</a></li>
      <li><a href="#type">type()</a></li>
      <li><a href="#id">id()</a></li>
    </ul>
  </li>
  <li><a href="#functionmethodclass">Functions, Classes, Methods</a>
    <ul>
      <li><a href="#variablescope">variable scope</a></li>
      <li><a href="#boundunbound">bound and unbound methods</a></li>
      <li><a href="#classstaticmethods">class and static methods</a></li>
      <li><a href="#decorators">decorators</a></li>
    </ul>
  </li>
  <li><a href="#classes">Class Objects</a>
    <ul>
      <li><a href="#classattributes">Attribute Reference</a></li>
      <li><a href="#init">Instantiation and <code>__init__()</code></a></li>
      <li><a href="#selfandcls"><code>self</code> and <code>cls</code></a></li>
      <li><a href="#underscores">underscores</a></li>
      <li><a href="#inheritance">inheritance</a></li>
      <li><a href="#abstractbaseclass">abstract class</a></li>
      <li><a href="#super"><code>super()</code></a></li>
    </ul>
  </li>
  <li><a href="#magicmethods">Class Magic Methods</a>
    <ul>
      <li><a href="#magicmethodsconstruction">Construction and Initialization</a></li>
      <li><a href="#magicmethodsrepresentation">Representation of Classes</a></li>
      <li><a href="#magicmethodsattributeaccess">Attribute Access</a></li>
      <li><a href="#descriptors">descriptors</a></li>
      <li><a href="#magicmethodscontainerobjects">Container Objects</a></li>
      <li><a href="#magicmethodscallable">Callable Objects</a></li>
    </ul>
  </li>
  <li><a href="contextmanagers">Context Managers</a>
    <ul>
      <li><a href="#enterexit"><strong>enter</strong>() and <strong>exit</strong>()</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="a-idnumbersnumbersa"><a id="numbers">NUMBERS</a></h2>

<p>Python can do simple calculations like addition, subtraction, division, multiplcation, and calculate powers.  </p>

<pre><code> 2 + 2**3  # Addition with 2 to the power of 2
 #10
</code></pre>

<h4 id="floor-division">Floor Division</h4>

<p>Integers (e.g. <code>2</code>, <code>4</code>, <code>20</code>) have type <strong>int</strong> and the fractional parts (e.g. <code>5.0</code>, <code>1.6</code>) have type <strong>float</strong>.  When doing division with a numerator and denominator of type int, then there is an automatic <strong>floor division</strong> (i.e. rounds down to the nearest integer, e.g. <code>11/4 = 2</code> even though result should be <code>2.75</code>).  To avoid floor division, make one of the operands a float (e.g. <code>11/4.0</code> and your result will be <code>2.75</code>).  You can also force a floor division (regardless of data types) using <code>//</code> operator</p>

<pre><code> (50 - 5 * 6) / 3  # Floor division because operands are both type int
 #6
 
 (50 - 5 * 6) / 3.0  # No floor division, at least one operand type float
 #6.666666666666667
 
 #(50 - 5 * 6) // 3  # Forces floor division
 #6
</code></pre>

<hr />

<h2 id="a-idsequencetypessequence-typesa"><a id="sequencetypes">SEQUENCE TYPES</a></h2>

<h3 id="a-idstringsstringsa"><a id="strings">Strings</a></h3>

<p>Python can also manipulate strings using single quotes (<code>'...'</code>) and double quotes (<code>"..."</code>) with <code>\</code> as an escape character.  Strings are <strong>immutable</strong> (i.e. object can’t be altered, a new object has to be created if a different value has to be stored)</p>

<pre><code>temp = 'hello world'  # single quotes
print temp  # hello world

temp = "hello world"  # double quotes
print temp  # hello world

temp = 'doesn\'t'  # use \ to escape a quote
print temp  # doesn't
print type(temp)  # &lt;type 'str&gt;'
</code></pre>

<h4 id="raw-strings">Raw Strings</h4>

<p>If you don't want characters prefaced by <code>\</code> to be interpreted as a special character (e.g. <code>\n</code> used in next line), then use <code>r</code> before the string</p>

<pre><code>print "C:\some\name"  # here \n means newline
#C:\some
#ame

print r"C:\some\name"  # here it reads the raw string
#C:\some\name
</code></pre>

<h4 id="joining-and-slicing-strings">Joining and Slicing Strings</h4>

<p>If you want to join strings together use <code>+</code>.  If you want to slice strings, use <code>[]</code>.</p>

<pre><code>word = "Python"
print word[1]  # Get character in position 0
#y

print word[-1]  # get character in last position
#n

print word[2:4]  # Slice characters
#th
</code></pre>

<h4 id="string-methods">String Methods</h4>

<ul>
  <li><code>str.count()</code> returns the number of occurrences of substring</li>
  <li><code>str.decode()</code> returns a decoded version of the string</li>
  <li><code>str.encode()</code> returns an encoded version of the string</li>
  <li><code>str.endswith()</code> returns <code>True</code> if suffix found, otherwise <code>False</code></li>
  <li><code>str.find()</code> returns <code>True</code> if substring found, otherwise <code>False</code></li>
  <li><code>str.format()</code> returns a formatted string</li>
  <li><code>str.join()</code> returns a concatenated string on the iterable</li>
  <li><code>str.lower()</code> returns a lower case conversion of the string</li>
  <li><code>str.replace(old, new)</code> returns a new string with old substring replaced with new</li>
  <li><code>str.startswith()</code> returns <code>True</code> if suffix found, otherwise <code>False</code></li>
</ul>

<hr />

<h3 id="a-idlistslistsa"><a id="lists">Lists</a></h3>

<p>Lists are a way to hold items in order.  The items can be different data types or the same type (if it’s the same type and you need speed, look up arrays, in particular numpy arrays).  Lists can also be sliced and concatenated (i.e. sequence type).  Lists are also <strong>mutable</strong> (i.e. there are methods to modify the object)</p>

<pre><code>squares = [1, 4, 9, 16, 25]  # make a list of numbers
print squares
#[1, 4, 9, 16, 25]

squares + [36, 49, 64, 'etc']  # Add in another list
#[1, 4, 9, 16, 25, 36, 49, 64, 'etc']

print squares[2:4]  
#[9, 16]
print type(squares)  # &lt;type 'list'&gt;
</code></pre>

<h4 id="list-slicing">List Slicing</h4>

<p>Just like you can index and slice strings, you can do the same for Python’s lists.</p>

<pre><code>squares = [1, 4, 9, 16, 25]
print squares # [1, 4, 9, 16, 25]
squares[0]  # 1
squares[-1]  # 25
squares[:]  # [1, 4, 9, 16, 25]
squares[2:4]  # [9, 16]  # only get index 2 and 3 (excludes 4)
squares[::2] # [1, 9, 25]  # skip every other
squares[::-1]  # [25, 16, 9, 4, 1] reverse order
</code></pre>

<h4 id="nesting-lists">Nesting Lists</h4>

<p>You can nest lists (create lists that contain other lists).</p>

<pre><code>a = ['a', 'b', 'c', 'd']
n = [1, 2, 3, 4]
x = [a, n]
print x  # [['a', 'b', 'c', 'd'], [1, 2, 3, 4]]
print x[0]  # ['a', 'b', 'c', 'd']
print x[0][1]  # b
</code></pre>

<h4 id="list-methods">List Methods</h4>

<ul>
  <li><code>list.append(x)</code> adds an item <code>x</code> to the end of the list</li>
  <li><code>list.extend(L)</code> extends the list by specific items</li>
  <li><code>list.insert(i, x)</code> inserts an item <code>x</code> at a given position <code>i</code></li>
  <li><code>list.remove(x)</code> removes the first occurrence of the value <code>x</code></li>
  <li><code>list.clear()</code> removes all items from the list</li>
  <li><code>list.index(x)</code> returns index in the list whose value is <code>x</code> or an error if none found</li>
  <li><code>list.count(x)</code> returns the number of times <code>x</code> appears in the list</li>
  <li><code>list.sort()</code> sorts the items of the list in place</li>
  <li><code>list.pop([i])</code> removes the <code>i</code> item or last item if not specified</li>
</ul>

<h4 id="stacks">Stacks</h4>
<p>A <strong>stack</strong> is using a list with first-in, last-out functionality.  The main methods for stacks are <code>append()</code> and <code>pop()</code>.  Note that with append, the items you add can be other lists (i.e. you can have a list with lists inside as individual items)</p>

<h4 id="queues">Queues</h4>
<p>A <strong>queue</strong> is a specific list built for efficient first-in, first-out functionality.  For more specialized containers, look up <code>collections</code>.</p>

<pre><code>from collections import deque
queue = deque(["Eric", "John", "Michael"])
queue.append("Terry")  # Terry arrives
queue.append("Graham")  # Graham arrives
queue.popleft()  # Eric (first in queue) now leaves
queue.popleft()  # John (second in queue) now leaves
queue  # deque(['Michael', 'Terry', 'Graham'])
print type(queue)  # &lt;type 'collections.deque'&gt;
</code></pre>

<h4 id="list-comprehensions">List comprehensions</h4>

<p>List comprehensions are a concise way of making lists based on an operation or if the item satisifes a certain condition.  This is a compact for-loop that builds lists.  Here are different ways of doing a regular loop along with the list comprehension equivalent:</p>

<pre><code>sqaures = []
for x in range(10):  # range(10) loops from 0 - 9
    squares.append(x**2)
print squares
#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

squares = map(lambda x: x**2, range(10))  # same, using map
squares = [x**2 for x in range(10)]  # same, using list comprehension
</code></pre>

<h4 id="so-what-makes-up-a-list-comprehension">So what makes up a list comprehension?</h4>

<p>The basic structure is:</p>

<pre><code>[&lt;output value&gt; for &lt;element&gt; in &lt;list&gt; &lt;optional criteria&gt;]
</code></pre>

<ul>
  <li>We have the list comprehension enclosed with brackets <code>[]</code> because we return a list</li>
  <li>In the middle section, we have <code>for &lt;element&gt; in &lt;list&gt;</code> and it looks like a regular <code>for-loop</code>.  This tells us we are iterating over the list going through each element in the sequence.</li>
  <li>The <code>&lt;output value&gt;</code> is what we append to the list we are building.  We can say this is the element itself, the element squared, the absolute value of the element, etc.</li>
  <li>The <code>&lt;optional criteria&gt;</code> can be a way to filter out items if they do not meet a condition.  </li>
</ul>

<p>Examples:</p>

<pre><code>vec = [-4, -2, 0, 2, 4]

[x for x in vec]  # print out the list as is
#[-4, -2, 0, 2, 4]

[x*2 for x in vec]  # create a new list with the output values doubled
#[-8, -4, 0, 4, 8]

[abs(x) for x in vec]  # apply a function to all the elements
#[8, 4, 0, 4, 8]

[x for x in vec if x &gt;= 0]  # filter the list to exclude negative numbers
#[0, 2, 4]    
</code></pre>

<hr />

<h3 id="a-idtuplestuplesa"><a id="tuples">Tuples</a></h3>

<p><strong>Tuples</strong> are like read-only lists because they are immutable (instead of mutable) and are enclosed with parentheses (instead of brackets).  Tuples do care about order.</p>

<pre><code>temp = ('abcd', 786, 2.23, 'john', 70.2 )
print temp  # ('abcd', 785, 2.23, 'john', 70.2)
print type(temp)  #&lt;type 'tuple'&gt;

print temp[0]  # prints first element of the tuple
# abcd

print temp[1:3]  # prints elements after 1st to 3rd
# (785, 2.23)
</code></pre>

<p>So why use a tuple over a list?</p>

<ul>
  <li>Certain tuples (if they contain values like strings, numbers, other tuples) can be used as dictionary <em>keys</em>.  Lists cannot be used as dictionary keys (because lists are not immutable).  Dictionary <em>keys</em> require an immutable data type, although the <em>value</em> can be mutable or immutable).</li>
  <li>Tuples are faster than lists.</li>
</ul>

<h4 id="a-idsequencemethodssequence-methodsa"><a id="sequencemethods">Sequence Methods</a></h4>
<p>Assuming <code>s</code> and <code>t</code> are sequences and <code>n</code>, <code>i</code>, <code>j</code> are integers.</p>

<ul>
  <li><code>x in s</code>  # True if an item of s is equal to x, else False</li>
  <li><code>x not in s</code>  # False if an item of s is equal to x, else True</li>
  <li><code>s + t</code>  # Concatenate s and t</li>
  <li><code>s * n</code>  # Create n copies of s</li>
  <li><code>s[i]</code>  # ith item of x (Note: origin is item 0)</li>
  <li><code>s[i:j]</code>  # slice of s from i to j</li>
  <li><code>s[i:j:k]</code>  # slice of s from i to j with step k</li>
  <li><code>len(s)</code>  # length of s</li>
  <li><code>min(s)</code>  # smallest item of s</li>
  <li><code>max(s)</code>  # largest item of s</li>
  <li><code>s.index(x)</code>  # index of the first occurence of x in s</li>
  <li><code>s.count(x)</code>  # total number of occurences of x in s</li>
</ul>

<h4 id="enumerate">Enumerate</h4>

<p>A useful built-in function for sequences is Enumerate.  Enumerate means you return a tuple containing a count and the value from iterating over the sequence.  By default this starts counting from start 0, unless you specify the <code>start=</code> parameter.</p>

<pre><code>seasons = ['Spring', 'Summer', 'Fall', 'Winter']

list(enumerate(seasons))
# [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]

list(enumerate(seasons, start=1))
# [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

for i, value in enumerate(seasons):
    print "Position ", i, " has value ", value
#Position  0  has value  Spring
#Position  1  has value  Summer
#Position  2  has value  Fall
#Position  3  has value  Winter
</code></pre>

<h4 id="a-idsequencesortsorting-sequencesa"><a id="sequencesort">Sorting Sequences</a></h4>

<p>Python has a <code>sort</code> method that modifies a list in-place and a <code>sorted</code> method that builds a new sorted list from an iterable.  NumPy also has a <code>sort</code> method, but it does not modify the list in-place.</p>

<pre><code>my_list = ['hello', 'world', 'will', 'was', 'here']

#NumPy's sort; not inplace
np.sort(my_list)
#array(['hello', 'here', 'was', 'will', 'world'],
#  dtype='|S5')
my_list
#['hello', 'world', 'will', 'was', 'here']

#Python's sort; inplace, only works for lists
my_list.sort()
#['hello', 'here', 'was', 'will', 'world']

#Python's sorted
sorted([5, 2, 3, 1, 4], reverse=False)
[1, 2, 3, 4, 5]
</code></pre>

<h4 id="keys">keys</h4>

<p>There is a <code>key</code> parameter in Python's <code>sort</code> and <code>sorted</code> methods that allows you to specify a function to be called on each list element prior to making comparisons.  Note this is not available in the Numpy version of <code>sort</code>.</p>

<pre><code>sorted("This is a test string from Will".split(), key=str.lower)
#['a', 'from', 'is', 'string', 'test', 'This', 'Will']
</code></pre>

<p>A common pattern is to sort objects using the object indices as a key.  For example, we are interested in the sorting by the age in this tuple.</p>

<pre><code>student_tuple = [
    ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10)]
#[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
sorted(student_tuple, key=lambda student: student[2])  # sort by age
#[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
</code></pre>

<h4 id="operator-itemgetter-attrgetter-methodcaller">operator (itemgetter, attrgetter, methodcaller)</h4>

<p>Python has a few built in functions to help you get get items with <code>itemgetter</code> and <code>attrgetter</code> to get attributes</p>

<pre><code>from operator import itemgetter, attrgetter
</code></pre>

<h4 id="itemgetter">itemgetter</h4>

<p>Get an item from an object using <strong>itemgetter</strong>.  This basically looks up an index on a sequence, then returns that value.</p>

<pre><code>#String
itemgetter(1)('ABCDEFG')  #'B'

#List
itemgetter(2)(['Hello', 'World', 'Will'])  #'World'

#Dict
itemgetter('Age')(phonebook1)

#Tuple
itemgetter(2)(student_tuple)  # ('dave', 'B', 10)
</code></pre>

<h4 id="attrgetter">attrgetter</h4>

<p>Get attributes from an object using <strong>attrgetter</strong>.  This basically looks up an attribute on an object.</p>

<pre><code>import operator
class Student(object):
    def __init__(self, id, name, grades):
        self.id = id
        self.name = name
        self.grades = grades
    
    def __str__(self):
        return '%s has grade %s' %(self.name, self.grades)

students = [Student(0, 'Will', 70), Student(1, 'Laura', 90), Student(2, 'Wayne', 87)]
best_student = max(students, key=operator.attrgetter('grades'))
print best_student
#Laura has grade 90
</code></pre>

<hr />

<h2 id="a-idhashtableshash-tablesa"><a id="hashtables">HASH TABLES</a></h2>

<p>A hash table (aka hash map) is a way to map keys to values (i.e. a key-value pair).  A hash function computes an index into an array of buckets or slots, from which the correct value can be found.</p>

<h3 id="a-iddictdictionary-dicta"><a id="dict">Dictionary (dict)</a></h3>

<p>A <strong>dictionary</strong> is a key-value pair.  The key can be almost any type, but usually are numbers or strings.  Value can be any Python object.  Dictionaries are enclosed with <code>{}</code> and accessed with brackets <code>[]</code>.  The idea is also called <strong>associative arrays</strong>, <strong>map</strong>, <strong>symbol table</strong>.  The ideas behind operations are:</p>

<ul>
  <li>create a dictionary</li>
  <li>add (aka insert) a key-value pair</li>
  <li>reassign a value</li>
  <li>remove (aka delete) a key/value pair</li>
  <li>clear to remove all elements</li>
  <li>give key, get value</li>
  <li>iterate through the dictionary</li>
</ul>

<p>Example:</p>

<pre><code>phonebook = {}  # Create dict with {}
phonebook = {'Name': 'Will', 'Age': 30, 'Number': 1234567890}
phonebook['Notes'] = 'Do not give cookies'  # Add key-value pair
phonebook['Number'] = 938477566  # Update value with key
del phonebook['Notes']  # Delete key-value pair
phonebook.keys()  #get keys  #['Age', 'Name', 'Number']
phonebook.values()  # get values  # [30, 'Will', 123456789]
phonebook.clear()  # clears all values, keeps keys

#Iterate through key, values    
for my_key, my_value in phonebook.iteritems():
    print "Key is: ", my_key
    print "Value is: ", my_value
#Key is:  Age
#Value is:  30
#Key is:  Name
#Value is:  Will
#Key is:  Number
#Value is:  938477566
</code></pre>

<hr />

<h3 id="a-idsetseta"><a id="set">Set</a></h3>

<p>A <strong>set</strong> is an unordered collection of distinct hashable elements.  Note that items have to be hashable and can’t hold duplicates. Sets do not have indexing, ordering, or slicing. Sets have all these restrictions, but are really fast. They’re also good for set methods.</p>

<pre><code>from sets import Set
engineers = Set(['John', 'Jane', 'Jack'])
print engineers  # Set(['Jane', 'John', 'Jack'])
print type(engineers)  # &lt;class 'sets.Set'&gt;

# Set operations
s1 = set(['Beta', 'Gamma', 'Alpha', 'Delta', 'Gamma', 'Beta'])
s2 = set(['Beta', 'Alpha', 'Epsilon', 'Omega'])
len(s1)  # get length of s1, # 4
'Gamma' in s1  # True  # test value if it exists in s1
'Beta' not in s1  # False  # test value if it does not exist in s1
s1.union(s2)  # set(['Epsilon', 'Beta', 'Delta', 'Alpha', 'Omega', 'Gamma'])
s1 | s2  # set(['Epsilon', 'Beta', 'Delta', 'Alpha', 'Omega', 'Gamma'])
s1.intersection(s2)  # set(['Alpha', 'Beta'])
s1.difference(s2)  # set(['Gamma', 'Delta'])
s1.symmetric_difference(s2)  # set(['Epsilon', 'Delta', 'Omega', 'Gamma'])
</code></pre>

<hr />

<h2 id="a-idcontrolflowcontrol-flowa"><a id="controlflow">Control Flow</a></h2>

<p>Python has the usual control flow statements.  These include:</p>

<ul>
  <li><code>if</code> statement</li>
  <li><code>for</code> statement</li>
  <li><code>range()</code> function iterates over a sequence of numbers</li>
  <li><code>xrange()</code> function is like <code>range()</code>, but doesn’t store in memory</li>
  <li><code>lambda</code> expression is a small anonymous function, which means lambda: a if some_condition() else b</li>
  <li><code>map()</code> function applys a function to every item of iterable and returns a list</li>
</ul>

<h3 id="a-idifelseif-elif-else-statementa"><a id="ifelse">if, elif, else statement</a></h3>

<pre><code># if statement
if x &lt; 0:
    print "x is negative"
elif x==0:
    print "x is zero"
else:
    print "x is positive"
</code></pre>

<h3 id="a-idforfor-statementa"><a id="for">for statement</a></h3>

<pre><code># for statement
words = ['cat', 'window', 'defense']
for w in words:
   print w,  # cat window defense
</code></pre>

<h3 id="a-idrangerange-xrangea"><a id="range">range(), xrange()</a></h3>

<pre><code># range() function
for i in range(5):
    print i,  # 0 1 2 3 4

# normal call with separate arguments
temp = list(range(3, 6))
print temp  # [3, 4, 5]

$ xrange() function
for i in xrange(2, 10):
    print i,  # 2 3 4 5 6 7 8 9
</code></pre>

<h3 id="a-idlambdalambda-expressiona"><a id="lambda">lambda expression</a></h3>

<p>Lambda is a way to create small anonymous functions (i.e. a function without a name).  These are often used in combination with <code>filter()</code>, <code>map()</code>, and <code>reduce()</code></p>

<pre><code># a general lambda expression
lambda x: 'big' if x &gt; 100 else 'small'
lambda x: x**2
</code></pre>

<h4 id="a-idfilterfiltera"><a id="filter">filter()</a></h4>

<p><code>filter(function, sequence)</code> is a function that filters out all the elements of a sequence where the function returns <code>True</code>.  The first argument is the function that returns a Boolean and this is applied to every element of the list.  A sequence is returned where the values are only where the function returns <code>True</code>.</p>

<pre><code># filter() with number
def lessThanFive(element):
    return element &lt; 5  # True if less than 5, otherwise False
fib = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
result = filter(lessThanFive, fib)
print result # [0, 1, 1, 2, 3]

# filter() with strings
names = ['Jack', 'Jill', 'Steve', '']
filter(None, names)  # empty strings, 0's and None's are False

# filter() with lambda
result = filter(lambda x: x %2, fib)  # odd only
print result # [1, 1, 3, 5, 13, 21, 55]

# filter's equivalent in list comprehension
# [item for item in iterable if function(item)]  # if function not None
# [item for item in iterable if item]  # if function is None
</code></pre>

<h4 id="a-idmapmapa"><a id="map">map</a></h4>

<p><code>map(function, sequence)</code> is a function with two arguments.  The first argument is the name of a function and the second is a <em>sequence data type</em> (e.g. a list).  Map applies the function to all the elements of the sequence and returns this as a new list.</p>

<pre><code># map()
def fahrenheit(T):
    return ((float(9)/5)*T + 32)
temp = (36.5, 37, 37.5, 39)  # temp (C)
F = map(fahrenheit, temp)

# map() with lambda
Celsius = [36.5, 37, 37.5, 39]
Fahrenheit = map(lambda x: (float(9)/5)*x + 32, Celsius)
print Fahrenehit  # [97.7, 98.60000000000001, 99.5, 102.2]
</code></pre>

<h4 id="a-idreducereducea"><a id="reduce">reduce</a></h4>

<p><code>reduce(function, sequence)</code> applies a function to a sequence and returns a single value (instead of a list like the above).  The idea is that the first two items are reduced to a single value, then that single value and the third value is reduced into a new single value.  This repeats until no more items are in the list.</p>

<pre><code># reduce()
result = reduce(lambda x,y: x+y, [47, 11, 42, 13])
print result  # 113
</code></pre>

<h4 id="a-idzipzipa"><a id="zip">zip</a></h4>

<p><code>zip(sequence1, sequence2)</code> returns a list of tuples, where each tuple contains the ith element from each of the sequences.  The returned list is truncated to the length of the shortest argument sequence.</p>

<pre><code># zip()
temp = zip(range(5), range(1, 20, 2))
print zip  # [(0, 1), (1, 3), (2, 5), (3, 7), (4, 9)]
</code></pre>

<hr />

<h2 id="a-iddebugdebugging-functionsa"><a id="debug">DEBUGGING FUNCTIONS</a></h2>

<p>These functions are nice for debugging your code.</p>

<h4 id="a-idhelphelpobjecta"><a id="help">help(object)</a></h4>

<p><code>help()</code> uses the built-in help system to tell you more about the function, class, method, keyword, etc.  Exit help with <code>:q</code>.</p>

<h4 id="a-iddirdira"><a id="dir">dir()</a></h4>

<p><code>dir()</code> gives you the list of names in the current local scope.  If you input an object as an argument, it tells you its attributes.</p>

<h4 id="a-idglobalsglobalsa"><a id="globals">globals()</a></h4>

<p><code>globals()</code> returns a dictionary of the current objects.</p>

<h4 id="a-idtypetypeobjecta"><a id="type">type(object)</a></h4>

<p><code>type()</code> returns the type of an object (e.g. str, list)</p>

<h4 id="a-idididobjecta"><a id="id">id(object)</a></h4>

<p><code>id()</code> returns the identity of the object as an integer or long integer; this represents the address of the object in memory.  This is useful to see if copies are being referenced or if the same object is.</p>

<hr />

<h2 id="a-idfunctionmethodclassfunctions-classes-and-methodsa"><a id="functionmethodclass">Functions, Classes, and Methods</a></h2>

<p>A <strong>function</strong> is a block of reusable code that is used to perform specific actions.  Some familiar built-in functions are things like <code>print</code>.  You can do a variety of things including pass in arguments, set default values, set keyword arguments, and make certain fields required.  Functions are defined using the <code>def</code> keyword.</p>

<pre><code>def happy_birthday(name, age_yesterday=10):
    """ Print happy birthday to a person and tell them their age"""
    age = age_yesterday + 1
    message = "Happy Birthday " + person + "! Congrats turning " + str(age)
    return message

happy_birthday(Will, 29)  # Happy Birthday Will! Congrats turning 30!
happy_birthday('Laura', 26)  # Happy Birthday Laura! Congrats turning 27!
happy_birthday(name='Billy')  # Happy Birthday Billy! Congrats turning 11!
</code></pre>

<p>A <strong>class</strong> is like a blueprint or instruction manual for creating objects.  You define a class using the <code>class</code> keyword and normally name it starting with a capital letter (e.g. Person, Car).  Even though we define how to create an object, we do not actually create an instance of one until we call the Class (e.g. Will is an instance of a Person, a Tesla is an instance of a Car).</p>

<pre><code>class Customer(object):
    """ A customer of a bank with a checking account """
    def __init__(self, name, balance=0.0):
        """ Return a Customer object with name and balance """
        self.name = name
        self.balance = balance
    
    def withdraw(self, amount):
        """ Return the balance remaining after withdrawing an amount """
        if amount &gt; self.balance:
            raise RuntimeError("Amount greater than available balance")
        self.balance -= amount
        return self.balance
    
    def deposit(self, amount):
        """ Return balance remaining after depositing an amount """
        self.balance += amount
        return self.balance

will = Customer()  # Create an instance of the Class
</code></pre>

<p>A <strong>method</strong> is a function that is stored as a class attribute.  Here we declare a method called <code>get_size</code> and bind it to an instance of our object Pizza.</p>

<pre><code>class Pizza(object):
    def __init__(self, size):
        self.size = size
    def get_size(self):
        return self.size

my_pizza = Pizza(size=5)
my_pizza.get_size()  # 5
</code></pre>

<h4 id="a-idvariablescopelocal-vs-global-variablesa"><a id="variablescope">Local vs Global variables</a></h4>

<p>Variables defined inside a function have a <strong>local scope</strong>, which means that they can only be accessed inside the function they are declared.</p>

<pre><code>def calculate(arg1, arg2):
    """ Add both the parameters and return the total """
    total = arg1 + arg2
    print "Inside the local function, total is:", total
    return total
calculate(5, 7)
#Inside the local function, total is: 12
</code></pre>

<p>Variables defined outside a function have a <strong>global scope</strong>, which means that they can be accessed outside the function.</p>

<pre><code>a = 10
def my_func():
    a = 5
    return a
print a  # 10
print my_func()  #5
</code></pre>

<h4 id="a-idboundunboundbound-vs-unbound-methodsa"><a id="boundunbound">Bound vs Unbound methods</a></h4>

<p>In Python classes we have <strong>unbound</strong> and <strong>bound</strong> methods.  When you access the method directly through the class (e.g. <code>Customer.withdraw()</code>), it is <strong>unbound</strong>.  When you access the method through an instance of the class (e.g. <code>Will.withdraw()</code>, it is <strong>bound</strong> to that instance of the class (in our example, the Customer <code>Will</code>).  This means that when you call a bound instance, its simply saying <code>Will</code> is passed as the first argument.</p>

<pre><code> class Customer(object):
    def withdraw():
        return "Withdrawing money!"

# Example of unbound method
Customer.withdraw
# &lt;unbound method Customer.withdraw&gt;

# Example of bound method
Will = Customer()
Will.withdraw
# &lt;bound method Customer.withdraw of &lt;__main__.Customer object at 0x00000000&gt;&gt;
</code></pre>

<h4 id="a-idclassstaticmethodsclass-and-static-methodsa"><a id="classstaticmethods">Class and Static Methods</a></h4>

<p>Besides bound and unbound methods, we have <strong>static methods</strong> and <strong>class methods</strong>.</p>

<pre><code>class Customer(object):
    @staticmethod
    def withdraw():
        return "Withdrawing money!"
    @classmethod
    def deposit(cls):
        return "Depositing money!"

Will = Customer()
Will.withdraw  # &lt;function withdraw at 0x00000000&gt;
Will.withdraw()  # Normally this would be a bound method, but staticmethod prevents it
# 'Withdrawing money!'

Will.deposit  # &lt;bound method type.deposit of &lt;class '__main__.Customer'&gt;&gt;
Will.deposit()  # 'Depositing money!'
</code></pre>

<p><strong>Static methods</strong> tells the method not to bind to an instance.  For the example, the method would normally be a bound method, but the <code>@staticmethod</code> makes this into a regular function.  When you see <code>@staticmethod</code>, it tells us that the method does not depend on the state of the object itself.</p>

<p><strong>Class methods</strong> tells the method not to bind to an instance, but the <code>@classmethod</code> binds the method to a class.  A class method is used to share among all the instances.</p>

<h4 id="a-iddecoratorsdecoratorsa"><a id="decorators">Decorators</a></h4>

<p>Decorators are functions that are applied right before your function or method call.  This is usually seen in something like a login function where say you can only run this specific function if you are logged in.  The decorator is a clean way to show this so you do not have to declare the login function inside your function. </p>

<pre><code>def p_decorate(func):
    """ Wraps string around with &lt;p&gt; tags """
    def func_wrapper(name):
        return "&lt;p&gt;{0}&lt;/p&gt;".format(func(name))
    return func_wrapper

# Example of decorating a function
@p_decorate
def get_text_clean(name):
    return "lorem ipsum, {0} dolor sit amet".format(name)

# Example of decorating a method
class Person(object):
    def __init__(self):
        self.name = "Willy"
        self.family = "Liu"

    @p_decorate
    def get_fullname(self):
        return self.name + " " + self.family
</code></pre>

<hr />

<h2 id="a-idclassesclass-objectsa"><a id="classes">CLASS OBJECTS</a></h2>

<p>Classes in Python create objects, which provides all the standard features of Object Oriented Programming.  You can have class inheritance from base class(es); this means you can derive a new class with all the variables and methods of the base class(es) and override any variables and/or methods.  We can access Class objects through <strong>attribute reference</strong> or <strong>instantiation</strong>.  By convention, we upper case our class names (e.g. Pet).</p>

<h4 id="a-idclassattributesclass-attribute-referencea"><a id="classattributes">Class Attribute Reference</a></h4>

<p>When you create a Class, all variables are in the <strong>local scope</strong> (i.e. referenced only inside the Class).  You can reference class objects with the pattern <code>Obj.name</code>; this can reference variables or methods.  </p>

<p>Example 1</p>

<pre><code>class Car(object):
    """ This is the docstring of a class """

    wheels = 4
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def make_sound(self):
        print "Vroooom!"

mustang = Car('Ford', 'Mustang')
print mustang.wheels  # 4
print Car.wheels  # 4
</code></pre>

<p>Example 2</p>

<pre><code>class MyClass:
    """ A simple example class """
    i = 12345  # a class attribute set at the class level

    def f(self):
        return 'hello world'

MyClass.i  # access an object integer
# 12345

MyClass.f  # access an object method
# &lt;unbound method MyClass.f&gt;

MyClass.__doc__  # access an object docstring
# 'A simple example class'

MyClass.__dict__  # access an object dict
# {'i': 12345, '__module__': '__main__', '__doc__': ' A simple class ', 'f': &lt;function f at 0x0000000002BCA128&gt;}
</code></pre>

<h4 id="a-idinitinstantiation-using-initselfa"><a id="init">Instantiation using <code>__init__(self)</code></a></h4>

<p>Class <strong>instantiation</strong> uses function notation; just pretend a class object is a parameterless function that returns a new instance of the class.</p>

<pre><code>x = MyClass()  # creates a new instance of the class and assigns it to a variable x
</code></pre>

<p>The instantiation operation (‘calling’ a class object) creates an empty object.  If you want to create an initial state, you define <code>__init__(self)</code>.  A good rule of thumb is to never introduce a normal variable outside of <code>__init__</code>.</p>

<pre><code>class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart

x = Complex(3.0, -4.5)
x.r, x.i  #(3.0, -4.5)
</code></pre>

<h4 id="a-idselfandclsself-and-clsa"><a id="selfandcls"><code>self</code> and <code>cls</code></a></h4>

<p><code>self</code> tells us we are looking at an <em>instance method</em>.  The name is by convention and does not actually have to be self (i.e. can be any word).  What it comes down to is when you call a method of an instance (e.g. call getName method from the instance of polly from the class Pet), Python automatically figures out that self should be the instance (e.g. polly) and passes it to the function (e.g. getName).  Always use <code>self</code> for the first argument to instance methods.</p>

<pre><code>class Pet(object):
    def __init__(self, name, species):
        self.name = name
        self.species = species
    def getName(self):
        return self.name
    def getSpecies(self):
        return self.species
    def __str__(self):
        return "%s is a %s" % (self.name, self.species)

polly = Pet("Polly", "Parrot")

print "Polly is a %s" % polly.getSpecies()
# Polly is a Parrot

print "Polly is a %s" % Pet.getSpecies(polly)
# Polly is a Parrot
</code></pre>

<p><code>cls</code> tells us we are looking at a <em>class method</em>.  This is similar to how self is used in instance methods.  Always use cls for the first argument to class methods.  Again, this naming is just convention and in theory you can call this whatever you want (but don’t make a new name, this will just cause confusion).  The reason you use cls is if you wanted attributes that all instances of the class can share.  cls is usually used in the <code>__new__</code> protocol for <code>staticmethod</code> and <code>classmethod</code> (i.e. methods that only need access to the class, but not to things specific to each instance of the class).</p>

<h4 id="a-idunderscoresuse-of-underscores--and-a"><a id="underscores">Use of underscores <code>_</code> and <code>__</code></a></h4>

<p>With classes, you may have noticed that some variables and functions have <code>_</code> and <code>__</code> listed in front (e.g. <code>__init__</code>, <code>__del__</code>).  Here are what these mean:</p>

<ul>
  <li><code>_singleleadingunderscore</code> - a single leading underscore usually means an ‘internal use’ indicator (i.e. this field is used only in this context, you should not access it).  This is more than just convention; when a class is imported, the objects that start with an <code>_</code> are not imported.</li>
  <li><code>singletrailingunderscore_</code> - a single trailing underscore means avoiding a conflict with a Python keyword (e.g. class is now class_)</li>
  <li><code>__doubleleadingunderscore</code> - double leading underscores mean that the variables should be private and you should not access them (but really you still can since this is Python).  The idea is that subclasses should not accidentally override the private methods and attributes of their superclasses so Python does <strong>name mangling</strong>, which creates a class attribute in the pattern <code>_classname__spam</code>.</li>
  <li><code>__doubleleadingandtrailunderscore__</code> - double leading and trailing underscores is reserved for Python’s magic/builtin methods or variables.  Do not create these, just use them as documented (e.g. <code>__init__</code>, <code>__doc__</code>).  See the magic methods section for more on this.</li>
</ul>

<h4 id="a-idinheritanceclass-inheritance-aka-derived-class-subclassa"><a id="inheritance">Class Inheritance (aka Derived Class, Subclass)</a></h4>

<p>Classes can support <strong>inheritance</strong>, which can include <strong>single inheritance</strong> and <strong>multiple inheritance</strong> (Note: avoid multiple inheritance, this gets too complicated).  The idea is that for the code <code>class Dog(Pet)</code>, a class named <code>Dog</code> inherits the features from the parent class <code>Pet</code>.</p>

<p>Classes can be derived from other classes and these can take many forms.  A <strong>derived class</strong> (aka <strong>subclass)</strong> is a class that is derived from another class.  As soon as we create a class, we are actually already subclassing from an object (e.g. <code>class Human(object):</code>).  A more obvious example of inheritance would be a class <em>Car</em> and class <em>Truck</em> inheriting from class <em>Vehicle</em>, (<code>class Car(Vehicle)</code>, <code>class Truck(Vehicle)</code>).  For example:</p>

<pre><code>class Vehicle(object):
    """ A vehicle for sale """

    base_sale_price = 0

    def __init__(self, wheels, miles, make, model, year, sold_on):
        """ Return a new Vehicle object """
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on

    def sale_price(self):
        """ Return the sale price for this vehicle """
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels

    def purchase_price(self):
        """ Return the price we would pay to purchase the vehicle """
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return self.base_sale_price - (.10 * self.miles)

class Car(Vehicle):
    def __init__(self, wheels, miles, make, model, year, sold_on):
        """ Return a new Car object """
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        ...

class Truck(Vehicle):
    def __init__(self, wheels, miles, make, model, year, sold_on):
        """ Return a new Car object """
        self.wheels = wheels
        self.miles = miles
        self.make = make
        self.model = model
        ...
</code></pre>

<h4 id="a-idabstractbaseclassabstract-base-classa"><a id="abstractbaseclass">Abstract Base Class</a></h4>

<p>In the above, we have a few issues in that there is still some repetition of fields and now we have a <em>Vehicle</em> object when it is really a concept (and not a real thing).  We can abstract these methods with <code>from abc import ABCMeta, abstractmethod</code>.  For example:</p>

<pre><code>from abc import ABCMeta, abstractmethod

class Vehicle(object):
    """ Vehicle for Sale """

    __metaclass__ = ABCMeta
    
    base_sale_price = 0
    wheels = 0

    def __init__(self, miles, make, model, year, sold_on):
        self.miles = miles
        self.make = make
        self.model = model
        self.year = year
        self.sold_on = sold_on

    def sale_price(self):
        """Return sale price"""
        if self.sold_on is not None:
            return 0.0  # Already sold
        return 5000.0 * self.wheels
    
    def purchase_price(self):
        """ Return price we pay to purchase the vehicle """
        if self.sold_on is None:
            return 0.0  # Not yet sold
        return self.base_sale_price - (.10 * self.miles)

    @abstractmethod
    def vehicle_type(self):
        """ Return a string representing the type of vehicle this is """
        pass

class Car(Vehicle):
    """ A Car """

    base_sale_price = 8000
    wheels = 4

    def vehicle_type(self):
        """ Return a string representing the type of vehicle this is """
        return 'car'

class Motorcycle(Vehicle):
    """ A Motorcycle """

    base_sale_price = 4000
    wheels = 2

    def vehicle_type(self):
        """ Return a string representing the type of vehicle this is """
        return 'motorcycle'
</code></pre>

<p><strong>Abstract Base Class</strong> creates a class that you can only inherit from.  By putting <code>__metaclass__ = ABC</code>, we created an ABC.</p>

<p><strong>abstractmethod</strong> requires that the class has a <code>__metaclass__ = ABCMeta</code>. </p>

<h4 id="a-idreflectionreflection-aka-introspectiona"><a id="reflection">Reflection (aka Introspection)</a></h4>

<p><strong>Reflection</strong> (aka <strong>introspection</strong>) means finding out about the type, class, attributes and methods of an object.  Some reflection-enabling functions include:</p>

<ul>
  <li><code>type()</code></li>
  <li><code>isinstance()</code> - check if this is an instance of a class; checks attribute <code>class.__instancecheck__(self, instance)</code>.  E.g. <code>isinstance(instance, class)</code></li>
  <li><code>issubclass()</code> - check if this is a subclass of a class; checks attribute <code>class.__subclasscheck__(self, subclass)</code>.  E.g. <code>issubclass(subclass, class)</code></li>
  <li><code>callable()</code> - check if this instance of your class can be called as if it were a function.</li>
  <li><code>dir()</code></li>
  <li><code>getattr()</code></li>
</ul>

<h4 id="a-idsupersuperclass-and-supera"><a id="super">Superclass and <code>super()</code></a></h4>

<p>With class inheritance, you can have many hierarchies.  For example, if C is a subclass of C1 and C1 is a subclass of C2, we have the linear hierarchy of [C, C1, C2].  With multiple inheritance this can get pretty crazy with no linearization (so try to avoid using multiple inheritance).  The set of rules that construct this linearization of C is called the <strong>Method Resolution Order (MRO)</strong> (aka <strong>C3 superclass linerization</strong>) and can be found under the <strong>mro</strong> attribute.</p>

<p>We can use <code>super()</code> to get the class hierarchy when there is single inheritance without having to name the parent classes explicitly.</p>

<pre><code>class C(B):
    def method(self, arg):
        super().method(arg)  # same as super(C, self).method(arg)
</code></pre>

<h4 id="a-idmetaclassesmetaclasses-and-typea"><a id="metaclasses">Metaclasses and <code>type</code></a></h4>

<p>So we know that classes are templates to create objects.  We can also have templates to build classes; these are called <strong>metaclasses</strong>.  So basically, classes are instances of something called metaclasses (the idea is kind of like how we have instances of classes).  The base metaclass is an instance of <code>type</code> (which is a kind of object).  To create this, you can do:</p>

<pre><code> class mymeta(type):
     pass
</code></pre>

<p>We don’t really need to use metaclasses or type.</p>

<h2 id="a-idmagicmethodsclass-magic-methodsa"><a id="magicmethods">Class Magic Methods</a></h2>

<p>Python has a few ‘magic’ methods that add ‘magic’ to your classes.  These methods range from helping with initialization, showing how classes are represented, and what attributes are accessed.  This is a more in-depth and advanced look into how classes work in Python.</p>

<h4 id="a-idmagicmethodsconstructionconstruction-and-initializationa"><a id="magicmethodsconstruction">Construction and Initialization</a></h4>

<p><code>__new__(cls, ...)</code> - this is the first method called when a object is instantiated.  It takes the class and any arguments and passes this to <code>__init__</code>.  This is not used too often except for sublassing an immutable type (like a tuple or string).</p>

<p><code>__init__(self, ...)</code> - this is the initializer for a class; it gets passed when a new instance is created.  For example, <code>will = Person('William', 30)</code> would pass in the values <code>William</code> and <code>30</code> as arguments.</p>

<p><code>__del__(self)</code> - this is destructor; this defines behavior for when an object is garbaged collected (e.g. close a database connection, close a file object).  There is no guarantee that this will be executed on exit so be careful.</p>

<pre><code>from os.path import join

class FileObject:
    """ Wrapper for file objects """
    def __init__(self, filepath='~', filename='sample.txt'):
        # open a file filename in filepath in read and write mode
        self.file = open(join(filepath, filename), 'r+')
    def __del__(self):
        self.file.close()
        del self.file
</code></pre>

<h4 id="a-idmagicmethodsrepresentationrepresentation-of-classa"><a id="magicmethodsrepresentation">Representation of Class</a></h4>

<p>You can represent your class usually as a custom string.</p>

<p><code>__str__(self)</code> - this represents what happens when <code>str()</code> is called on the instance of your class.  Usually this returns a useful human readable name.</p>

<p><code>__dir__(self)</code> - this represents what happens when <code>dir()</code> is called on the instance of your class.  Usually you do not modify this, it just returns a list of attributes of your class.</p>

<h4 id="a-idmagicmethodsattributeaccessattribute-accessa"><a id="magicmethodsattributeaccess">Attribute Access</a></h4>

<p>Some say that Python does not have true encapsulation for classes (e.g. no way to define private attributes and then have a public getter and setters).  Python actually does have a lot of encapsulation through these ‘magic’ methods.</p>

<p><code>__getattr__(self, name)</code> - this represents what happens when a user attempts to access an attribute that does not exist.  This is commonly used in catching and redirecting common misspellings, giving warnings about deprecated attributes or methods.</p>

<p><code>__setattr__(self, name, value)</code> - this assigns a value to an attribute regardless of whether or not that attribute exists.</p>

<p><code>__delattr__(self, name)</code> - this attempts to delete an attribute regardless of whether or not that attribute exists.</p>

<p><code>__getattribute__(self, name)</code> - try to avoid this and use <code>__getattr__</code> instead since this has a higher chance of implementing infinite recursion.</p>

<h2 id="a-iddescriptorsdescriptorsa"><a id="descriptors">Descriptors</a></h2>

<p><strong>Descriptors</strong> are classes that have any of the methods <code>__get__()</code>, <code>__set__()</code>, and/or <code>__delete__()</code> defined.  The default behavior for these attribute access is to get, set, or delete the attribute from an object’s dictionary.  When you define your own method, you override the default behavior.  So why would you want to do that?  Descriptors are what’s used in defining properties, (bound and unbound) methods, static methods, class methods, and <code>super()</code>.</p>

<p><strong>Descriptor Protocol</strong></p>

<ul>
  <li><code>descr.__get__(self, obj, type=None)</code> –&gt; value</li>
  <li><code>descr.__set__(self, obj, value)</code> –&gt; None</li>
  <li><code>descr.__delete__(self, obj)</code> –&gt; None</li>
</ul>

<p>Depending on what methods you define/override, this results in different types of descriptors (and this type determines how overrides are calculated).</p>

<ul>
  <li>If you only define <code>__get__()</code>, this is a <strong>non-data descriptor</strong>.  This is typically used for methods</li>
  <li>If you define both <code>__get__()</code> and <code>__set__()</code>, this is a <strong>data descriptor</strong>.</li>
</ul>

<p><strong>Invoking Descriptors</strong></p>

<p>Descriptors are not meant to be used alone and instead are used when building object-oriented databases or classes that have attributes whose values are dependent on each other.</p>

<pre><code>class Meter(object):
    ''' Descriptor for a meter '''

    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)

class Distance(object):
    ''' Class to represent distance using descriptor for meters '''
    meter = Meter()
</code></pre>

<p><strong>property()</strong></p>

<p>Calling <strong>property()</strong> is a quick (and recommended) way to access or set an attribute.  When you want read-only properties, then use the <code>@property</code> decorator.</p>

<h4 id="a-idmagicmethodscontainerobjectscontainer-objectsa"><a id="magicmethodscontainerobjects">Container Objects</a></h4>

<p>We can implement <strong>container objects</strong>, these can be <strong>sequences</strong> (like lists, tuples) or <strong>mappings</strong> (like dictionaries) or any other container type.  Container objects can be:</p>

<ul>
  <li>An <strong>immutable container</strong> requires:
    <ul>
      <li><code>__len__</code></li>
      <li><code>__getitem__</code></li>
    </ul>
  </li>
  <li>A <strong>mutable container</strong> requires:
    <ul>
      <li><code>__len__</code></li>
      <li><code>__getitem__</code></li>
      <li><code>__setitem__</code></li>
      <li><code>__delitem__</code></li>
    </ul>
  </li>
  <li>An <strong>iterable</strong> requires:
    <ul>
      <li><code>__iter__</code></li>
      <li><code>__next__</code></li>
    </ul>
  </li>
</ul>

<p>As for the actual protocols, here is a short (and not complete) list:</p>

<p><code>__len__(self)</code> - returns the length of the container; used on both immutable and mutable containers.</p>

<p><code>__getitem__(self, key)</code> - defines behavior for when an item is accessed.  The notation is: <code>self[key]</code>.  This raises <code>TypeError</code> if the type of the key is wrong and <code>KeyError</code> if there is no corresponding value for the key.</p>

<p><code>__setitem__(self, key, value)</code> - defines behavior for when an item is assigned.  The notation is <code>self[nkey] = value</code>.  This raises <code>TypeError</code> if the type of the key is wrong and <code>KeyError</code> if there is no corresponding value for the key.</p>

<p><code>__delitem__(self, key)</code> - defines behavior for when an item is deleted.  The notation is <code>del self[key]</code>.  The notation is <code>self[nkey] = value</code>.  This raises <code>TypeError</code> if the type of the key is wrong and <code>KeyError</code> if there is no corresponding value for the key.</p>

<p><code>__iter__(self)</code> - is an iterator for the container.  For example <code>for x in container:</code>.  Iterators are their own objects and they also must define an <code>__iter__</code> method that returns <code>self</code>.</p>

<h4 id="a-idmagicmethodscallablecallable-objectsa"><a id="magicmethodscallable">Callable Objects</a></h4>

<p>Python functions are first-classed objects; this means they can be passed to functions and methods as if they were objects of any other kind.  A special magic method <code>__call__(self, ...)</code> allows an instance of the class to behave as if they were functions.  This means <code>x()</code> is the same as <code>x.__call__</code>.  This is useful in classes whose instances need to change an object’s state.</p>

<pre><code>class Entity(object):
    """ Class to represent an entity.  Callable to update the entity's position.  If no class inheritance, it is good practice to explicitly inherit from type 'object' """

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        """ Change the position of the entity """
        self.x, self.y = x, y
</code></pre>

<h4 id="a-idnewstyleoldstylenew-style-classes-and-old-style-classesa"><a id="newstyleoldstyle">New Style Classes and Old Style Classes</a></h4>

<p>Don’t worry about this if you’re using a current version of Python (e.g. 2.7 or 3+).  You’re using a new style object or class (Note: a class is new style if it inherits from <code>object</code> or <code>type</code>).</p>

<h2 id="a-idcontextmanagerscontext-managersa"><a id="contextmanagers">Context Managers</a></h2>

<p>PEP 343 introduces a new <strong>with</strong> statement to Python so we don’t have to be as reliant on <strong>try/finally</strong> statements. we have context managers that provide <strong>enter</strong>() and <strong>exit</strong>() methods that are invoked on entry to and exit from the body of the <strong>with</strong> statement.  For example, the below statement is roughly translated to:</p>

<pre><code>with VAR = EXPR:
    BLOCK

VAR = EXPR
VAR.__enter__()
try:
    BLOCK
finally:
    VAR.__exit__()
</code></pre>


</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
      <li><span>17 Oct 2015</span> <a href="/2015/10/17/django.html">Django Web Framework</a></li>
    
      <li><span>04 Oct 2015</span> <a href="/2015/10/04/testing.html">Testing</a></li>
    
      <li><span>03 Oct 2015</span> <a href="/2015/10/03/django-rest-framework.html">Django REST Framework (DRF)</a></li>
    
  </ul>
</div>

    <div class="footer">
      <div class="contact">
        <p>
          William Liu<br/>
        </p>
      </div>
      <div class="contact">
        <p>
          <a href="http://github.com/williamqliu/">github.com/williamqliu</a><br/>
        </p>
      </div>
    </div>
  </div>

  <!--
  <a href="http://github.com/williamqliu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  -->

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36019998-1', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Google Analytics end -->
</body>

</html>