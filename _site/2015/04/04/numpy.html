<!DOCTYPE html>
<html>
<head>
   <title>NumPy</title>
   <meta name="William Liu" content="William Liu" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- LaTeX support -->
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
     MathJax.Hub.Config({
     extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
    });
   </script>

</head>

<body>
  <div class="site">
    <div class="title">
      <a href="/">William Liu</a>
    </div>

    <div id="post">
<h2 id="numpy">NumPy</h2>

<hr />

<p><strong>Summary</strong></p>

<p>NumPy takes Python's <strong>sequence data type</strong> (things like a list, which is flexible and lets you put in any data type) and takes it a step more specific by making it much more efficient at the cost of making data <strong>homogeneous</strong> (only the same <code>dtype</code>, like float64 or string).  The idea is that with this new array type (<code>ndarray</code>), you can <strong>broadcast</strong> (work with different array sizes) and apply <strong>vectorized</strong> operation (i.e. no for-loops) to the entire array at the same time instead of element by element (i.e. like a <strong>scalar</strong>).  This makes it really quick and there are a bunch of useful statistical methods.  Because NumPy is optimized for speed, the operations (e.g. modifying sliced objects, sorting) is done inplace instead of making copies.  If you want copies, you need to explicitly state it.</p>

<hr />

<p><strong>About Numpy</strong></p>

<p>NumPy stands for Numerical Python and is a fundamental package for scientific computing in Python.  With NumPy, we get array-oriented computing, which includes:</p>

<ul>
  <li><code>ndarray</code>, multidimensional (n) array, whose advantages are:
    <ul>
      <li>Vectorization - does batch operations without writing any for-loops</li>
      <li>Scalar - does operations that affect a single element at a time</li>
      <li>Broadcasting - allows operations with different sized arrays</li>
    </ul>
  </li>
  <li>NumPy does fast operations on arrays including linear algebra, statistical operations</li>
  <li>There are tools for integrating with C, C++</li>
</ul>

<hr />

<p><strong>Table</strong></p>

<ul>
  <li>Array objects (i.e. <code>ndarray</code>)
    <ul>
      <li>Create (zeros, ones, empty, arange, linspace)</li>
      <li>Data Types (dtype, astype)</li>
      <li>Shape (shape, ndim, reshape, ravel, transform)</li>
      <li>Random function (seed, rand, distributions)</li>
    </ul>
  </li>
  <li>Array manipulation: copy, slice, index
    <ul>
      <li>Copy</li>
      <li>Basic Slice and Index</li>
      <li>Advanced Indexing (integer, boolean, fancy)</li>
    </ul>
  </li>
  <li>Descriptive statistical methods
    <ul>
      <li>Aggregate, Summarize</li>
      <li>Sorting</li>
      <li>Set logic (unique, intersect1d, union1d, setdifference)</li>
      <li>Linear Algebra Methods</li>
      <li>Matrix Operations</li>
    </ul>
  </li>
  <li>Universal Functions (ufuncs, vectorized operations)
    <ul>
      <li>Unary ufuncs (abs, exp, log, sqrt, floor, isnan)</li>
      <li>Binary ufuncs (add, subtract, multiple, divide, mod)</li>
    </ul>
  </li>
  <li>Array Iteration
    <ul>
      <li>Single array iteration</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="ndarray">ndarray</h2>

<p><code>ndarray</code> is a N-dimensional array object, which is a collection of <strong>homogeneous data</strong> (i.e. all items must be the same type).  Items can be indexed and each item takes up the same size block of memory.  Note that this is not Python’s standard library of <code>array.array</code>, which is only one-dimensional and more limited functionality.</p>

<ul>
  <li>Vectorization - do batch operations without writing any for loops</li>
  <li>Scalars - propogate changes to each element at a time</li>
  <li>Broadcasting - operations between different sized arrays</li>
</ul>

<hr />

<h2 id="create">CREATE</h2>

<h4 id="array-creating-an-ndarray">array (creating an ndarray)</h4>

<p>The easiest way to create an <code>ndarray</code> is to use the <strong>array</strong> and passing in a sequence object (e.g. a list, array).</p>

<pre><code>import numpy as np

#create ndarray by passing in a sequence
data = [6, 7.5, 8, 0, 1]
my_array = np.array(data)  #array([ 6., 7.5, 8., 0., 1. ])

#create ndarray by initializing values
one_dim = np.array([2, 3, 4], dtype='int16')  # can specify type
two_dim = np.array([[1.5, 2., 3.],  # nested sequences make multidimensions
                   [4., 5., 6.]])
three_dim = np.array([[[1., 2., 3.],
                       [4., 5., 6.]],
                      [[7., 8., 9.],
                       [10, 11, 12]]])
</code></pre>

<h4 id="zeros-ones-empty">zeros, ones, empty</h4>

<p>You can create an ndarray specifically with <strong>zeros</strong> (initial values of 0), <strong>ones</strong> (initial values of 1), <strong>empty</strong> (no initial values).  For a single dimension, enter in a number.  For multidimensional, enter a tuple.</p>

<pre><code>temp = np.zeros(10)  # create a single dimension
temp  #array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

temp = np.zeros((2, 4))  # create multidimensional with tuple
#array([[0., 0., 0., 0.],
#       [0., 0., 0., 0.]])

temp = np.ones((1, 2, 3))  # create multidimensional with tuple
#array([[[1., 1., 1.],
#        [1., 1., 1.]]])
</code></pre>

<h4 id="arange-linspace">arange, linspace</h4>

<p><strong>arange</strong> returns the number of samples.  <code>arange</code> is an array-valued version of Python’s <code>range</code> function and unless specified, is a <code>float64</code> data type.</p>

<pre><code>np.arange(7)
#array([0, 1, 2, 3, 4, 5, 6])
</code></pre>

<p><strong>linspace</strong> is like <code>arange</code>, but it uses a step size instead of explicitly saying the number of samples.  <code>linspace(start, stop, num=50)</code> returns evenly spaced numbers over a specified interval <code>num</code>.  If <code>endpoint=True</code> then <code>stop</code> is the last sample (otherwise not included)</p>

<pre><code>np.linspace(0, 5, num=6, endpoint=True)
#array([1, 1.8, 2.6, 3.4, 4.2, 5.])
</code></pre>

<hr />

<h2 id="shape">SHAPE</h2>

<p>You can see and modify the shape of your ndarray using a variety of tools, including: <strong>shape</strong>, <strong>ndim</strong>, <strong>reshape</strong>, <strong>ravel</strong>, <strong>t</strong></p>

<h4 id="shape-1">shape</h4>

<p>Each ndarray has a <strong>shape</strong>, a tuple indicating the size of each dimension.  The first argument is the rows, second argument is the number of columns.</p>

<pre><code>#shape
print one_dim.shape  #(3,)
print two_dim.shape  #(2, 3)
print three_dim.shape  #(2, 2, 3)
</code></pre>

<h4 id="ndim">ndim</h4>

<p>The ndarrays are n-dimensional, you can find the n-dimensions with <strong>ndim</strong>.  </p>

<pre><code>#ndim
one_dim.ndim  #1
two_dim.ndim  #2
three_dim.ndim  #3
</code></pre>

<h4 id="reshape">reshape</h4>
<p>If you want to change the shape, then do a <strong>reshape</strong>.</p>

<pre><code>#reshape
np.reshape(one_dim, (1, 3))
#array([[2, 3, 4]], dtype=int16)
</code></pre>

<h4 id="ravel">ravel</h4>

<p>If you want to flatten the array, do a <strong>ravel</strong>.  </p>

<pre><code>#ravel
np.ravel(two_dim)
#array([1.5, 2., 3., 4., 5., 6.])
</code></pre>

<h4 id="t">t</h4>

<p>If you want to transpose, use <strong>t</strong>.</p>

<pre><code>#Transpose (T)
temp = np.array([[1., 2., 3.], [4., 5., 6.]])
temp.T
#array([[1., 4.],
#       [2., 5.],
#       [3., 6.]])
</code></pre>

<hr />

<h2 id="data-types">DATA TYPES</h2>

<h4 id="dtype">dtype</h4>

<p>Each ndarray can only have one data type (i.e. <strong>homogeneous</strong>).  This is stored in <strong>dtype</strong>.  By default, numpy does a good job figuring it out.  There is a type name (like <code>float</code> or <code>int</code>) with the number of bits per element.</p>

<pre><code>one_dim.dtype  #dtype('int16')
two_dim.dtype  #dtype('float64')
three_dim.dtype  #dtype('float64')
</code></pre>

<h4 id="astype">astype</h4>

<p>You can explicitly convert or cast an array from one dtype to another using ndarray’s <code>astype</code> method.  If conversion fails, a <code>TypeError</code> will be raised.  Using <code>astype</code> always creates a new array (a copy of the data).</p>

<pre><code>default_array = np.array([1, 2, 3, 4, 5])
default_array.dtype  # dtype('int64')

float_array = default_array.astype(np.float64)
float_array.dtype  #dtype('float64')
</code></pre>

<h4 id="floating-point-error">floating point error</h4>

<p>When doing complex calculations, you might get a floating point error because <code>float64</code> and <code>float32</code> arrays are only capable of approximating fractional quantities (so comparisons are only valid up to a certain number of decimal places)</p>

<hr />

<h2 id="random">RANDOM</h2>

<p><strong>random</strong> returns random numbers in a given shape, specifies different seed values, shuffles, types, ranges, and distributions.  There are a lot of other random functions (e.g. for multinomial, multivariate_normal), these are just a few:</p>

<ul>
  <li><code>random.seed</code> sets a specific seed for the rng</li>
  <li><code>permutation</code> creates a random sequence</li>
  <li><code>shuffle</code> modifies a sequence in place by shuffling contents</li>
  <li><code>rand</code> creates array of given shape with random uniform distribution (0 to 1)</li>
  <li><code>randint</code> returns random integers from low (inclusive) to high (exclusive)</li>
  <li><code>randn</code> return a sample from the standard normal distribution (0 to 1)</li>
  <li><code>binomial</code> return sample(s) from a binomial distribution (0 to 1); like a coin toss results</li>
  <li><code>normal</code> return sample(s) from a normal (Gaussian) distribution; the ‘bell curve’</li>
  <li><code>logistic</code> returns sample(s) from a logistic distribution</li>
  <li><code>chisquare</code> returns sample(s) from a chisquare distribution</li>
  <li><code>gamma</code> returns sample(s) from a Gamma distribution</li>
  <li><code>beta</code> returns sample(s) of the Beta distribution, a special case of the Dirichlet distribution</li>
  <li><code>uniform</code> returns sample(s) from a uniform distribution</li>
</ul>

<h4 id="randomseed">random.seed</h4>

<p><strong>seed</strong> saves a RandomState in the random number generator so the results are reproducable.  You just set it at the beginning before calling your random numbers.</p>

<pre><code>np.random.seed(123)
</code></pre>

<h4 id="randompermutation">random.permutation</h4>

<p><strong>permutation</strong> creates a random sequence</p>

<pre><code>np.random.permutation(10)
array([1, 7, 3, 0, 9, 2, 5, 8, 6])
</code></pre>

<h4 id="randomshuffle">random.shuffle</h4>

<p><strong>shuffle</strong> just shuffles the items</p>

<pre><code>arr = np.arange(10)
np.random.shuffle(10)  #[1, 7, 5, 2, 9, 4, 3, 6, 0, 8]
</code></pre>

<h4 id="randomrand">random.rand</h4>

<p><strong>rand</strong> creates an array of a given shape (first arg is rows, second arg is columns) with a random uniform distribution (values 0 to 1)</p>

<pre><code>np.random.rand(3, 4)
#array([[.004, .544, .077, .701],
#       [.660, .712, .748, .948],
#       [.979, .854, .973, .631]])
</code></pre>

<h4 id="randomrandint">random.randint</h4>

<p><strong>randint</strong> returns a random integer based on first argument (lowest value), second argument (highest value, exclusive), and an optional size or shape of array.</p>

<pre><code>np.random.randint(low=0, high=10, size=2)  # create 2 random ints 0-10
#array([5, 7])

np.random.randint(0, 100, (3, 4))  # create array (3, 4) with random ints 0-100
#array([[10, 92, 15, 72],
#       [ 7, 15, 44, 12],
#       [52, 69, 85, 74]])
</code></pre>

<h4 id="randomrandn">random.randn</h4>

<p><strong>randn</strong> returns sample(s) from a standard normal distribution (0-1)</p>

<pre><code>np.random.randn()  # get a single random value
#0.3706716413438257

np.random.randn(2, 4) + 1  # get an ndarray of random values
#array([[ 2.94723669,  2.52429319,  3.50433846,  1.16161333],
#       [ 0.81147123,  1.60399355, -0.12758733, -0.13248681]])
</code></pre>

<h4 id="randombinomial">random.binomial</h4>

<p><strong>binomial</strong> returns sample(s) from a binomial distribution with <code>n</code> trials and <code>p</code> probability of success where <code>n</code> &gt;=0 and <code>p</code> is in the interval [0, 1].</p>

<pre><code>results = np.random.binomial(n=10, p=.5, size=1000)
results.shape(1000,)  # Results of flipping a coin 10 times, tested 1000 times
</code></pre>

<h4 id="randomnormal">random.normal</h4>

<p><strong>normal</strong> returns sample(s) from a normal distribution with first arg as the mean, second arg as the standard deviation.</p>

<pre><code>mu, sigma = 0, 0.1  # mean and standard deviation
np.random.normal(mu, sigma, 1000)  # get 1000 normal distribution samples
</code></pre>

<h4 id="randomuniform">random.uniform</h4>

<p><strong>uniform</strong> returns sample(s) from a uniform distribution.  First argument is low (default 0, inclusive), second argument is high (default 1, exclusive), and size.</p>

<pre><code>np.random.uniform(-1, 0, size=1000)
</code></pre>

<hr />

<h2 id="array-manipulation-copy-slice-index">ARRAY MANIPULATION: COPY, SLICE, INDEX</h2>

<h3 id="copy">Copy</h3>

<p>When working with arrays, the data is not copied because NumPy is made for fast performance and some datasets can get very large.  To make a copy, you need to explicitly state <code>.copy()</code></p>

<pre><code>test = arr[2].copy()
test = arr[5:8].copy()
</code></pre>

<h3 id="slice-and-index">Slice and Index</h3>

<p>There are a variety of ways to select a subset of your data or individual elements.  <strong>Slicing</strong> is selecting a subset of your data.  The axis 0 is y (vertical, the row) and axis 1 is x (horizontal, the column).  <strong>Indexing</strong> is accessing the values of your data.  Array slicing are <strong>views</strong> on the original array, meaning the data is not copied and any modifications to the view will be reflected in the source array.</p>

<h4 id="one-dimensional-ndarray---slice-and-select-items">One Dimensional ndarray - slice and select items</h4>

<p>Each index is a scalar (e.g. <code>arr[5] = 12</code>)</p>

<pre><code>arr = np.arange(10)  #array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

arr[5]  #select single element
#5

arr[5:8]  #select subset
#array([5, 6, 7])

arr[5:8] = 12  # update values in subset with scalar (i.e. broadcasted)
#array([0, 1, 2, 3, 4, 12, 12, 12, 8, 9])
</code></pre>

<h4 id="two-dimensional-ndarray---select-individual-items">Two Dimensional ndarray - select individual items</h4>

<p>Each index is a one-dimensional array (e.g. <code>arr[5] = [7, 8, 9]</code>) instead of a scalar (e.g. <code>arr[5] = 12</code>).</p>

<pre><code>arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

arr[2]  #select single element
#array([7, 8, 9])

arr[0][2]  #select individual items
#3
arr[0, 2]  #select individual items
#3
</code></pre>

<h4 id="two-dimensional-ndarray---slice-items">Two Dimensional ndarray - slice items</h4>

<p>Slicing lets you keep specific rows and columns.  First argument is rows, second argument is columns.  A <code>:</code> means to select all, <code>:x</code> anything before x, <code>x:</code> anything after x.  What you select is inclusive and starts at 1.</p>

<h4 id="slice-by-rows-only">Slice by row(s) only</h4>

<pre><code>arr[:2,]  #slice by row, keep rows 1 to 2 (inclusive)
#array([[1, 2, 3],
#       [4, 5, 6]])
    
arr[2:3,]  #slice by row, keep rows 2 to 3 (inclusive)
#array([[7, 8, 9]])
</code></pre>

<h4 id="slice-by-columns-only">Slice by column(s) only</h4>

<pre><code>arr[:,:2]  #slice by column, keep cols 1 to 2 (inclusive)
#array([[1, 2],
#       [4, 5],
#       [7, 8]])
</code></pre>

<h4 id="slice-by-rows-and-columns">Slice by row(s) and column(s)</h4>

<pre><code>arr[:2, :2]
#array([[1, 2],
#       [4, 5]])
</code></pre>

<h4 id="multidimensional-ndarray">Multidimensional ndarray</h4>

<p>Higher dimensional objects give you more options as you can slice one or more axes and also mix integers.</p>

<pre><code>arr = np.array([[[1, 2, 3],
                 [4, 5, 6]],
                [[7, 8, 9],
                 [10, 11, 12]]])    
arr.shape  #(2, 2, 3)

arr[0]
#array([[1, 2, 3],
#       [4, 5, 6]])
</code></pre>

<h3 id="advanced-indexing">Advanced Indexing</h3>

<p><strong>Advanced array indexing</strong> happens when the selection object is a non-tuple sequence object, an <code>ndarray</code> of data type <code>integer</code> or <code>bool</code>, or a tuple with at least one sequence object or ndarray (of data type integer or bool).  There are two types of advanced indexing, <strong>integer</strong> and <strong>Boolean</strong>; these always return a copy of the data (instead of a view).</p>

<h4 id="integer-indexing">Integer indexing</h4>

<p><strong>Integer array indexing</strong> allows selection of items based on their n-dimensional index.  This is always run as a broadcast (i.e. happens all at once with no iteration).  </p>

<pre><code>#Basic indexing
x = np.array([[1, 2], [3, 4], [5, 6]])
x[[0, 1, 2], [0, 1, 0]]  # for each row, select 
#array([1, 4, 5])
</code></pre>

<h4 id="boolean-indexing">Boolean indexing</h4>

<p><strong>Boolean array indexing</strong> allows selection of items based on whether it meets a specific condition.  This is always run as a broadcast (i.e. happens all at once with no iteration).</p>

<pre><code>#strings
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe'])
names == 'Will'
#array([False, False,  True, False,  True, False], dtype=bool)
temp = (names == 'Will') | (names == 'Bob')
#array([ True, False,  True,  True,  True, False], dtype=bool)

#numbers
nums = np.random.rand(3, 4)
</code></pre>

<h4 id="fancy-indexing">Fancy indexing</h4>

<p><strong>fancy indexing</strong> describes indexing with integer arrays</p>

<pre><code>arr = np.empty((6, 4))  # initialize shape
for i in range(6):
    arr[i] = i    # set values
#array([[0., 0., 0., 0.],
#       [1., 1., 1., 1.],
#       [2., 2., 2., 2.],
#       [3., 3., 3., 3.],
#       [4., 4., 4., 4.],
#       [5., 5., 5., 5.]])

arr[[2, 5, 4]]  # select a subset of your rows in this order
#array([[ 2., 2., 2., 2.],
#       [ 5., 5., 5., 5.],
#       [ 4., 4., 4., 4.]])
</code></pre>

<hr />

<h2 id="descriptive-statistical-methods">DESCRIPTIVE STATISTICAL METHODS</h2>

<p>NumPy provides statistical methods, regardless of whether they are applying to a <code>np.ndarray</code> (i.e. a n-dimensional array) or a <code>np.matrix</code> (i.e. a 2-dimensional array).</p>

<ul>
  <li><code>sum</code> calculates the sum on all the elements in the array or along an axis</li>
  <li><code>mean</code> calculates the arithmetic mean</li>
  <li><code>std</code> is the standard deviation</li>
  <li><code>var</code> is the variance with an optional degrees of freedom</li>
  <li><code>min</code> is the minimum</li>
  <li><code>max</code> is the maximum</li>
  <li><code>cumsum</code> is the cumulative sum of elements starting from 0</li>
  <li><code>cumprod</code> is the cumulative product of elements starting from 1</li>
</ul>

<h4 id="aggregation">AGGREGATION</h4>

<p>Aggregations really just <strong>reduce</strong> a lot of data (e.g. an entire array) into a smaller chunk of data (e.g. a value like the mean or sum).  You can do <strong>aggregations</strong> on specific axis (0 for row, 1 for column) or on the entire array.</p>

<h4 id="sum">sum</h4>

<p>Calculates the sum along an axis (0 = sum up each column, 1 = sum up each row)</p>

<pre><code>temp = np.array([[1., 2., 3., 4.], [5., 6., 7., 8.]])
np.sum(temp, axis=0)  #array([6., 8., 10., 12.])  #add up columns
np.sum(temp, axis=1)  #array([10., 26.])  #add up rows
np.sum(temp)  # 36.0  #sum of the entire array
</code></pre>

<h4 id="mean">mean</h4>

<p>Calculates the mean along an axis (0 = sum up each column, 1 = sum up each row)</p>

<pre><code>np.mean(temp, axis=0)  #array([3., 4., 5., 6.])  #add up columns
np.mean(temp, axis=1)  #array([2.5, 6.5])  #add up rows
np.mean(temp)  #4.5  #mean of the entire array
</code></pre>

<h4 id="min-max">min, max</h4>

<p>Calculates the min or max along an axis (0 = sum up each column, 1 = sum up each row)</p>

<pre><code>np.min(temp)  # 1.0
np.max(temp)  #8.0
</code></pre>

<h4 id="std">std</h4>

<p>Calculates the <strong>standard deviation (SD)</strong>, a measure used to quantify the amount of variation or dispersion of a set of values.</p>

<pre><code>np.std(temp)  #2.29128
</code></pre>

<hr />

<h2 id="sorting-unique-set-logic">SORTING, UNIQUE, SET LOGIC</h2>

<h4 id="npsort">np.sort</h4>

<p>You can sort data a number of ways (<code>quicksort</code>, <code>mergesort</code>, <code>heapsort</code>).  This operation applies inplace.</p>

<pre><code>temp = np.random.randn(8)  # sort a flattened array
temp.sort()  # sorts inplace
temp  #array([-0.211,  0.298,  0.749,  0.897,  0.949])  # sorted

temp = np.array([[6, 5, 4,], [3, 2, 1]])  # sort in ascending
temp.sort()
temp
#array([[4, 5, 6],
#       [1, 2, 3]])
</code></pre>

<h4 id="npunique">np.unique</h4>

<p>Find the unique elements in an array.  Can return additional indormation like where the index is, how often the occurrence.</p>

<pre><code>np.unique([1, 2, 1, 2, 3, 7, 7, 7])  # 1 dimension
#array([1, 2, 3, 7])

# 2 dimensional, also count occurrence
temp = np.array([['a', 'a', 'b'], ['b', 'c', 'd']])
x, y = np.unique(temp, return_counts=True)  # 2 dimensional
#array(['a', 'b', 'c', 'd'], dtype='|S1'), array([2, 2, 1, 1]))
</code></pre>

<h4 id="npintersect1darg1-arg2">np.intersect1d(arg1, arg2)</h4>

<p><code>intersect1d</code> is the sorted, unique values in both input arrays.</p>

<pre><code>np.intersect1d([1, 2, 3, 4], [3, 2, 5, 6])
#array([2, 3])
</code></pre>

<h4 id="npunionarg1-arg2">np.union(arg1, arg2)</h4>

<p><code>union</code> returns the unique, sorted array of values that are in either of the two input arrays.</p>

<pre><code>np.union1d([-1, 0, 1], [-2, 0, 2])
array([-2, -1,  0,  1,  2])
</code></pre>

<hr />

<h2 id="linear-algebra">LINEAR ALGEBRA</h2>

<ul>
  <li><code>dot</code> returns the dot product of two vectors</li>
  <li><code>trace</code> returns the sum along diagonals of the array</li>
  <li><code>det</code> computes the determinant of an array</li>
  <li><code>eig</code> computes the eigenvalue</li>
  <li><code>inv</code> computes the multiplicative inverse of a matrix</li>
  <li><code>pinv</code> computes the Moore-Penrose pseudoinverse of a matrix</li>
  <li><code>qr</code> computes the qr factorization of a matrix</li>
  <li><code>svd</code> singular value decomposition</li>
  <li><code>solve</code> solves a linear matrix equation or system of linear scalar equations</li>
  <li><code>lstsq</code> returns the least-squares solution to a linear matrix equation</li>
</ul>

<h4 id="dot">dot</h4>

<p><code>dot</code> returns the product of two vectors</p>

<pre><code>x = np.array([1, 2, 3, 4])
y = np.array([5, 6, 7, 8])

np.dot(x, y)  #70  #dot product of two arrays
</code></pre>

<h4 id="solve">solve</h4>

<p><code>solve</code> returns the solution to a linear matrix equation (i.e. 2 different equations)</p>

<pre><code>a = np.array([[3,1], [1,2]])
b = np.array([9,8])
np.linalg.solve(a, b)
</code></pre>

<hr />

<h2 id="matrix-operations">MATRIX OPERATIONS</h2>

<p>A <code>np.matrix</code> is just a 2-dimensional <code>np.ndarray</code>.  Here are some additional functions for them that can help with matrix operations.</p>

<h4 id="eye-identity">eye, identity</h4>

<p>Create a square N * N identity matrix (1s on the diagonal and 0s elsewhere)</p>

<pre><code>np.eye(2, dtype=int)
#array([[1, 0],
#       [0, 1]])
</code></pre>

<hr />

<h2 id="universal-functions">UNIVERSAL FUNCTIONS</h2>

<p>A <strong>universal function</strong> (aka <strong>ufunc</strong>) is a function that performs elementwise operations on data in ndarrays.  They’re fast vectorized wrappers for simple functions.</p>

<ul>
  <li><code>abs</code> computes the absolute value element-wise for that value</li>
  <li><code>sqrt</code> computes the square root of each element</li>
  <li><code>square</code> computes the square of each element</li>
  <li><code>log</code> creates the natural logarithm (can be different bases)</li>
  <li><code>ceil</code> computes the ceiling of each element (i.e. smallest int of element)</li>
  <li><code>floor</code> computes the floor each element (i.e. largest int of element)</li>
  <li><code>isnan</code> returns a boolean array indicating whether value is <code>NaN</code></li>
  <li><code>isinfinite</code>, <code>isinf</code> returns boolean array if finite or infinite.</li>
  <li><code>cos</code>, <code>sin</code>, <code>tan</code> applies the trigonometric functions </li>
</ul>

<p>There is also a list of <strong>binary universal functions</strong></p>

<ul>
  <li><code>add</code> adds corresponding elements in arrays</li>
  <li><code>subtract</code> subtracts elements in second array from first array</li>
  <li><code>multiply</code> multiplies array elements</li>
  <li><code>divide</code>, <code>floor_divide</code> does division or floor division (truncate remainder)</li>
  <li><code>power</code> raises first array to powers indicated in second array</li>
</ul>

<hr />

<h2 id="array-iteration">ARRAY ITERATION</h2>

<p>Sometimes you just have to iterate over an array; you can do this with <strong>nditer</strong></p>

<h4 id="npnditer">np.nditer</h4>

<p>Most basic version is to iterate over every element of an array</p>

<pre><code>a = np.arange(6).reshape(2,3)
for x in np.nditer(a):
    print x,
0 1 2 3 4 5
</code></pre>

</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
      <li><span>05 Apr 2015</span> <a href="/2015/04/05/pandas.html">Pandas</a></li>
    
      <li><span>03 Apr 2015</span> <a href="/2015/04/03/statistical-analysis.html">Statistical Analysis</a></li>
    
      <li><span>02 Apr 2015</span> <a href="/2015/04/02/python-basics.html">Python Basics</a></li>
    
  </ul>
</div>

    <div class="footer">
      <div class="contact">
        <p>
          William Liu<br/>
        </p>
      </div>
      <div class="contact">
        <p>
          <a href="http://github.com/williamqliu/">github.com/williamqliu</a><br/>
        </p>
      </div>
    </div>
  </div>

  <!--
  <a href="http://github.com/williamqliu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  -->

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36019998-1', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Google Analytics end -->
</body>

</html>