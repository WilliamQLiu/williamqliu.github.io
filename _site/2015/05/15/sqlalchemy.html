<!DOCTYPE html>
<html>
<head>
   <title>SQLAlchemy</title>
   <meta name="William Liu" content="William Liu" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- LaTeX support -->
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
     MathJax.Hub.Config({
     extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
    });
   </script>

</head>

<body>
  <div class="site">
    <div class="title">
      <a href="/">William Liu</a>
    </div>

    <div id="post">
<h2 id="sqlalchemy">SQLAlchemy</h2>

<hr />

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#dbapi">Python DBAPI</a></li>
  <li><a href="#sqlalchemycore">SQLAlchemy Core</a>
    <ul>
      <li><a href="#engine">SQLAlchemy Engine</a></li>
      <li><a href="#sqlexpressionlanguage">SQLAlchemy SQL Expression Language</a>
        <ul>
          <li><a href="#sqlalchemyexpinsert">insert()</a></li>
          <li><a href="#sqlalchemyexpselect">select()</a></li>
          <li><a href="#sqlalchemyexpoperators">operators: where(), like()</a></li>
          <li><a href="#sqlalchemyexpconjunctions">conjunctions: <code>and_</code>, <code>or_</code>, <code>not_</code></a></li>
          <li><a href="#sqlalchemyexpexecute">execute()</a></li>
          <li><a href="#resultobject">result object</a></li>
        </ul>
      </li>
      <li><a href="#sqlalchemyschema">SQLAlchemy Schema</a>
        <ul>
          <li><a href="#metadata">MetaData</a></li>
          <li><a href="#metadatatypes">MetaData Types</a></li>
          <li><a href="#ddl">DDL</a></li>
          <li><a href="#abstractionreflectionintrospection">Database Abstraction, Reflection, Introspection</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#orm">SQLAlchemy Object Relational Mapper (ORM)</a>
    <ul>
      <li><a href="#ormtypes">Types of ORMs</a>
        <ul>
          <li><a href="#ormactiverecord">Active Record</a></li>
          <li><a href="#ormdatamapper">Data Mapper</a></li>
        </ul>
      </li>
      <li><a href="#ormconfigurationpatterns">ORM Configuration Patterns</a>
        <ul>
          <li><a href="#ormdeclarative">All-at-once (aka Declarative)</a></li>
          <li><a href="#ormseparate">Separate</a></li>
          <li><a href="#ormsqlalchemypattern">SQLAlchemy ORM Pattern</a></li>
        </ul>
      </li>
      <li><a href="#ormsqlalchemyuse">SQLAlchemy ORM Usage</a>
        <ul>
          <li><a href="#ormdeclarativebase">Step 1 - delcarative_base()</a></li>
          <li><a href="#ormschema">Step 2 - create schema</a></li>
          <li><a href="#orminstanceclass">Step 3 - create instance of the class</a></li>
          <li><a href="#ormsession">Step 4 - create session</a></li>
          <li><a href="#ormsessiondata">Step 5 - create session data</a></li>
          <li><a href="#ormcommitsession">Step 6 - commit session data</a></li>
        </ul>
      </li>
      <li><a href="#ormobjectmanipulation">SQLAlchemy ORM Object Manipulation</a>
        <ul>
          <li><a href="#ormquerying">Object Querying with query()</a></li>
          <li><a href="#ormfiltering">Object Filtering with filter() and filter_by()</a></li>
          <li><a href="#ormobjectiterating">Object Iteration</a></li>
          <li><a href="#ormnaming">Object Naming with alised() and label()</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#sqlalchemypandas">SQLAlchemy with Pandas</a>
    <ul>
      <li></li>
    </ul>
  </li>
</ul>

<h2 id="a-idsummarysummarya"><a id="summary">Summary</a></h2>

<p><strong>SQLAlchemy</strong> is a set of tools for working with databases using Python.  There are many layers to this system and you can pick which one(s) you want to use.  As for the layers, going from lowest (closest to the database) to highest level (very abstracted, closest to Python), we have:</p>

<ul>
  <li>Python DBAPI; lowest level of using Python to interact with the database.  Most of this is straight up SQL statements and little Python.</li>
  <li>SQLAlchemy Core; good mix of SQL and Python.
    <ul>
      <li>SQLAlchemy Engine; this gives SQLAlchemy and the DBAPI the ability to interact</li>
      <li>SQLAlchemy Schema; this lets you see the database metadata</li>
      <li>SQL Expression Language - slight abstraction by converting SQL statements to Python objects and vice versa.  This approach is more like the literal schema and SQL expressions.</li>
    </ul>
  </li>
  <li>SQLAlchemy Object Relational Mapper (ORM) - database is fully abstracted, we work mainly with Python classes instead of SQL for everything including mapping tables and relationships.</li>
</ul>

<h2 id="a-iddbapipython-dbapia"><a id="dbapi">Python DBAPI</a></h2>

<p>Python has numerous PEPs, which are basically features to Python (whether it is a style guide or wsgi interface).  PEP-0249 is the Python Database API and is a de-facto system for providing Python database interfaces.  This PEP makes a lot of suggestions of what to do, but does not say you should do this.  An example DBAPI is psycopg2, an adapter for Postgresql databases.</p>

<pre><code>import psycopg2
connection = psycopg2.connect("myusername", "mypassword", "test")

cursor = connection.cursor()
cursor.execute(
        "select emp_id, emp_name from employee"
        "where emp_id=%(emp_id)s",
        {'emp_id':5})  # this substitues parameter
emp_name = cursor.fetchone()[1]
cursor.close()

cursor = connection.cursor()
cursor.execute(
        "insert into employee_of_month "
        "(emp_name) values (%(emp_name)s)",  # this substitues parameter
        {"emp_name": emp_name})
cursor.close()

connection.commit()
</code></pre>

<p>A <strong>bound parameter</strong> is where you can bind a Python variable (e.g. <code>5</code>, <code>emp_name</code>) to a corresponding SQL statement parameter (e.g. <code>emp_id</code>, <code>emp_name</code>).  Be careful because this is where SQL injections can happen.</p>

<p>By default, the DBAPI does not autocommit.  That means you have to explicitly say to commit.</p>

<h2 id="a-idsqlalchemycoresqlalchemy-corea"><a id="sqlalchemycore">SQLAlchemy Core</a></h2>

<p>One layer above the Python DBAPI is the SQLAlchemy Core.  The Core is made up of the Engine (used for connecting to Python DBAPI), the SQL Expression Language (for running queries), and the Schema (for inspecting the database or the SQLAlchemy objects).</p>

<h3 id="a-idenginesqlalchemy-enginea"><a id="engine">SQLAlchemy Engine</a></h3>

<p>SQLAlchemy Engine is the piece that interfaces between SQLAlchemy and the Python DBAPI.  Here is how to setup an engine:</p>

<pre><code>import sqlalchemy

engine = sqlalchemy.create_engine('sqlite:///:memory:', echo=True)

# You can specify different engine dialect and drivers
#engine = create_engine("postgresql+psycopg2:////username:password@localhost/test")
</code></pre>

<h3 id="a-idsqlexpressionlanguagesqlalchemy-sql-expression-languagea"><a id="sqlexpressionlanguage">SQLAlchemy SQL Expression Language</a></h3>

<p>The SQL Expression Language builds on top of the Metadata above.  The idea is that SQLAlchemy has built Python objects that represent individual SQL strings (statements) that we would send to the database.  It works behind the scenes by overriding Python callable operators (e.g. <code>__eq__()</code>).  These are Python objects until we <code>execute</code> them (or <code>print</code> them), which then gets created into the SQL strings.</p>

<p>An example setup:</p>

<pre><code>from sqlalchemy import create_engine, Table, Column, Integer, String, MetaData, ForeignKey

engine = create_engine('sqlite:///:memory:', echo=True)
metadata = MetaData()

users = Table('users', metadata,
        Column('id', Integer, primary_key=True),
        Column('name', String(50),
        Column('fullname', String(50)))
addresses = Table('addresses', metadata,
        Column('id', Integer, primary_key=True),
        Column('user_id', None, ForeignKey('users.id')),
        Column('email_address', String(50), nullable=False))

metadata.create_all(engine)  # Check presence of each table before creating
</code></pre>

<h4 id="a-idsqlalchemyexpinsertinserta"><a id="sqlalchemyexpinsert">insert()</a></h4>

<p>We look at a Table and automatically create an INSERT statement.  By default, INSERT lists every column name.  If you want to specify the column names, add in the <code>values()</code> method.</p>

<pre><code>ins = users.insert()
print str(ins) # See what the INSERT statement creates
#'INSERT INTO users (id, name, fullname) VALUES (:id, :name, :fullname)'

ins = users.insert().values(name='jack', fullname='Jack Jones')
#'INSERT INTO users (name, fullname) VALUES (:name, :fullname)'

ins.compile().params
#{'fullname': 'Jack Jones', 'name': 'jack'}

result = conn.execute(ins)
# INSERT INTO users (name, fullname) VALUES (?, ?) ('jack', 'Jack Jones')
# COMMIT
</code></pre>

<h4 id="a-idsqlalchemyexpselectselecta"><a id="sqlalchemyexpselect">select()</a></h4>

<p>We look at data in an existing database using the SELECT statement.</p>

<pre><code>from sqlalchemy.sql import select

# SELECT all columns
s = select([users])
result = conn.execute(s)
# SELECT users.id, users.name, users.fullname FROM users
# COMMIT

# SELECT specific columns
s = select([users.c.name, users.c.fullname])
</code></pre>

<p>We have a few different ways we can access the data.  The simplest is to just iterate and return rows as a tuple-like object.</p>

<pre><code>for row in result:
    print row

#(1, u'jack', u'Jack Jones')
#(2, u'wendy', u'Wendy Williams')
</code></pre>

<p>You can also use methods like <code>fetchone()</code> or <code>fetchall()</code> to return results.</p>

<pre><code>result = conn.execute(s)
row = result.fetchone()
print "name:", row['name'], "| fullname:", row['fullname']

# name: jack | fullname: Jack Jones
</code></pre>

<p>You can access results through a dictionary using the string names of the columns.</p>

<pre><code>result = conn.execute(s)
row = result.fetchone()
print "name:", row['name'], "| fullname:", row['fullname']

# name: jack | fullname: Jack Jones
</code></pre>

<p>You can access results with integer indexes.</p>

<pre><code>row = result.fetchone()
print "name:", row[1], "| fullname:", row[2]

# name: wendy | fullname: Wendy Williams
</code></pre>

<p>You can also access results using the <code>Column</code> objects directly as keys.</p>

<pre><code>for row in conn.execute(s):
    print "name:", row[users.c.name], "| fullname:", row[users.c.fullname]

# name: jack | fullname: Jack Jones
# name: wendy | fullname: Wendy Williams
</code></pre>

<h4 id="a-idsqlalchemyexpoperatorsoperators-where-likea"><a id="sqlalchemyexpoperators">Operators: where(), like()</a></h4>

<p>We can add a WHERE clause to a statement by appending it to our method.  For example, here we are selecting two tables.  Note that in our WHERE clause, we are using the Python <code>==</code>, which normally returns True or False.  We can also add the LIKE clause to a statement.</p>

<pre><code>s = select([users, addresses]).where(users.c.id == addresses.c.user_id)

s = select(addresses).where(addresses.c.email_address.like('%@gmail.com'))
</code></pre>

<h4 id="a-idsqlalchemyexpconjunctionsconjunctions-and-or-nota"><a id="sqlalchemyexpconjunctions">Conjunctions: <code>and_</code>, <code>or_</code>, <code>not_</code></a></h4>

<p>We can add AND, OR, NOT similar to a SQL statement.</p>

<pre><code>from sqlalchemy.sql import and_, or_, not_

s = select([users.c.fullname + ", " 
    + addresses.c.email_address).label('title').\
    where(users.c.id == addresses.c.user_id).\
    where(
        or_(
            addresses.c.email_address.like('%@aol.com'),
            addresses.c.email_address.like('%@msn.com')
            )
        )
    ])
#
</code></pre>

<h4 id="a-idsqlalchemyexpexecuteexecutea"><a id="sqlalchemyexpexecute">execute()</a></h4>

<p>The most basic and useful method is <code>execute()</code>, which takes a string (like the above INSERT statement) and passes this through to the DBAPI.  This makes use of the <code>:emp_id</code> as the <strong>bound parameter</strong> (notice the pattern is <code>:</code>variable_name.</p>

<pre><code>result = engine.execute(
        "select emp_id, emp_name from "
        "employee where emp_id=:emp_id",
        emp_id=3)

result = engine.execute(
        "insert into users (name, fullname) "
        "values (:name, :fullname)',
        (name='will', fullname='William Liu'))
</code></pre>

<p>At this level, we are using the SQL Expression Language; its as direct a line to the DBAPI as you can get.</p>

<h4 id="a-idresultobjectresult-objecta"><a id="resultobject">Result Object</a></h4>

<p>Running the above <code>execute()</code> returns a <strong>result object</strong> (more precisely, a ResultProxy object).  This result object is like a DBAPI cursor and is basically a Python dict, but with more additional features like methods and you can iterate over it.  You can access fields like a dictionary (i.e. key-value pairs), use methods like <code>fetchone()</code>, <code>fetchall()</code>, and iterate through the object.</p>

<pre><code>result = engine.execute(
        "select users from"
        "employee where users=:users",
        users='Will')

row = result.fetchone()
print row.keys()
#[u'emp_id', u'emp_name']

print result.fetchall()
#[((1, u'ed'), (2, u'jack'), (3, u'fred'))]

for row in result:
    print row #Sample Data: (1, u'jack', u'Jack Jones')
</code></pre>

<p>When you get all the rows, it will automatically close the connection; otherwise you can manually close with: <code>result.close()</code>, which is recommended to be explicit.</p>

<h3 id="a-idschemasqlalchemy-schemaa"><a id="schema">SQLAlchemy Schema</a></h3>

<p>The SQLAlchemy schema goes into the metadata, ddls, and database abstraction, reflection, and introspection.</p>

<h4 id="a-idmetadatametadataa"><a id="metadata">Metadata</a></h4>

<p>The <strong>metadata</strong> describes the structure of the database (i.e. the tables, columns, constraints) in terms of Python data structures.  Metadata is data about the data.  This metadata is the basis for mapping SQL to Python objects.</p>

<pre><code>from sqlAlchemy import MetaData, Table, Column, Integer, String, Numeric, DateTime, Enum, ForeignKey

metadata = MetaData()

user_table = Table('users', metadata,
                Column('id', Integer, primary_key=True),
                Column('name', String(),
                Column('fullname', String()))
                )

print user_table.name  #user

print user_table.c.name  # shows columns
#Column('name', String(), table=&lt;users&gt;)

print user_table.columns.name  # can say columns instead of c
#Column('name', String(), table=&lt;users&gt;)

print user_table.columns.keys()
#['id', 'name', 'fullname']

print user_table.columns.fullname.name
#'fullname'

print user_table.columns.fullname.type
#String()

print user_table.primary_key
#PrimaryKeyConstraint(Column('id', Integer(), table=&lt;user&gt;, primary_key=True, nullable=False))
</code></pre>

<h4 id="a-idmetadatatypesmetadata-type-conversionsa"><a id="metadatatypes">MetaData Type Conversions</a></h4>

<table>
  <thead>
    <tr>
      <th>Python Type</th>
      <th>Database Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Integer()</td>
      <td>INT</td>
    </tr>
    <tr>
      <td>String()</td>
      <td>VARCHAR</td>
    </tr>
    <tr>
      <td>Unicode()</td>
      <td>VARCHAR,NVARCHAR</td>
    </tr>
    <tr>
      <td>Boolean()</td>
      <td>BOOLEAN,INT,TINYINT</td>
    </tr>
    <tr>
      <td>DateTime()</td>
      <td>DATETIME,TIMESTAMP</td>
    </tr>
    <tr>
      <td>Float()</td>
      <td>floating point values</td>
    </tr>
    <tr>
      <td>Precision()</td>
      <td>precision</td>
    </tr>
  </tbody>
</table>

<h4 id="a-idddldata-definition-language-ddla"><a id="ddl">Data Definition Language (DDL)</a></h4>

<p>Metadata was designed to look like a <strong>Data Definition Language</strong> (aka <strong>Data Description Language (DDL)</strong>); this defines data structures (i.e. is the database schema).  Notice how SQLAlchemy makes the output look like a <code>CREATE TABLE</code> in SQL.  We can use our metadata from earlier to generate a schema as well as to be generated from a schema.</p>

<pre><code>###Using SQLAlchemy, we generate a SQL schema
fancy_table = Table('fancy', metadata,
                Column('mykey', String(50), primary_key=True),
                Column('mytimestamp', DateTime),
                Column('amount', Numeric(10, 2)),
                Column('type', Enum('a', 'b', 'c'))
            )
fancy_table.create(engine)

#The above Python code generates the following SQL code:
CREATE TABLE fancy(
        mykey VARCHAR(50) NOT NULL,
        mytimestamp DATETIME,
        amount NUMERIC(10,2),
        type VARCHAR(1),
        PRIMARY KEY (mykey),
        CHECK (type IN ('a', 'b', 'c'))
    )
</code></pre>

<p>We can use metadata to link tables too.  You can do even more advanced things like creating composite foreign keys, which will create a ForeignKeyConstraint.</p>

<pre><code>#We can link to different tables we create too
address_table = Table('address', metadata,
                    Columns('id', Integer, primary_key=True),
                    Column('email_address', String(100), nullable=False),
                    Column('user_id', Integer, ForeignKey('user.id'))
                )
address_table.create(engine)

#The above Python code generates the following SQL code:
CREATE TABLE address(
        id INTEGER NOT NULL,
        email_address VARCHAR(100) NOT NULL,
        user_id INTEGER,
        PRIMARY_KEY (id),
        FOREIGN KEY(user_id) REFERENCES user (id)
    )
</code></pre>

<h4 id="a-idabstractionreflectionintrospectiondatabase-abstraction-reflection-introspectiona"><a id="abstractionreflectionintrospection">Database Abstraction, Reflection, Introspection</a></h4>

<p><strong>Database Abstraction</strong> is an application programming interface (API) that unifies the communication between a computer application (e.g. using Python) and databases (e.g. MySQL, PostgreSQL)</p>

<p><strong>Database Reflection</strong> means getting metadata from the database table and pulling that into SQLAlchemy/Python objects.  Behind the scenes, a column is represented as a <code>Column</code> object, which is associated with a <code>Table</code> object.  This is useful if you need to migrate from one database to another.</p>

<pre><code> metadata = MetaData()
 user_reflected = Table('user', metadata, autoload=True, autoload_with=engine)
 print user_reflected
 #Table('user', MetaData(bind=None), Column(u'id', INTEGER(), table=&lt;user&gt;, primary_key=True, nullable=False,))
</code></pre>

<p><strong>Database Introspection</strong> means looking at the database structure in even more detail.</p>

<pre><code>from sqlalchemy import inspect

inspector = inspect(engine)

inspector.get_table_names()
#SELECT name FROM (SELECT * FROM sqlite_master UNION ALL
#                   SELECT * FROM sqlite_temp_master)
#                   WHERE type='table' ORDER BY name
#[u'address', u'fancy', u'network', u'published', u'story', u'user']

inspector.get_columns('address_table')  # returns as a dict
#PRAGMA table_info('address_table')
#[{'primary_key':1, 'nullable':False, 'default':None, 'autoincrement':True, 'type':INTEGER(), 'name': u'id'}, {'primary_key':0, 'nullable':False, 'default':None, 'autoincrement':True, 'type':VARCHAR(length=100), 'name':u'email_address'}, {'primary_key':0, 'nullable':True, 'default':None, 'autoincrement':True, 'type':INTEGER(), 'name':u'user_id'}]
</code></pre>

<h2 id="a-idormsqlalchemy-object-relational-mapper-orma"><a id="orm">SQLAlchemy Object Relational Mapper (ORM)</a></h2>

<p>The SQLAlchemy Object Relational Mapper is another layer on top of the SQLAlchemy SQL Expression Language.  At this level, the database is abstracted so that it has more reliable compatibility with a greater range of database systems.  The our ORM we have:</p>

<ul>
  <li><strong>domain model</strong> is the set of object oriented classes (i.e. our Python objects).  We have our entire Application and individual <strong>domain objects</strong> (e.g. our Columns, Tables)</li>
  <li><strong>database</strong> is all of our database tables and rows.</li>
</ul>

<p>In general, ORMs translate between the domain model (e.g. our Python objects) and the Database data (e.g. our Tables and Row).  This might include:</p>

<ul>
  <li>Represent the basic composititons of the objects (e.g. one-to-many, many-to-one tables using foreign key associations)</li>
  <li>Provides a mean of querying the database in terms of the domain model structure</li>
  <li>Can handle data sharding (i.e. store a domain model across multiple schemas or databases)</li>
  <li>Provide patterns for data validation (i.e. checks that data going in is what you want) and coercion (i.e. is this the right data type)</li>
</ul>

<h3 id="a-idormtypestypes-of-ormsa"><a id="ormtypes">Types of ORMs</a></h3>

<p>There are two types of approaches to designing ORMs, <strong>active record</strong> and <strong>data mapper</strong>.</p>

<h4 id="a-idormactiverecordactive-recorda"><a id="ormactiverecord">Active Record</a></h4>

<p><strong>Active Record</strong> ORM means the domain objects handle their own persistence.  Basically this means if we want to make a new user, we declare a new User object and we do an INSERT statement right when it does a <code>save()</code>.</p>

<pre><code>user_record = User(name="ed", fullname="Ed Jones")
user_record.save()

user_record = User.query(name="ed").fetch()
user_record.fullname = "Edward Jones"
user_record.save()
</code></pre>

<h4 id="a-idormdatamapperdata-mappera"><a id="ormdatamapper">Data Mapper</a></h4>

<p><strong>Data Mapper</strong> tries to keep the details of persistence separate from the object being persisted.  Basically this means that if we want to make a new user, we first create an object that talks to the database (the dbsession).  We then create the new user by adding to the object.  We then do an INSERT statement with a <code>commit()</code>.  This normally means a little more configuration.</p>

<pre><code>dbsession = start_session()

user_record = User(name="ed", fullname="Ed Jones")
dbsession.add(user_record)
user_record = dbsession.query(User).filter(name="ed").first()
user_record.fullname = "Edward Jones"

dbsession.commit()
</code></pre>

<h3 id="a-idormconfigurationpatternsorm-configuration-patternsa"><a id="ormconfigurationpatterns">ORM Configuration Patterns</a></h3>

<p>ORMs have many configuration patterns, most use <strong>all-at-once</strong> (aka <strong>declarative</strong>) and others are <strong>separate</strong> (i.e. keep the declaration of domain model and table metadata separate).</p>

<h4 id="a-idormdeclarativeall-at-once-aka-declarativea"><a id="ormdeclarative">All-at-once (aka Declarative)</a></h4>

<p><strong>All-at-once</strong> (aka <strong>Declarative</strong> ) style is where the class and table information is together.  This is like the Django ORM and similar to SQLAlchemy.</p>

<pre><code># a fake declarative system
class User(ORMObject):
    tablename = 'user'
    
    name = String(length=50)
    fullname = String(length=100)

class Address(ORMObject):
    tablename = 'address'

    email_address = String(length=100)
    user = many_to_one('User')
</code></pre>

<h4 id="a-idormseparateseparatea"><a id="ormseparate">Separate</a></h4>

<p><strong>Separate</strong> - the other option is to keep Model and Table metadata separate.  This is not seen very often.</p>

<pre><code># class that is declared without any awareness of database
class User(object):
    def __init__(self, name, username):
        self.name = name
        self.username = username

# elsewhere, it's associated with a database table
mapper(
    User,
    Table("user", metadata,
        Column("name", String(50)),
        Column("fullname", String(100)
        )
    )
)
</code></pre>

<h4 id="a-idormsqlalchemypatternsqlalchemy-orm-patterna"><a id="ormsqlalchemypattern">SQLAlchemy ORM Pattern</a></h4>

<p>SQLAlchemy ORM is essentially a <strong>data mapper</strong> style ORM that has a <strong>declarative</strong> configuration.  The SQLAlchemy ORM is slightly different than the SQLAlchemy SQL Expression Language.  With the ORM, we have:</p>

<ul>
  <li><strong>Unit of Work</strong> - objects maintained by a system that tracks changes over the course of a transaction and flushes pending changes periodically.  Basically, just give me your objects and we will handle it automatically (e.g. what order to create Tables that are linked to each other).</li>
  <li><strong>Identity Map</strong> - objects are tracked by their primary key within the unit of work.  These are <em>unique</em> on that primary key identity.</li>
  <li><strong>Lazy Loading</strong> - some attributes of an object may emit additional SQL queries when they are accessed.  You do not access this additional information unless you explicitly say to load it.  This means if you access a user table, it will not load other table data.  This is more efficient if you have all the data you want.</li>
  <li><strong>Eager Loading</strong> - multiple tables are queried at once in order to load related objects and collections.  E.g. give me this user table, but also give me the related objects and collections.  This saves a trip to the database, but grabs a lot more data.</li>
  <li><strong>Method Chaining</strong> - each method returns the object back and you can chain multiple methods</li>
</ul>

<h3 id="a-idormsqlalchemyusesqlalchemy-orm-usea"><a id="ormsqlalchemyuse">SQLAlchemy ORM Use</a></h3>

<p>Here we have a basic example of using the <strong>Declarative system</strong>.  This is the recommended method, although you can use the <strong>Classical Mappings</strong> instead if you want to map a <code>Table</code> to a Python class using the <code>mapper()</code> function directly.</p>

<pre><code>from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

engine = create_engine('sqlite:///:memory:', echo=True)
Base = declarative_base()  # Capitalize first letter since its a class

class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    name = Column(String)
    fullname = Column(String)
    password = Column(String)
    
    def __repr__(self):
        return "&lt;User(name='%s', fullname='%s', password='%s')&gt;" % \
                (self.name, self.fullname, self.password)

 Base.metadata.create_all(engine)  # Create Tables (User)
</code></pre>

<p>The basic idea behind the Declarative system are these steps:</p>

<ol>
  <li>We start by making a <strong>declarative_base()</strong> class; this is a reference to determine how other classes map together (e.g. how User class relates to our Base class)</li>
  <li>We create a schema of the table in the database; this maps the Database Table with the Python object.  If this Table does not exist in the Database yet, we can use the <strong>MetaData</strong> object to help issue special commands like CREATE TABLE</li>
  <li>Now that mapping between Python objects and Database Tables are complete, we create instances of the Python object (e.g. for <code>User</code> object, we can now create a <code>User</code> of Will)</li>
  <li>We create a <code>Session</code>, which basically handles how to talk to the database</li>
  <li>We manipulate our data, whether we do things like query, filter, join, rename objects.  Once this is done, we <code>commit()</code> changes back to the database.</li>
</ol>

<h4 id="a-idormdeclarativebasestep-1---setup-a-declarativebasea"><a id="ormdeclarativebase">Step 1 - setup a declarative_base()</a></h4>

<p>We start with a <strong>declarative_base</strong> class, which is a class that maintains a catalog of classes and tables relative to that base class.  We normally only have one instance of this base class in an application.  We then map classes in terms of this base class (e.g. we create a User Table using this new Base class).</p>

<p>The purpose of the declarative base class is <strong>instrumentation</strong>, which means we augment the functionality of a regular class with additional database-enabled descriptors that represent database columns and relationships.  Since we defining the database table, we are required to have at least one column (which is part of the Primary Key) and a <code>__tablename__</code> attribute.</p>

<pre><code>from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()  # using Declarative system

class User(Base):
    __tablename__ = 'users'  # required table name
    id = Column(Integer, primary_key=True)  # required at least one Col
</code></pre>

<h4 id="a-idormschemastep-2---create-a-schemaa"><a id="ormschema">Step 2 - create a schema</a></h4>

<p>We have to specify the schema of the Table (e.g. what are the Column names, their types, table name).  This should appear in the class <code>.__table__</code> attribute.  If the Table does not exist in the database, we can use the <code>MetaData</code> object to help with commands like a CREATE TABLE statement.</p>

<h4 id="table">Table</h4>

<p>When we declared our class using the Declarative system, this automatically created a <code>Table</code> object.  We can look at the <code>__table__</code> attribute of our new class.</p>

<pre><code>&gt;&gt;&gt; User.__table__
Table('users', MetaData(bind=None),
        Column('id', Integer(), table=&lt;users&gt;, primary_key=True, nullable=False),
        Column('name', String(), table=&lt;users&gt;),
        Column('fullname', String(), table=&lt;users&gt;),
        Column('password', String(), table=&lt;users&gt;), schema=None)
</code></pre>

<h4 id="mapper">Mapper</h4>

<p>You can see how the Database Table and the Python object are mapped together by looking at the <code>.__mapper__</code> attribute.</p>

<pre><code>&gt;&gt;&gt; User.__mapper__
&gt;&gt;&gt; &lt;Mapper at 0x327e240; User&gt;
</code></pre>

<h4 id="metadata">MetaData</h4>

<p>The Table is part of a larger collection known as the <code>MetaData</code>.  This MetaData has the ability to create schema commands to the database.  For example, we can use the MetaData to do a CREATE TABLE statement using the <code>MetaData.create_all()</code> method.  In general, we can see the Base class <code>.metadata</code> attribute.  Note: Even though this looks like magic, remember that we still need to import your model (like we did with the User class).</p>

<pre><code>&gt;&gt;&gt; Base.metadata.create_all(engine)
PRAGMA table_info("users")
()
CREATE TABLE users (
    id INTEGER NOT NULL,
    name VARCHAR,
    fullname VARCHAR,
    password VARCHAR,
    PRIMARY KEY (id)
    )
()
COMMIT
</code></pre>

<h4 id="a-idorminstanceclassstep-3---create-an-instance-of-the-classa"><a id="orminstanceclass">Step 3 - create an instance of the class</a></h4>

<p>Now that we have mappings completed between the Python object (<code>class User(Base)</code>) and the Database Table (<code>CREATE TABLE users...</code>), we can now create specific instances of the <code>User</code> object.</p>

<pre><code>&gt;&gt;&gt; will_user = User(name='will', fullname='Will Liu', password='stuff')
&gt;&gt;&gt; will_user.name
'will'
&gt;&gt;&gt; will_user.password
'stuff'
&gt;&gt;&gt; str(will_user.id)
'None'
</code></pre>

<p>Note that in our instance (will_user) when we do not specify a field (e.g. the id), we get a return value of <code>None</code> instead of a regular behavior like <code>AttributeError</code> for an undefined attribute. </p>

<p>If we want to customize this, we can explicitly override the <code>__init__()</code> method created by the Declarative system for our <code>User</code> class.</p>

<h4 id="a-idormsessionstep-4---create-a-sessiona"><a id="ormsession">Step 4 - create a session</a></h4>

<p>In order to talk to the database, we need to create a <strong>Session</strong> class using the <code>sqlalchemy.orm.session.Session</code>.  There are additional helper functions like <strong>sessionmaker</strong> to generates a new <strong>Session</strong> with customized parameters and <strong>scoped_session</strong> creates a thread local proxy/manager of Session instances (i.e. which thread is asking for what session; good for multithreaded applications).</p>

<h4 id="sessionmaker">sessionmaker</h4>

<p>A <strong>sessionmaker</strong> class is normally used to create a top level <code>Session</code> configuration.  This is only created one time in your application and is a factory for creating <code>Session</code> objects.</p>

<pre><code>from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# create an Engine, the Session uses this to get DB table info
some_engine = create_engine('postgresql://will:pwd@localhost/')

# create a configured 'Session' class; sessionmaker is a factory
Session = sessionmaker(bind=engine)

# create a Session object used whenver you want to talk to the DB table
session = Session()

# Do some work with the Python object
item1 = session.query(Item).get(1)
item2 = session.query(Item).get(2)
session.commit()
</code></pre>

<h4 id="scopedsession">scoped_session</h4>

<p>A <strong>scoped_session</strong> creates a thread local proxy/manager of <code>Session</code> instances.  If you are doing multithreaded applications, you can normally just do this.  Otherwise, just ignore.</p>

<pre><code>DBSession = scoped_session(sessionmaker(engine))
companies = DBSession.query(Company).all()
</code></pre>

<h4 id="a-idormsessiondatastep-5---manipulate-data-in-a-sessiona"><a id="ormsessiondata">Step 5 - manipulate data in a session</a></h4>

<p>For each <code>Session</code> object, we can do a variety of things like <code>add()</code>, <code>add_all()</code>, <code>delete()</code>, <code>rollback()</code>, <code>query()</code>.  The objects are in a <strong>pending</strong> state until we issue the SQL to persist using a process known as <strong>flush</strong> (which commits the current transaction to the Database using <code>commit()</code>).</p>

<pre><code>&gt;&gt;&gt; will_user = User(name='will', fullname='Will Liu', password='stuff')
&gt;&gt;&gt; session.add(will_user)
&gt;&gt;&gt; our_user = session.query(User).filter_by(name='will').first()
&gt;&gt;&gt; our_user
&lt;User(name='will', fullname='Will Liu', password='stuff')&gt;
# SQL View
# INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
# ('will', 'Will Liu', 'stuff')
# SELECT users.id AS users_id,
#        users.name AS users_name,
#        users.fullname AS users_fullname,
#        users.password AS users_password
# FROM users
# WHERE users.name = ?
#  LIMIT ? OFFSET ?
# ('will', 1, 0)

&gt;&gt;&gt; session.add_all([
    User(name='wendy', fullname='Wendy Williams', password='test'),
    User(name='mary', fullname='Mary Contrary', password='test1'),
    User(name='fred', fullname='Fred Flinstone', password='test2')])
&gt;&gt;&gt; session.delete(will_user)
&gt;&gt;&gt; session.commit()
</code></pre>

<h3 id="a-idormobjectmanipulationorm-object-manipulationa"><a id="ormobjectmanipulation">ORM Object Manipulation</a></h3>

<p>You can get into some pretty advanced querying, filtering, iterating, and renaming of objects.</p>

<h4 id="a-idormqueryingqueryinga"><a id="ormquerying">Querying</a></h4>

<p>To get data from the Database Table, we can use the <code>query()</code> method to return a <code>Query</code> object.  We can do this a few different ways including:</p>

<pre><code># query from a class
session.query(User).filter_by(name='ed').all()

# query with multiple classes, returns tuples
session.query(User, Address).join('addresses').filter_by(name='ed').all()

# query using ORM-enabled descriptors
session.query(User.name, User.fullname).all()

# query from a mapper
user_mapper = class_mapper(User)
session.query(user_mapper)
</code></pre>

<h4 id="a-idormfilteringfiltering-with-filter-and-filterbya"><a id="ormfiltering">Filtering with filter() and filter_by()</a></h4>

<p>We can chain methods by using <code>filter()</code> to get the objects we want and <code>filter_by()</code> for specific column names (i.e. keyword arguments), though you can use <code>filter()</code> to get the same results.  Note that the reason we can use <code>==</code> is because behind the hood the equality operator is overloaded.</p>

<pre><code>session.query(User).filter_by(name='will')
session.query(User.name=='will')
session.query(User.filter(or_(User.name=='will', User.password='test1')))
</code></pre>

<p>Basically <code>filter()</code> is for <code>column==expression</code> and <code>filter_by()</code> is for <code>keyword=expression</code>.</p>

<h4 id="a-idormobjectiteratingiterating-through-query-objecta"><a id="ormobjectiterating">Iterating through Query object</a></h4>

<p>We can iterate through a <code>Query</code> object using a variety of ways.  </p>

<pre><code># We can return a list of `User` objects.
for instance in session.query(User).order_by(User.id):
    print instance.name, instance.fullname
#will Will Liu
#wendy Wendy Williams
#mary Mary Contrary
#fred Fred Flinstone

# We can return tuples using ORM-instrumented descriptors as arguments
for name, fullname in session.query(User.name, User.fullname):
    print name, fullname
#will Will Liu
#wendy Wendy Williams
#mary Mary Contrary
#fred Fred Flinstone

# We can return `KeyedTuple` class and are like a regular Python object
for row in session.query(User, User.name).all():
    print row.User, row.name
#&lt;User(name='will', fullname='Will Liu', password='stuff')&gt; will
#&lt;User(name='wendy', fullname='Will Liu', password='test1')&gt; wendy
#&lt;User(name='mary', fullname='Mary Contrary', password='test2')&gt; mary
#&lt;User(name='fred', fullname='Fred Flinstone', password='test3')&gt; fred
</code></pre>

<h4 id="a-idormnamingcontrol-names-with-aliased-and-labela"><a id="ormnaming">Control Names with aliased() and label()</a></h4>

<p>You can change the object name returned from the <code>query()</code> using <code>aliased()</code>.  You can change the individual column names using <code>label()</code></p>

<pre><code>from sqlalchemy.orm import aliased
user_alias = aliased(User, name='user_alias')

for row in session.query(user_alias, user_alias.name).all():
    print row.user_alias
#&lt;User(name='will', fullname='Will Liu', password='stuff')&gt;
#&lt;User(name='wendy', fullname='Will Liu', password='test1')&gt;
#&lt;User(name='mary', fullname='Mary Contrary', password='test2')&gt;
#&lt;User(name='fred', fullname='Fred Flinstone', password='test3')&gt;

for row in session.query(User.name.label('name_label')).all():
    print (row.name_label)
#will
#wendy
#mary
#fred
</code></pre>

<h4 id="a-idormsessioncommitstep-6---commit-a-sessiona"><a id="ormsessioncommit">Step 6 - commit a session</a></h4>

<p>Finally you want to commit your session data.  This might look like:</p>

<pre><code>import urllib
import pyodbc
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import pandas as pd

# SQLAlchemy SETUP
params = urllib.quote_plus('DRIVER={SQL Server};SERVER=&lt;mysqlserver&gt;;DATABASE=&lt;mydb&gt;;UID=&lt;myusername&gt;;PWD=&lt;mypassword&gt;')
engine = create_engine("mssql+pyodbc:///?odbc_connect=%s" % params)
Base = declarative_base()
Session = sessionmaker(bind=engine)

class LookupTable(Base):
    """
        LookupTable is the Python object that represents the Lookup Table used in the database.
    """
    __tablename__ = 'myTableName'
    myid = Column(String(50), primary_key=True)
    value = Column(String(512))

if __name__ == '__main__':
    # Setup
    Base.metadata.create_all(engine)
    session = Session()

    # Peak at the dataset
    current_table = session.query(myTableName).all()
    for row in current_table:
       print row.myid, row.value
    
    # Add some data
    test_kvpair = LookupTable(myid='Foo', value='Bar')
    session.add(test_kvpair)
    
    try:
        session.commit()
        print "Session Committed"
    except:
        print "Error with committing session"
        raise
</code></pre>

<h2 id="a-idsqlalchemypandassqlalchemy-with-pandasa"><a id="sqlalchemypandas">SQLAlchemy with Pandas</a></h2>

<p>So SQLAlchemy is great with connecting and writing to databases, but I use Pandas DataFrames for doing statistical analysis and general data cleaning.  Can we use these two together?  Yes!  Here is an example of connecting to a MS SQL Server, reading a query into a DataFrame, doing some stuff (e.g. here is an arbitrary JOIN), then write this new DataFrame back to the Database Table.  You can skip using sessions and do read and writes immediately with <code>read_sql()</code> and <code>to_sql()</code>.</p>

<pre><code>import urllib
import pyodbc
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
import pandas as pd

params = urllib.quote_plus('DRIVER={SQL Server};SERVER=&lt;nameofserver&gt;;DATABASE=&lt;nameofdb&gt;;UID=&lt;userid&gt;;PWD=&lt;pwd&gt;')
engine = create_engine("mssql+pyodbc:///?odbc_connect=%s" % params)
Base = declarative_base()

class LookupTable(Base):
    """
        LookupTable is the Python object that represents the Lookup Table used in the database.
    """
    __tablename__ = 'myTableName'

    myid = Column(String(50), primary_key=True)
    value = Column(String(512))

if __name__ == '__main__':
    
    # Setup
    Base.metadata.create_all(engine)
    pdsql = pd.io.sql.SQLDatabase(engine)
    
    # Query Database Table and return a DataFrame
    df_a = pd.read_sql("SELECT * FROM myTableName", con=engine)
    
    # Do DataFrame Stuff; here its just a simple join
    df_b = pd.DataFrame({'myid': [1, 2, 3, 4],
                         'value': ['Hello', 'World', 'Liu', 'Summers']})
    df_c = pd.merge(df_a, df_b, on='myid', how='inner')

    # Write new DataFrame back to Database Table
    df_c.to_sql(name='myTableName', if_exists='append',con=engine)
</code></pre>

</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
      <li><span>17 Oct 2015</span> <a href="/2015/10/17/django.html">Django Web Framework</a></li>
    
      <li><span>04 Oct 2015</span> <a href="/2015/10/04/testing.html">Testing</a></li>
    
      <li><span>03 Oct 2015</span> <a href="/2015/10/03/django-rest-framework.html">Django REST Framework (DRF)</a></li>
    
  </ul>
</div>

    <div class="footer">
      <div class="contact">
        <p>
          William Liu<br/>
        </p>
      </div>
      <div class="contact">
        <p>
          <a href="http://github.com/williamqliu/">github.com/williamqliu</a><br/>
        </p>
      </div>
    </div>
  </div>

  <!--
  <a href="http://github.com/williamqliu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  -->

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36019998-1', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Google Analytics end -->
</body>

</html>