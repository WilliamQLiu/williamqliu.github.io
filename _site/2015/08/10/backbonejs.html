<!DOCTYPE html>
<html>
<head>
   <title>Backbone.js</title>
   <meta name="William Liu" content="William Liu" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- LaTeX support -->
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
     MathJax.Hub.Config({
     extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
    });
   </script>

</head>

<body>
  <div class="site">
    <div class="title">
      <a href="/">William Liu</a>
    </div>

    <div id="post">
<h2 id="backbonejs">Backbone.js</h2>

<hr />

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#setup">Setup</a></li>
  <li><a href="#dependencies">Dependencies</a></li>
  <li><a href="#js">Basic Javascript</a>
    <ul>
      <li><a href="#jsorganizedata">Organize Data without Backbone</a></li>
      <li><a href="#jsorganizedatabackbone">Organize Data with Backbone</a></li>
    </ul>
  </li>
  <li><a href="#models">Models</a>
    <ul>
      <li><a href="#modelssetget"><code>set()</code> and <code>get()</code></a> </li>
      <li><a href="#modelstojson"><code>toJSON()</code></a></li>
      <li><a href="#modelsvalidate">Validating Models</a></li>
      <li><a href="#modelsid">Model id, cid, idAttribute</a></li>
    </ul>
  </li>
  <li><a href="#collections">Collections</a>
    <ul>
      <li><a href="#collectionsgetset">Collections (get, set)</a></li>
      <li><a href="#collectionsmultiple">Collections (multiple Models)</a></li>
      <li><a href="#collectionsunderscore">Collections Underscore functions</a></li>
    </ul>
  </li>
  <li><a href="#events">Events Mixin</a>
    <ul>
      <li><a href="#eventspushsub">Publish and Subscribe Pattern</a></li>
      <li><a href="#eventsformat">Events Format</a></li>
      <li><a href="#eventsontrigger"><code>on</code> and <code>trigger</code></a></li>
      <li><a href="#eventsoff"><code>off</code></a></li>
      <li><a href="#eventsonerror">Events trigger on error example</a></li>
    </ul>
  </li>
  <li><a href="#views">Views</a>
    <ul>
      <li><a href="#viewsel">el</a></li>
      <li><a href="#viewsinitialize">initialize</a></li>
      <li><a href="#viewsrender">render</a></li>
      <li><a href="#viewsevents">events</a></li>
      <li><a href="#viewstemplate">template</a></li>
    </ul>
  </li>
  <li><a href="#routes">Routes</a>
    <ul>
      <li><a href="#history">History</a></li>
    </ul>
  </li>
  <li><a href="#nonjstemplate">Non JS Template</a></li>
  <li><a href="#hwexample">Hello World Example</a>
    <ul>
      <li><a href="#hwview">1. Create View with initialize</a></li>
      <li><a href="#hwevent">2. Bind DOM events to View methods</a></li>
      <li><a href="#hwmodelcollection">3. Models and Collections</a></li>
      <li><a href="#hwmodelview">4. Delegate Model to View</a></li>
      <li><a href="#hwmodelaction">5. Create Model Actions</a></li>
    </ul>
  </li>
  <li><a href="#apiintegration">API Integration</a>
    <ul>
      <li><a href="#apimappings">API Mappings</a></li>
      <li><a href="#apijson">API JSON</a></li>
      <li><a href="#apifetch">API fetch()</a></li>
      <li><a href="#apisave">API save()</a></li>
      <li><a href="#apidestroy">API destroy()</a></li>
      <li><a href="#apioptions">API options</a></li>
    </ul>
  </li>
</ul>

<h2 id="a-idsummarysummarya"><a id="summary">Summary</a></h2>

<p><strong>Backbone.js</strong> is a JavaScript MV* for front-end web development.  It’s basically a huge step up from pulling and pushing data (e.g. pull with AJAX GET, push with WebSockets using a persistent connection between client and server) to manipulate data (where you previously would have to write the glue code that looks at the DOM, finds an element with a specific id, and update the HTML manually).  Backbone is pre-configured to sync with a RESTful API and is great for building single page applications (don’t have to wait for entire page to reload for every time we change the underlying data).</p>

<p>Note: For back-end/server stuff, Django is mainly a synchronous framework (a request goes in, we wait while the server computes stuff, then a response goes out).  If you need a persistent connection, change your back-end server to something like Tornado or Twisted (which complicates projects because of connections breaking).</p>

<p>The idea behind Backbone is that you represent your data with <strong>Models</strong>, which can be created, validated, destroyed, and saved to the server.  When a UI action causes an attribute to change, the model triggers a ‘change’ event.  The change event notifies the <strong>Views</strong> that display the model’s state and are able to respond accordingly by re-rendering themselves with the new information.</p>

<p>Backbone is a minimal way of separating business logic from user interface:</p>

<ul>
  <li>Data Structure
    <ul>
      <li>Models (orchestrates data and business logic, loads and saves from server, emits events when data changes)</li>
      <li>Collections (a group of related models)</li>
    </ul>
  </li>
  <li>User Interface
    <ul>
      <li>Views (listens for changes from events and renders UI, handles user input and interactivity, sends captured input to the model)</li>
      <li>Routing with URLs</li>
    </ul>
  </li>
</ul>

<h2 id="a-iddependenciesdependenciesa"><a id="dependencies">Dependencies</a></h2>

<p>Backbone has a fixed dependency on <strong>Underscore.js</strong> to help with filtering and sorting data.  Backbone uses <strong>jQuery</strong> for manipulating the Document Object Model (DOM).</p>

<h2 id="a-idsetupsetupa"><a id="setup">Setup</a></h2>

<p>This is my particular setup:</p>

<p><code>sudo npm install -g grunt-cli bower</code> - install global depenencies
<code>sudo npm install -g coveralls</code> - optionally install coveralls (for Travis CI)
<code>npm install</code> - to install NPM dependencies
<code>bower install</code> - to install Bower dependencies</p>

<h4 id="a-idbuildsystembuild-system-with-grunt-and-gulpa"><a id="buildsystem">Build System with Grunt and Gulp</a></h4>

<p>The build system is used to build, preview, and test your project.</p>

<h4 id="a-idpackagemanagerpackage-manager-with-bower-and-npma"><a id="packagemanager">Package Manager with Bower and npm</a></h4>

<p>The package manager is used for dependency management so you don’t have to manually download and manage your scripts.</p>

<p><strong>Bower</strong> is a way of going to GitHub or a developer’s site to download a .zip of a JavaScript tool.  You can <code>bower install [stuff]</code> and then the code is saved in a directory, usually <code>app/bower_components/</code>.  E.g. <code>bower install query</code> to install jQuery.</p>

<p>Example:</p>

<pre><code>$bower init
# For a new project; I select 'globals' for types of modules to expose and this process creates a 'bower.json' file
$bower search backbone.localstorage
&gt; Search results:  backbone.localStorage git://github.com/jeromegn/Backbone...
$bower info backbone.localStorage
$bower install backbone.localStorage --save
$bower install  # installs all dependencies listed in 'bower.json'
</code></pre>

<p>When working with multiple developers, we want to include <code>--save</code> to tell Bower to remember this new dependency.</p>

<p><strong>Grunt</strong> is a JavaScript-based task runner that runs common jobs (e.g. <code>grunt server</code>, <code>grunt build</code>, <code>grunt test</code>).  Tasks are defined in a customized <strong>Gruntfile.js</strong> file that lives in the root directory of your project.</p>

<ul>
  <li><code>grunt build</code> sucks up your js scripts, concatenates them, minifies, and prefixes them with unique hashes to prevent browsers from caching outdated versions.</li>
  <li><code>grunt server</code> compiles any CoffeeScript js files, Sass CSS styles, then connects to your server and opens up an instance, usually at <code>localhost:9000</code> in your browser</li>
</ul>

<h4 id="a-idinstallotherother-options-sass-less-requirejs-modernizer-coffeescripta"><a id="installother">Other Options (Sass, Less, RequireJS, Modernizer, CoffeeScript)</a></h4>

<p><strong>Sass</strong> (Syntactically Awesome Stylesheets) is an extension to CSS.  Sass allows CSS to have variables, support mixins (which are repeated code that you can insert into any location to make code DRY) and loops (<code>@for</code>, <code>@each</code>, and <code>@while</code>).</p>

<p><strong>Less</strong> is also another extension to CSS and like Sass, has many of the same features like variables and mixins.  Less is more like CSS than Sass.</p>

<p><strong>RequireJS</strong> is a JavaScript script loader to help improve the load time of multiple JavaScript files.  Synchronous file loading is slow and asynchronous file loading can have dependency issues.</p>

<p><strong>Modernizer</strong> runs on a web page load to detect whether certain features are available (to help support browsers that lag behind).  It lets you write conditional JavaScript and CSS code to handle each situation of whether a browser supports a feature or not.</p>

<p><strong>CoffeeScript</strong> is a language that compiles into JavaScript.</p>

<h4 id="a-idyoscaffolds-with-yoa"><a id="yo">Scaffolds with Yo</a></h4>

<p>There’s scripts out there like Yo that scaffolds out a new application, writing your build configuration (e.g. Gruntfile, Gulpfile) and pulling in the relevant build tasks and package manager dependencies (Bower, npm) that your project needs.</p>

<p>Yeoman includes the scaffolding tool (<strong>yo</strong>), the build tool (e.g. <strong>Grunt</strong>, <strong>Gulp</strong>), and the <strong>package manager</strong> (e.g. <strong>Bower</strong> and <strong>npm</strong>).</p>

<ol>
  <li>Install yo with: <code>npm install -yo</code></li>
  <li>To get some functional boilerplate Backbone app out of the box, we can do:  <code>npm install -g generator-backbone</code></li>
  <li>Make a new directory and <code>cd</code> into it: <code>mkdir myproject &amp;&amp; cd $_</code></li>
  <li>Run <code>yo backbone [app-name]</code>.  Additionally for backbone, you can:
    <ul>
      <li><code>yo backbone:collection todos</code>: create a collection for our To Do items</li>
      <li><code>yo backbone:model todo</code>: create a model for a To Do item</li>
      <li><code>yo backbone:view todo</code>: create a view for just one To Do item.</li>
      <li><code>yo backbone:router todo</code>: to create a router for your app</li>
    </ul>
  </li>
</ol>

<p>You’ll normally see a structure like:</p>

<ul>
  <li><code>app/</code> where your pure, non-compiled, non-minified source code goes</li>
  <li><code>app/scripts/</code> is where your JavaScript goes.</li>
  <li><code>app/styles/</code> is where your CSS goes</li>
  <li><code>app/index.html</code> is the non-minified version of <code>index.html</code></li>
  <li><code>Gruntfile.js</code> has all the build, server, and test tasks defined</li>
</ul>

<p>Note: I tried this out and it seemed a little too much so I installed piece by piece as needed.</p>

<h2 id="a-idjsbasic-javascripta"><a id="js">Basic JavaScript</a></h2>

<p>Here’s a brief review of JavaScript.</p>

<h4 id="a-idjsorganizedataorganizing-data-without-backbonejsa"><a id="jsorganizedata">Organizing Data (without Backbone.js)</a></h4>

<p>This is how to represent and organize data using straight JavaScript.</p>

<p><em>main.js</em></p>

<pre><code>// Setup our Person Object, have our unique attributes to the Person
var Person = function(config) {
    this.name = config.name;
    this.age = config.age;
    this.occupation = config.occupation;
};

// Common Traits/Methods for our Person Object
Person.prototype.work = function() {
    return this.name + ' is working';
}
</code></pre>

<p><em>Chrome Dev Tools</em></p>

<pre><code>var person = new Person({ name: 'Will Liu', age: 30, occupation: 'programmer'});  // undefined
person.work();  // "Will Liu is working"
</code></pre>

<h4 id="a-idjsorganizedatabackboneorganizing-data-with-backbonejsa"><a id="jsorganizedatabackbone">Organizing Data (with Backbone.js)</a></h4>

<p>Same example above, but with Backbone.js.</p>

<p><em>main.js</em></p>

<pre><code>var Person = Backbone.Model.extend({
    defaults: {
        name: 'Will Liu',
        age: 30,
        occupation: 'programmer'
    },
    work: function() {
        return this.get('name') + ' is working';
    }
});
</code></pre>

<p><em>Chrome Dev Tools</em></p>

<pre><code>var person = new Person;  // undefined
person  // returns a lot more fields including: attributes, changed, cid as well as the original __proto__
</code></pre>

<p>We get additional details like:</p>

<ul>
  <li><code>changed: Object</code> - determines if object was changed</li>
  <li><code>__proto__ : Object</code> - we still have access to our original prototype.</li>
  <li><code>attributes: Object</code>  - attributes (what would have been in <em>prototype</em>).  In order to access these attributes, we now need to use <code>.get()</code> and <code>.set()</code></li>
</ul>

<h2 id="a-idmodelsmodelsa"><a id="models">Models</a></h2>

<p>Models contain interactive data and logic such as getters, setters, data initialization, and data validation.  Properties are dynamic (can be created on the spot) and don’t have a specific type associated with it.</p>

<pre><code>var app = {};  // Create namespace for our app

app.Todo = Backbone.Model.extend({
  defaults: {
      title: '',
      completed: false
  }
});
</code></pre>

<p>To test Models in Chrome, you can go to the Console and do:</p>

<ol>
  <li><code>var todo = new app.Todo({title: 'Learn Backbone.js', completed: false});</code></li>
  <li><code>todo.get('title');</code> returns <code>"Learn Backbone.js"</code></li>
  <li><code>todo.set('created_at', Date());</code> create a new object</li>
  <li><code>todo.get('created_at')</code> returns ‘Tue Aug 11 2015’</li>
</ol>

<h4 id="a-idmodelssetgetmodels-set-and-geta"><a id="modelssetget">Models (<code>set()</code> and <code>get()</code>)</a></h4>

<p>Instead of modifying the Model attributes directly, make sure to use Backbone’s <code>set()</code> and <code>get()</code>.  If you’re setting one attribute, you can just pass in the value.  If you’re setting more than one attribute, pass in the object (i.e. <code>{}</code>).  Note: <code>set()</code> updates the DOM while triggering the ‘change’ event while <code>save()</code> updates the Database.</p>

<pre><code>person.get('occupation');  // "programmer"
person.set('occupation': 'developer');  // setting single attribute
person.set({name:'Laura Summers', occupation: 'designer'});  // setting multiple attributes
</code></pre>

<p>What really goes on behind the scenes is that when you do something like a set or get, you’re sending data through a ‘request payload’ (that you can see in the Chrome Tools under &gt; Network to see the most recent requests); this ‘request payload’ takes and stringifies our JSON data.</p>

<h4 id="a-idmodelstojsonmodels-tojsona"><a id="modelstojson">Models (<code>toJSON()</code>)</a></h4>

<p>We can take our Model objects and call <code>toJSON()</code>, which will return a JavaScript object.</p>

<pre><code> person.toJSON();  // returns Object with attributes (age, name, occupation) and __proto__
</code></pre>

<h4 id="a-idmodelsvalidatemodels-validatea"><a id="modelsvalidate">Models (validate)</a></h4>

<p>Backbone has model validation using <code>model.validate()</code>, which checks the attribute values before setting them.  By default, this occurs during a <code>save()</code> method or when <code>set()</code> is called if <code>{validate: true}</code> is passed as an argument.</p>

<pre><code>var Person = new Backbone.Model({name: 'Will'});

// Validate the model name
Person.validate = function(attrs) {
  if (attrs.age &lt;0) {
    return 'Age must be positive';
  }

  if (!attrs.name) {
    return 'Everyone needs a name';
  }
};

// Change the name
Person.set({name: 'Laura'});
console.log(Person.get('name'));  // 'Laura'

// Remove the name attribute, force validation
Person.unset('name', {validate: true});  // false
</code></pre>

<h4 id="a-idmodelsidmodels-id-cid-idattributea"><a id="modelsid">Models (id, cid, idAttribute)</a></h4>

<p>When you exchange data between the client and the server, you need a way to uniquely identify models.  In Backbone, we have the <code>id</code>, <code>cid</code>, and <code>idAttribute</code> properties.</p>

<ul>
  <li>Each model has an <code>id</code>, a unique identifier that is either an integer or a string (e.g. a UUID).</li>
  <li>Each model also has a client id <code>cid</code>, which is automatically generated by Backbone when the model is created.</li>
  <li>You can use either the <code>id</code> or the <code>cid</code> to retrieve a model from a collection.  The difference is that the <code>cid</code> is generated by Backbone, which is helpful when you don’t have a true id yet (e.g. if your model hasn’t been saved to the server or you aren’t saving it to a database).</li>
  <li>The <code>idAttribute</code> is the id from the server (i.e. the <code>id</code> in your database).  This is like a mapper.  By default, it assumes <code>id</code>.</li>
</ul>

<h2 id="a-ideventsevents-an-object-mixina"><a id="events">Events (an object mixin)</a></h2>

<p>Events is an object mixin (like a class mixin) that you can use to listen for well… events across the other Backbone objects like Model, Collection, Router, History, and View.  So how does <code>Backbone.Events</code> give any object the ability to bind and trigger custom events?</p>

<ol>
  <li>What normally happens is you have a function that calls another function by name.  The programmer controls the events; the first function runs then the second function.</li>
  <li>However, Events works by replacing the first function with an event handler (i.e. a specific function that looks for a specific event to occur) that when triggered, runs the second function.</li>
</ol>

<p>Events have a few methods we’re interested in like <code>on</code>, <code>off</code>, and <code>trigger</code> (similar to jQuery).  <code>on</code> has the format <code>object.on(event, callback, [context])</code>, which means to bind an object to an event and a callback.  When that event is triggered, it executes the callback.  E.g. <code>todoList.on('add', this.addAll, this);</code> would mean everytime a new item is ‘add’ed to the Backbone.Collection, the event ‘add’ is triggered.  You can add events to Collections, Views, etc.</p>

<p>So how does this work in practice?  Imagine that you update your Model’s data, but the data isn’t updated on your screen.  With Events, you can easily setup an event to look for changes on the Model’s data and if there is a change, run a function to rerender the View.  Now the user sees data changes immediately on their screen.</p>

<h4 id="a-ideventspushsubevents-publishsubscribe-patterna"><a id="eventspushsub">Events (Publish/Subscribe Pattern)</a></h4>

<p>Events follow the publisher/subscriber behavior where publishers (aka senders/messages) do not sent messages directly to specific subscribers (aka receivers) and instead are sent to a message-oriented middleware system.  More specifically, events follow the <strong>observer pattern</strong> where an object (the subject) has a list of dependents called observers that are notified automatically of any state changes (usually by calling one of their methods).</p>

<h4 id="a-ideventsformatevents-formata"><a id="eventsformat">Events (Format)</a></h4>

<p>Events have the following format.</p>

<pre><code>//{"&lt;EVENT_TYPE&gt; &lt;ELEMENT_ID&gt;": "&lt;CALLBACK_FUNCTION&gt;"}
//e.g. events: {'keypress #new-todo': 'createTodoOnEnter'}
// The jQuery equivalent would be `$('#new-todo').keypress(createTodoOnEnter);`

App.Views.Advice = Backbone.View.extend({
    events: {
        'click': 'showAlert'
    },
    showAlert: function() {
        alsert('you clicked me!');
    }
});
</code></pre>

<h4 id="a-ideventsformatevents-custom-eventsa"><a id="eventsformat">Events (Custom Events)</a></h4>

<p>Events can also have a simpler format and allows custom event triggers with: <code>object.on({click: action})</code>.  We can trigger on any event (e.g. on Model’s data changing) or a specific event (e.g. on change of a specific field in the Model’s data).</p>

<pre><code>var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

var myTodo = new Todo();
myTodo.set({title: 'Buy some cookies', completed:true});

// Run custom function if change on specific fields
myTodo.on({
  'change:title': titleChanged,
  'change:completed': stateChanged
});

function titleChanged(){
  console.log('Title changed!');
}

function stateChanged(){
  console.log('State changed!');
}

myTodo.set({title: 'Get the groceries!'});  // Title changed!
</code></pre>

<p>The general format is:</p>

<pre><code>object.on("change: something", function(stuff){ 
  console.log("Stuff");
});`
</code></pre>

<h4 id="a-ideventsontriggerevents-as-a-mixin-using-on-and-triggera"><a id="eventsontrigger">Events as a Mixin using <code>on</code> and <code>trigger</code></a></h4>

<p>Let’s get into more detail with how <code>on</code> and <code>trigger</code> can be used for custom events.</p>

<pre><code>var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

// Add a custom event
ourObject.on('dance', function(msg){
  console.log('We triggered ' + msg);
});

// Trigger the custom event
ourObject.trigger('dance', 'ourevent');
</code></pre>

<p>The <code>on</code> is similar to the <strong>subscribe</strong> and <code>trigger</code> is similar to <strong>publish</strong> in a Publish/Subscribe pattern.  <code>on</code> binds a callback function to an object ‘dance’.  The callback is invoked whenever the event is triggered.  If you do a lot of events, consider namespacing the events.  If there is no listener for a trigger (e.g. <code>object.trigger("jump", "jump.  Yeah!"</code>, then nothing happens.</p>

<pre><code>var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function dancing(msg) {
  console.log("We started " + msg);
}

// Add namespaced custom events
ourObject.on("dance:tap", dancing);
ourObject.on("dance:break", dancing);

// Trigger the custom events individually
ourObject.trigger("dance:tap", "tap dancing. Yeahhh!");
ourObject.trigger("dance:break", "break dancing.  Woottt!");
</code></pre>

<p>Instead of a single event, we can also trigger multiple events / pass multiple arguments to the callback function.</p>

<pre><code>// Trigger multiple events
ourObject.trigger("dance:tap dance:break", " dancing!");
</code></pre>

<h4 id="a-ideventsonerrorevents---on-error-examplea"><a id="eventsonerror">Events - on error example</a></h4>

<p>A common example is listening for a triggered event on error:</p>

<pre><code> person.on('error', function(model, error) {
    console.log(error);
});
</code></pre>

<h4 id="a-ideventsallevents-as-a-mixin-using-alla"><a id="eventsall">Events as a Mixin using <code>all</code></a></h4>

<p>The event <code>all</code> creates notifications for every event that occurs on the object.</p>

<pre><code>var ourObject = {};

// Mixin
_.extend(ourObject, Backbone.Events);

function dancing(msg){
  console.log("We started " + msg);
}

ourObject.on("all", function(eventName){
  console.log("The name of the event passed was " + eventName);
});

// Each event will be caught with a catch 'all' event listener
ourObject.trigger("dance:tap", "tap dancing.  Yeahhh!");
ourObject.trigger("dance:break", "break dancing.  Woottt!");
</code></pre>

<h4 id="a-ideventsoffevents-as-a-mixin-using-offa"><a id="eventsoff">Events as a Mixin using <code>off</code></a></h4>

<p><code>off</code> removes callback functions that were previously bound to an object.  In a Publish/Subscribe pattern, <code>off</code> is similar to <strong>unsubscribe</strong>.  We can remove specific callbacks to an event or we can remove all callbacks for the event.</p>

<pre><code>// Removes a single event bound to the object
ourObject.off("dance:tap");
</code></pre>

<p>Every <code>on</code> should have an <code>off</code> or else we’ll have memory leaks.  You should use <code>on</code>/<code>off</code> on views and their corresponding models at the same time, otherwise if you remove a view that you registered to be notified about events on a model, but don’t remove the model or call <code>off</code> to remove the view’s event handler, the view’s callback function can’t be collected by JavaScript’s garbage collector.</p>

<h4 id="a-ideventsoffevents-using-listento-and-stoplisteninga"><a id="eventsoff">Events using <code>listenTo()</code> and <code>stopListening()</code></a></h4>

<p>We can either have every <code>on</code> called on an object to also have an <code>off</code> called, or we can use <code>listenTo()</code>, which allows Views to bind to Model notifications and unbind from all of them with just one call <code>stopListening()</code>.  The default <code>View.remove()</code> makes a call to <code>stopListening()</code> to ensure that any listeners bound are unbound before the view is destroyed.</p>

<pre><code>var view = new Backbone.View();
var b = _.extend({}, Backbone.Events);

view.listenTo(b, 'all', function(){
  console.log(true);
});
b.trigger('anything');  // logs: true

view.listenTo(b, 'all', function(){
  console.log(false);
});
view.remove();  // 'stopListening()' implicitly called by 'remove()'
b.trigger('anything');  // does not log anything since trigger has been removed
</code></pre>

<h4 id="a-ideventsviewsevents-binding-to-viewsa"><a id="eventsviews">Events binding to Views</a></h4>

<p>Events bind to views a little differently; see the Views - Events section.</p>

<h2 id="a-idviewsviews-overviewa"><a id="views">Views (Overview)</a></h2>

<p>Views are the user interface and tells us how data is displayed.  Backbone views are generally based on View Templates.  While rendering the UI, Views also listen to the events from the DOM.  Views have four basic properties (with an optional fifth ‘template’):</p>

<ol>
  <li><code>el</code></li>
  <li><code>initialize</code></li>
  <li><code>render</code></li>
  <li><code>events</code></li>
  <li><code>template</code></li>
</ol>

<h4 id="a-idviewselviews-ela"><a id="viewsel">Views (el)</a></h4>

<p>The el property stands for element and is the reference to the DOM.  Every view has an element associated with it where the view will inject content in.  <code>el</code> tells you how to inject the content.  Without Backbone, you would manually write out the HTML string in your Javascript, which is a code smell.  Backbone’s <code>el</code> will allow you to do this cleanly.</p>

<p>A few things to note:</p>

<ul>
  <li>A view has the following properties:
    <ul>
      <li><code>el</code> - where you want to start inserting your HTML; <code>this.el</code> is created from the view’s <code>el</code>.  You use ‘el’ or ‘tagName’</li>
      <li><code>tagName</code> - can specify your HTML’s wrapper; default is a <code>&lt;div&gt;</code> wrapper.  You use ‘el’ or ‘tagName’.</li>
      <li><code>className</code> - can specify your HTML’s class</li>
      <li><code>id</code> - can specify your HTML’s id</li>
      <li><code>attributes</code></li>
      <li>If none of the above are specified, then it is an empty <code>div</code>.</li>
    </ul>
  </li>
  <li><code>view.$el</code> is the cached jQuery object of the view’s element (<code>view.el</code>)</li>
</ul>

<p><strong>Example 1 - view with default values</strong></p>

<p>We create a simple view, which defaults <code>el</code> to a <code>&lt;div&gt;</code>.</p>

<p><em>main.js</em></p>

<pre><code>var Person = Backbone.Model.extend({
    defaults: {
        name: 'Will Liu',
        age: 30,
        occupation: 'programmer'
    }
});

var PersonView = Backbone.View.extend({
});
var personView = new PersonView;
</code></pre>

<p><em>Chrome Dev Tool</em></p>

<pre><code>&gt;personView.el  // this element
 &lt;div&gt;&lt;/div&gt;
&gt;personView.$el  // this element wrapped in jQuery
 [&lt;div&gt;&lt;/div&gt;]
</code></pre>

<p><strong>Example 2 - view with different tagName, className, and id</strong></p>

<p><em>main.js</em></p>

<p>You can specify your own tagName (i.e. instead of a <code>&lt;div&gt;</code>), className</p>

<pre><code>var PersonView = Backbone.View.extend({
    tagName: 'li',
    className: 'myperson',
    id: 'myid'
});
</code></pre>

<p><em>Chrome Dev Tool</em></p>

<pre><code>&gt;var personView = new PersonView();
&gt;personView.$el
[&lt;li id="myid" class="myperson"&gt;&lt;/li&gt;]
</code></pre>

<h4 id="a-idviewsinitializeviews-initializea"><a id="viewsinitialize">Views (initialize)</a></h4>

<p><code>initialize</code> - the first function (automatically called) when a view is instantiated.  You can pass parameters that will be attached to a model, collection or <code>view.el</code></p>

<pre><code>var PersonView = Backbone.View.extend({
    initialize: function() {
        console.log('hi there, I initialized');
    }
})
</code></pre>

<h4 id="a-idviewsrenderviews-rendera"><a id="viewsrender">Views (render)</a></h4>

<p><code>render</code> - this function injects the markup into the elements.  This is not required; some views can call other view’s render function.</p>

<pre><code>var PersonView = Backbone.View.extend({
    tagName: 'li',    

    initialize: function() {
        console.log('hi there, I initialized');
        this.render();  // You can render immediately
    }
    render: function() {
        this.$el.html(this.model.get('name'));  // the jQuery wrapped item
    }
});

var person = new Person;  // Create the Model
var personView = new PersonView({model: person})  // Create the View, pass in the Model
</code></pre>

<h4 id="a-idviewseventsviews-events-mixina"><a id="viewsevents">Views (events mixin)</a></h4>

<p>Events bind to Views a little different; in Views there’s two types of events you can listen for and depending on the type, <code>this</code> points to different things.  The two types of events you can listen for are:</p>

<ol>
  <li>DOM events</li>
  <li>Events triggered using the Event API</li>
</ol>

<p><strong>Dom events</strong> can be bound using the View’s <code>events</code> property or using <code>jQuery.on()</code>.</p>

<ul>
  <li>If the event is bound using the <code>events</code> property, then <code>this</code> refers to the View object</li>
  <li>If the event is bound using jQuery, then <code>this</code> is set to the handling DOM element by jQuery.</li>
</ul>

<p>All Dom event callbacks are passed as an <code>event</code> object by jQuery.</p>

<p><strong>Event API</strong> events can be bound using <code>on()</code> on the observed object with a context parameter passed as the third parameter or with <code>listenTo()</code>.</p>

<ul>
  <li>If the event is bound using <code>on()</code> on the object, then a context parameter is passed as the third argument.</li>
  <li>If the event is bound using <code>listenTo()</code> then within the callback <code>this</code> refers to the listener.  The arguments passed to Event API callbacks depends on the type of event (see Catalog of Events in the Backbonejs documentation).</li>
</ul>

<p>For example:</p>

<pre><code>&lt;div id="todo"&gt;
  &lt;input type='checkbox'/&gt;
&lt;/div&gt;

var View = Backbone.View.extend({
  el: '#todo',

  // bind to DOM event using the `events` property
  events: {
    'click [type="checkbox"]': 'clicked',
  },
  initialize: function() {
    // bind to DOM event using jQuery
    this.$el.click(this.jqueryClicked);
    
    // bind to an Event API
    this.on('apiEvent', this.callback);        
  },
  
  // 'this' is view
  clicked: function(event) {
    console.log("events handled for " + this.el.outerHTML);
    this.trigger('apiEvent', event.type);
  },
  
  // 'this' is handling a DOM element
  jQueryClicked: function(event) {
    console.log("jQuery handler for " + this.outerHTML);
  },
  
  callback: function(eventType) {
    console.log("event type was " + eventType);
  }
});
var view = new View();
</code></pre>

<h4 id="a-idviewstemplateviews-templatea"><a id="viewstemplate">Views (template)</a></h4>

<p>Instead of rendering HTML manually in our View’s <code>render</code> function, you can use templates.  Templates can have different types including the default Underscore (<code>_</code>) to Mustache.</p>

<p><code>template</code> - _.js templates have the following format: <code>_.template(templateString, [data], [settings])</code> where in <code>templateString</code> you can use the placeholders to dynamically insert data:
*  <code>&lt;%= %&gt;</code> (allows for HTML escape)
*  <code>&lt;%- %&gt;</code> (does not allow for HTML escape)
*  <code>&lt;% %&gt;</code> runs any javascript code</p>

<h4 id="a-idviewsinlinetemplateviews-inline-templatea"><a id="viewsinlinetemplate">Views (inline template)</a></h4>

<p>You can do an inline template.  The View is rendered , we wrap the <code>el</code> tags (<code>li</code>) to html, and then use an inline template.</p>

<p><em>main.js</em></p>

<pre><code>var AdviceModel = Backbone.Model.extend({
    defaults: {
        skills: [],
        title: "default_title",
        location: "New York, NY",
        img: null,
        is_active: true,
        q_who_what: "who and what",
        q_avg_day: "avg day",
        q_like_dislike: "like dislike",
        q_advice_new: "advice new",
        q_big_accomplish: "big accomplish",
        flagged: 0
    },
});

var AdviceView = Backbone.View.extend({
    tagName: 'li',
    template: _.template("&lt;%= q_who_what %&gt; at &lt;%= location %&gt;"),

    initialize: function() {
        console.log('View is getting initialized');
        console.log("Model is ", this.model);
        this.render();
    },

    render: function() {
        console.log('Rendering View');
        //this.$el.html( this.model.get('title'));  // get the model's  attribute title
        console.log("Model in JSON is ", this.model.toJSON());
        this.$el.html( this.template( this.model.toJSON()));
    }
});

var advice = new AdviceModel;
var adviceView = new AdviceView({model: advice});
//This renders in Chrome: 'who and what at New York, NY'
</code></pre>

<h4 id="a-idviewsexternaltemplateviews-external-templatea"><a id="viewsexternaltemplate">Views (external template)</a></h4>

<p>We can place our template into an external script.</p>

<p><em>template.html</em></p>

<pre><code>&lt;!-- Our External Template --&gt;
&lt;script id="adviceTemplate" type="text/template"&gt;
    &lt;%= q_who_what %&gt; at &lt;%= location %&gt;
&lt;/script&gt;
</code></pre>

<p><em>main.js</em></p>

<pre><code>var AdviceModel = Backbone.Model.extend({
        defaults: {
            skills: [],
            title: "default_title",
            location: "New York, NY",
            img: null,
            is_active: true,
            q_who_what: "who and what",
            q_avg_day: "avg day",
            q_like_dislike: "like dislike",
            q_advice_new: "advice new",
            q_big_accomplish: "big accomplish",
            flagged: 0
        },
    });

var AdviceView = Backbone.View.extend({
    tagName: 'li',
    template: _.template( $('#adviceTemplate').html() ),

    initialize: function() {
        console.log('View is getting initialized');
        console.log("Model is ", this.model);
        this.render();
    },

    render: function() {
        console.log('Rendering View');
        //this.$el.html( this.model.get('title'));  // get the model's  attribute title
        console.log("Model in JSON is ", this.model.toJSON());
        this.$el.html( this.template( this.model.toJSON()));
    }
});

var advice = new AdviceModel;
var adviceView = new AdviceView({model: advice});
//This renders in Chrome: 'who and what at New York, NY'
</code></pre>

<h2 id="a-idcollectionscollectionsa"><a id="collections">Collections</a></h2>

<p>Collections are ordered sets of models.  You can get and set models in the collection, listen for events when any element in the collection changes, and fetch data from the server and save the model’s data to the database.  Collections require a reference, usually a <strong>url</strong> parameter where the model’s resource is located on the server (e.g. on an API).  If you want to work with local files, you can use the backbone.localStorage-min.js file.</p>

<pre><code>app.TodoList = Backbone.Collection.extend({
  model: app.Todo,
  //localStorage: new Store("backbone-todo")
});
app.todoList = new app.TodoList();  // instance of the Collection
</code></pre>

<p>To test Collections in Chrome, you can go to the Console and do:</p>

<ol>
  <li><code>var todoList = new app.TodoList()</code></li>
  <li><code>todoList.create({title: 'Learn Backbone\s Collection'});</code></li>
  <li><code>var lmodel = new app.Todo({title: 'Learn Models', completed: true});</code></li>
  <li><code>todoList.add(lmodel);</code></li>
  <li><code>todoList.pluck('title');</code>  // [“Learn Backbone’s Collection”, “Learn Models”]</li>
  <li><code>todoList.pluck('completed');</code>  // [false, true]</li>
  <li><code>JSON.stringify(todoList);</code>  // “[{“title”:”Learn Backbone’s Collection”, “completed”:false”}…, {“title”:”Learn Models”…}]”</li>
</ol>

<h4 id="a-idcollectionsnobackbonecollections-trying-with-pure-javascripta"><a id="collectionsnobackbone">Collections (trying with pure JavaScript)</a></h4>

<p>To really get an idea behind what Collections do, let’s think about what we would do without them.  We now create multiple models and multiple views.</p>

<pre><code>var person = new Person;
var personView = new PersonView({model: person});

var person2 = new Person({name: 'Will Liu', age: 30});
var personView2 = new PersonView({model: person2});

// This gets messy quick
var people = [personView, personView2]  // creates an array of people, but we don't have helpful events like add, delete
</code></pre>

<p>We’re really missing out on helper functions like add, delete, sync.</p>

<h4 id="a-idcollectionstojsoncollections-trying-with-backbonejsa"><a id="collectionstojson">Collections (trying with Backbone.js)</a></h4>

<p>Now let’s try this with Backbone.js’ Collections.</p>

<p><em>Adding in Models to Collections</em></p>

<pre><code>var person = new Person;
var person2 = new Person({name: 'Will Liu', age: 30});

var PeopleCollection = Backbone.Collection.extend({
    model: Person  // reference the Model instead of the instance
});

var peopleCollection = new PeopleCollection;
peopleCollection.add(person);
console.log(peopleCollection);  // now length is 1, the model is contained in the 'models' attribute
</code></pre>

<p><em>Adding in individual objects (that represent the Models) to Collections</em></p>

<pre><code>var peopleCollection = new PeopleCollection([
  {
    name: 'Will Liu',
    age: 30,
    occupation: 'programmer'
  },
  {
    name: 'Laura Summers',
    age: 27,
    occupation: 'designer'
  }
]);
</code></pre>

<p>Backbone understands that these items passed are actually Models since we declared this in our initial Collections.</p>

<h4 id="a-idcollectionsgetsetcollections-get-seta"><a id="collectionsgetset">Collections (<code>get()</code>, <code>set()</code>)</a></h4>

<p>By default, the Models stored inside Collections are enumerated (i.e. ordered) by their <code>id</code> property.  To get a specific model, you can use <code>collection.get(id)</code>, which will check the array for the existence of the model with the right <code>id</code>.  You can also try to reference a model with the <code>cid</code> or <code>idAttribute</code>.  This also applies to <code>collection.set(id)</code></p>

<h4 id="a-idcollectionstojsoncollections-tojsona"><a id="collectionstojson">Collections (<code>toJSON()</code>)</a></h4>

<pre><code>var PeopleCollection = Backbone.Collection.extend({
    model: People,
});

var peopleCollection = new PeopleCollection;
console.log(peopleCollection);
peopleCollection.toJSON();  // returns an array of our models
</code></pre>

<h4 id="a-idcollectionsmultiplecollections-multiple-modelsa"><a id="collectionsmultiple">Collections (multiple Models)</a></h4>

<p>You can do the standard <code>collection.get()</code>, <code>collection.set()</code>, <code>collection.reset()</code> to affect the entire Collection instead of just a Model at a time.</p>

<h4 id="a-idcollectionsunderscorecollections-underscore-functions-foreach-sortby-map-chainas"><a id="collectionsunderscore">Collections Underscore functions (forEach, sortBy(), map(), chain())</a>s</h4>

<p>Since Backbone has a hard dependency on Underscore, you can use Underscore’s utility functions directly on collections.  These include:</p>

<ul>
  <li><code>forEach</code>: iterate over collections</li>
  <li><code>sortBy()</code>: sort a collection on a specific attribute</li>
  <li><code>map()</code>: iterate through a collection, map each value</li>
  <li><code>min()/max()</code>: retrieve an item with min or max value of an attribute</li>
  <li><code>filter()</code>: filter a collection (e.g. contains these ids)</li>
  <li><code>indexOf()</code>: return index of a particular item within a collection</li>
  <li><code>any()</code>: confirm if any of the values in a collection pass an iterator truth test</li>
  <li><code>size</code>: return size of a collection</li>
  <li><code>isEmpty()</code>: determines if a collection is empty</li>
  <li><code>keys()/values()</code>: gets a list of attribute names/keys and values</li>
</ul>

<p>You can also use Underscore’s <code>chain()</code> method to chain multiple methods (e.g. if you want to filter by age and map what is returned to another list)</p>

<h2 id="a-idroutesroutesa"><a id="routes">Routes</a></h2>

<p>Routes reference a certain ‘state’ of the web application in the URL.  Routes are hash maps that match URL patterns to functions.  You can use parameter parts such as <code>todo/:id</code> or splats <code>file/*path</code> to match all the parameters from the splat on (make sure to make splat parameters last since they’re greedy).  Remember that this navigates to a <code>#</code> location (e.g. a route to “about” leads to a url of “#about”). </p>

<pre><code>// Example Route:  http://example.com/$search/hotels/page1

var TodoRouter = Backbone.Router.extend({
  // define the route and funtion maps for this router
  routes: {
    "": "index",
    "about" : "showAbout",  // E.g. http://example.com/#about
    "todo/:id" : "getTodo",  // Using a ':param' variable; E.g. http://example.com/#todo/5
    "todos/*documentPath" : "downloadDocument", // Using a '*splat'; E.g. http://example.com/#todos/Meeting_schedule.doc
    "*other" : "defaultRoute",
  },

  index: function() {
    console.log("Hi, this is the index page");
  },      
  showAbout: function(){
    console.log("This is the showAbout page");
  },    
  getTodo: function(id){
    console.log("You reached todo item " + id);
  },    
  downloadDocument: function(id, path){
  },    
  defaultRoute: function(other){
    console.log("Invalid, you attempted to reach:" + other);
  }
});
</code></pre>

<h4 id="a-idrouteseventtriggersroutes-with-custom-event-triggersa"><a id="routeseventtriggers">Routes with Custom Event Triggers</a></h4>

<p>You route with a custom event trigger.</p>

<pre><code>var vent = _.extend({}, Backbone.Events);

App.Views.Appointment = Backbone.View.extend({
    initialize: function() {
        vent.on('appointment:show', this.show, this);
    },
    show: function(id) {
        console.log('Showing the appointment ' + id);
    }
});

App.Router = Backbone.Router.extend({
    routes: {
        '': 'index',
        'appointment/:id': 'showAppointment'
    },
    index: function() {
        console.log('hi, this is the index page');
    },
    showAppointment: function(appointmentId) {
        vent.trigger('appointment:show', appointmentId);
    }
});

new App.Views.Appointment;

new App.Router;
Backbone.history.start();    
</code></pre>

<p>The route matches with the url, which then triggers the appointment event.  The event calls the function ‘show’ which shows the appointment data (model or collection).</p>

<h4 id="a-idhistoryhistorya"><a id="history">History</a></h4>

<p>Backbone.history handles <code>hashchange</code> events in our application; this automatically handles routes that have been defined and trigger callbacks when they’ve been accessed.  Place this right after your Routes initialization.</p>

<pre><code>Backbone.history.start();
</code></pre>

<h2 id="a-idnonjstemplatenon-javascript-part-of-templatea"><a id="nonjstemplate">Non-Javascript part of Template</a></h2>

<p>The non-js part of our template.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;title-backbonejs&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script src="http://ajax.cdnjs.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"&gt;&lt;/script&gt;
  &lt;script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.2.1/backbone-min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    //Put Backbone.js stuff here or link to src
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="a-idhwexamplehello-world-examplea"><a id="hwexample">Hello World Example</a></h2>

<h4 id="a-idhwviewdeclaration-and-instantiation-of-a-minimalist-view-with-initialize-and-rendera"><a id="hwview">Declaration and Instantiation of a minimalist View with <code>initialize</code> and <code>render</code></a></h4>

<p>Upon instantiation, we automatically call <code>initialize()</code>.  This handles all bindings except for UI events like clicks.  We then <code>render()</code> the view, in this case inside an existing element.</p>

<pre><code>(function($){  // creates a self-executing wrapper
  var ListView = Backbone.View.extend({  // our main app's view
    el: $('body'),  // attaches 'this.el' to an existing element
    
    initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
      _.bindAll(this, 'render'); // fixes loss of context for 'this' within methods

      this.render();  // not all views are self-rendering; this one is
    },

    render: function(){  // function to render the entire view in 'this.el'
      $(this.el).append("&lt;ul&gt; &lt;li&gt;hello world&lt;/li&gt; &lt;/ul&gt;");
    }
  });
  
  var listView = new ListView();  // instantiate main app view
})(jQuery);
</code></pre>

<h4 id="a-idhweventbinding-of-dom-events-to-view-methods-with-eventsa"><a id="hwevent">Binding of DOM events to View methods with <code>events</code></a></h4>

<p>Views act like Controllers in a MVC and are used to bind DOM events to View methods.  Under ‘events’, you can see that we have a ‘click’ that triggers the custom ‘addItem’ function.</p>

<pre><code>(function($){  // creates a self-executing wrapper
  var ListView = Backbone.View.extend({  // our main app's view
    el: $('body'),  // attaches 'this.el' to an existing element

    events: {
        'click button#add': 'addItem'
    },
    
    initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
      _.bindAll(this, 'render', 'addItem'); // every function that uses 'this' as the current object should be here

      this.counter = 0;  // total number of items added so far
      this.render();  // not all views are self-rendering; this one is
    },

    render: function(){
      $(this.el).append("&lt;button id='add'&gt;Add list item&lt;/button&gt;");
      $(this.el).append("&lt;ul&gt;&lt;/ul&gt;");
    },

    addItem: function(){
        this.counter++;
        $('ul', this.el).append("&lt;li&gt;hello world"+this.counter+"&lt;/li&gt;");
    }    
  });
  
  var listView = new ListView();  // instantiate main app view
})(jQuery);
</code></pre>

<h2 id="a-idmodelsmodels-and-collectionsa"><a id="models">Models and Collections</a></h2>

<p>A Model is a JavaScript object (i.e. key-value pairs) with some helper functions to handle things like event triggering, persistence.  A Collection is a group of Models.</p>

<h4 id="a-idhwmodelcollectionhow-to-use-a-collection-of-models-to-store-data-and-tie-changes-to-a-viewa"><a id="hwmodelcollection">How to use a Collection of Models to store data and tie changes to a View</a></h4>

<pre><code>(function($){  // creates a self-executing wrapper

  var Item = Backbone.Model.extend({
    defaults: {
        part1: 'hello',
        part2: 'world'
    }
  });
  
  var List = Backbone.Collection.extend({
    model: Item
  });

  var ListView = Backbone.View.extend({  // our main app's view
    el: $('body'),  // attaches 'this.el' to an existing element

    events: {
        'click button#add': 'addItem'
    },
    
    initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
      _.bindAll(this, 'render', 'addItem', 'appendItem'); // every function that uses 'this' as the current object should be here

      this.collection = new List();
      this.collection.bind('add', this.appendItem);  // collection event binder

      this.counter = 0;  // total number of items added so far
      this.render();  // not all views are self-rendering; this one is
    },

    render: function(){
      var self = this;  // save reference to 'this' so it can be accessed from within the scope of the callback
      $(this.el).append("&lt;button id='add'&gt;Add list item&lt;/button&gt;");
      $(this.el).append("&lt;ul&gt;&lt;/ul&gt;");
      _(this.collection.models).each(function(item){
        // in case collection is not empty
        self.appendItem(item);
      }, this);
    },

    // addItem now works with just the models/collections
    addItem: function(){
      this.counter++;
      var item = new Item();
      item.set({
        part2: item.get('part2') + this.counter  // modify item defaults
      });
      this.collection.add(item);  // add item to collection; view is updated via event 'add'
    },
    
    appendItem: function(item){
      $('ul', this.el).append("&lt;li&gt;"+item.get('part1')+" "+item.get('part2')+"&lt;/li&gt;");
    }

  });
  
  var listView = new ListView();  // instantiate main app view
})(jQuery);
</code></pre>

<h4 id="a-idhwmodelviewdelegate-rendering-of-a-model-to-a-dedicated-viewa"><a id="hwmodelview">Delegate rendering of a Model to a dedicated View</a></h4>

<pre><code>(function($){  // creates a self-executing wrapper

  var Item = Backbone.Model.extend({
    defaults: {
        part1: 'hello',
        part2: 'world'
    }
  });
  
  var List = Backbone.Collection.extend({
    model: Item
  });

  var ItemView = Backbone.View.extend({
    tagName: 'li', // name of (orphan) root tag in 'this.el'
    initialize: function(){
      _.bindAll(this, 'render');  // every function that uses 'this' as the current object should be here
    },

    render: function(){
      $(this.el).html('&lt;span&gt;'+this.model.get('part1')+' '+this.model.get('part2')+'&lt;/span&gt;');
      return this;  // for chainable calls, like .render().el 
    }
  });

  var ListView = Backbone.View.extend({  // our main app's view
    el: $('body'),  // attaches 'this.el' to an existing element

    events: {
        'click button#add': 'addItem'
    },
    
    initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
      _.bindAll(this, 'render', 'addItem', 'appendItem'); // every function that uses 'this' as the current object should be here

      this.collection = new List();
      this.collection.bind('add', this.appendItem);  // collection event binder

      this.counter = 0;  // total number of items added so far
      this.render();  // not all views are self-rendering; this one is
    },

    render: function(){
      var self = this;  // save reference to 'this' so it can be accessed from within the scope of the callback
      $(this.el).append("&lt;button id='add'&gt;Add list item&lt;/button&gt;");
      $(this.el).append("&lt;ul&gt;&lt;/ul&gt;");
      _(this.collection.models).each(function(item){
        // in case collection is not empty
        self.appendItem(item);
      }, this);
    },

    // addItem now works with just the models/collections
    addItem: function(){
      this.counter++;
      var item = new Item();
      item.set({
        part2: item.get('part2') + this.counter  // modify item defaults
      });
      this.collection.add(item);  // add item to collection; view is updated via event 'add'
    },
    
    appendItem: function(item){
      var itemView = new ItemView({
        model: item
      });
      $('ul', this.el).append(itemView.render().el);
    }
  });
  
  var listView = new ListView();  // instantiate main app view
})(jQuery);
</code></pre>

<h4 id="a-idhwmodelactioncreate-model-actionsa"><a id="hwmodelaction">Create Model actions</a></h4>

<p>We use <code>Backbone.sync</code> to override persistence storage (so we can do <code>Model.destroy()</code>).  In our <code>ItemView</code> we now have two clickable events for each <code>Item</code> (swap and delete).  </p>

<pre><code>(function($){  // creates a self-executing wrapper

  // `Backbone.sync` allows use of `Model.destroy()` without raising an error
  Backbone.sync = function(method, model, success, error){
    success();
  }

  var Item = Backbone.Model.extend({
    defaults: {
        part1: 'hello',
        part2: 'world'
    }
  });
  
  var List = Backbone.Collection.extend({
    model: Item
  });

  var ItemView = Backbone.View.extend({
    tagName: 'li', // name of (orphan) root tag in 'this.el'; tag to be created
    
    // ItemView now respond to two clickable actions for each item `swap` and `delete`
    events: {
      'click span.swap': 'swap',
      'click span.delete': 'remove'
    },

    initialize: function(){
      _.bindAll(this, 'render', 'unrender', 'swap', 'remove');  // every function that uses 'this' as the current object should be here

      this.model.bind('change', this.render);
      this.model.bind('remove', this.unrender);
    },

    render: function(){
      $(this.el).html('&lt;span style="color:black;"&gt;'+this.model.get('part1')+' '+this.model.get('part2')+'&lt;/span&gt; &amp;nbsp; &amp;nbsp; &lt;span class="swap" style="font-family:sans-serif; color:blue; cursor:pointer;"&gt;[swap]&lt;/span&gt; &lt;span class="delete" style="cursor:pointer; color:red; font-family:sans-serif;"&gt;[delete]&lt;/span&gt;');
      return this;  // for chainable calls, like .render().el 
    },

    unrender: function(){
      $(this.el).remove();
    },

    swap: function(){
      var swapped = {
        part1: this.model.get('part2'),
        part2: this.model.get('part1')
      };
      this.model.set(swapped);
    },

    remove: function(){
      this.model.destroy();
    }
  });

  var ListView = Backbone.View.extend({  // our main app's view
    el: $('body'),  // attaches 'this.el' to an existing element

    events: {
        'click button#add': 'addItem'
    },
    
    initialize: function(){  // automatically call upon instantiation; do all bindings except for UI events (e.g. clicks)
      _.bindAll(this, 'render', 'addItem', 'appendItem'); // every function that uses 'this' as the current object should be here

      this.collection = new List();
      this.collection.bind('add', this.appendItem);  // collection event binder

      this.counter = 0;  // total number of items added so far
      this.render();  // not all views are self-rendering; this one is
    },

    render: function(){
      var self = this;  // save reference to 'this' so it can be accessed from within the scope of the callback
      $(this.el).append("&lt;button id='add'&gt;Add list item&lt;/button&gt;");
      $(this.el).append("&lt;ul&gt;&lt;/ul&gt;");
      _(this.collection.models).each(function(item){
        // in case collection is not empty
        self.appendItem(item);
      }, this);
    },

    // addItem now works with just the models/collections
    addItem: function(){
      this.counter++;
      var item = new Item();
      item.set({
        part2: item.get('part2') + this.counter  // modify item defaults
      });
      this.collection.add(item);  // add item to collection; view is updated via event 'add'
    },
    
    appendItem: function(item){
      var itemView = new ItemView({
        model: item
      });
      $('ul', this.el).append(itemView.render().el);
    }
  });
  
  var listView = new ListView();  // instantiate main app view
})(jQuery);
</code></pre>

<h2 id="a-idapiintegrationapi-integrationa"><a id="apiintegration">API Integration</a></h2>

<p>One of Backbone’s biggest advantages is that it is pre-configured to sync with a RESTful API.  The API talks through a <strong>Collection</strong> by specifying the <strong>url</strong> of your resource endpoint and calling <code>fetch()</code> to get your data.  Once you get your data, you can do GET, POST, DEL, etc.</p>

<pre><code>var Books = Backbone.Collection.extend({
  url: '/books'
});
</code></pre>

<h4 id="a-idapimappingsapi-mappingsa"><a id="apimappings">API (Mappings)</a></h4>

<p>Here’s how the <strong>Collection</strong> and <strong>Model</strong> components map to <strong>REST</strong> resources.</p>

<pre><code>GET  /books/  ... collection.fetch();
POST /books/  ... collection.create();
GET  /books/1 ... model.fetch();
PUT  /books/1 ... model.save();
DEL  /books/1 ... model.destroy();
</code></pre>

<h4 id="a-idapijsonapi-json-dataa"><a id="apijson">API (JSON data)</a></h4>

<p>When fetching raw JSON data from an API, <strong>Collection</strong> populates itself with data as an <strong>array</strong> while <strong>Model</strong> populates itself with data as an <strong>object</strong>.</p>

<pre><code>[{"id": 1}, {"id":2}]     ... a Collection with a couple of items
{"id": 1, "name": "Will"} ... a Model with a couple of attributes
</code></pre>

<h4 id="a-idapifetchapi---collectionsfetcha"><a id="apifetch">API - <code>Collections.fetch()</code></a></h4>

<p><code>Collections.fetch()</code> is used to fetch an entire collection of models from a server as a JSON array by sending a HTTP GET request to the URL specified by the collection’s <strong>url</strong> property.</p>

<pre><code>// Create Model
var Todo = Backbone.Model.extend({
  defaults: {
    title: '',
    completed: false
  }
});

// Create Collection
var TodosCollection = Backbone.Collection.extend({
  model: Todo,
  url: '/todos'  // specify 'url' for the HTTP request
});

var todos = new TodosCollection();  // instantiate
todos.fetch();  // sends HTTP GET to '/todos'
</code></pre>

<p>Note: it might be a good idea to do <code>todos.fetch().then()</code> to specify what to do after <code>fetch()</code> is completed.</p>

<h4 id="a-idapisaveapi---save-and-collectionscreatea"><a id="apisave">API - <code>save()</code> and <code>Collections.create()</code></a></h4>

<p>With <code>fetch()</code> we were able to get an entire collection of models, but we cannot save models individually (instead of as a group).  When we save a model, we call on the model’s <code>save()</code> method, which checks if the model is a new instance:</p>

<ol>
  <li>If the model is a new instance that was created in the browser (i.e. does not have an id), then an HTTP POST is sent to the collection’s URL.</li>
  <li>If the model is not a new instance (i.e. has an id already), we construct a URL by appending the model’s id to the collections URL and sends and a HTTP POST is sent to the server.</li>
</ol>

<p>Note: If we want to save time, we can use <code>Collection.create()</code> to create a new model, add it to the collection, and send it to the server in a single method call.</p>

<pre><code>// Create Model
  var Todo = Backbone.Model.extend({
    defaults: {
      title: '',
      completed: false
    }
  });
  
// Create Collection
var TodosCollection = Backbone.Collection.extend({
  model: Todo,
  url: '/todos'  // specify 'url' for the HTTP request
});

var todos = new TodosCollection();  // instantiate
todos.fetch();  // sends HTTP GET to '/todos'

var todo2 = todos.get(2);
todo2.set('title', 'go fishing');
todo2.set('completed': true);
todo2.save();  // sends HTTP PUT to '/todos/2'
</code></pre>

<p>Note: When a model is <code>saved()</code>, the <code>validate()</code> method will automatically be called and will trigger an <code>invalid</code> event if the model validation fails.</p>

<h4 id="a-idapiparseapi---parsea"><a id="apiparse">API - parse</a></h4>

<p>If the API does not return data in a format you like, you can specify the <code>parse()</code> function.</p>

<h4 id="a-idapidestroyapi---destroy-and-collectionsremovea"><a id="apidestroy">API - <code>destroy()</code> and <code>Collections.remove()</code></a></h4>

<p>A model can be deleted from the collection and server by calling <code>destroy()</code>.  <code>destroy()</code> sends an HTTP DELETE to the collection’s URL.  If you want to only remove a model from a collection (and not delete it on the server), you can use <code>Collection.remove()</code>.</p>

<pre><code>// Create Model
  var Todo = Backbone.Model.extend({
    defaults: {
      title: '',
      completed: false
    }
  });
  
// Create Collection
var TodosCollection = Backbone.Collection.extend({
  model: Todo,
  url: '/todos'  // specify 'url' for the HTTP request
});

var todos = new TodosCollection();  // instantiate
todos.fetch();  // sends HTTP GET to '/todos'

var todo2 = todos.get(2);
todo2.destroy();  // sends HTTP DELETE to '/todos/2' and removes from collection
</code></pre>

<h4 id="a-idapioptionsapi-optionsa"><a id="apioptions">API options</a></h4>

<p>Each RESTful API method accepts a variety of options, including success and error callbacks.  See the Backbone.js documentation for full descriptions of supported options.</p>

<pre><code>// Save partial information using HTTP PATCH by using API options
model.clear().set({id: 1, a: 1, b: 2, c: 3, d: 4});
model.save();
model.save({b: 2, d:4}, {patch: true});
console.log(this.syncArgs.method);  // 'patch'
</code></pre>

<h4 id="a-idapiprimerapi-primera"><a id="apiprimer">API Primer</a></h4>

<p>From the creator of Backbone.js, this is the best resource on how to really work with Models and Collections.</p>

<p>https://github.com/jashkenas/backbone/wiki/Backbone,-The-Primer</p>


</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
      <li><span>17 Oct 2015</span> <a href="/2015/10/17/django.html">Django Web Framework</a></li>
    
      <li><span>04 Oct 2015</span> <a href="/2015/10/04/testing.html">Testing</a></li>
    
      <li><span>03 Oct 2015</span> <a href="/2015/10/03/django-rest-framework.html">Django REST Framework (DRF)</a></li>
    
  </ul>
</div>

    <div class="footer">
      <div class="contact">
        <p>
          William Liu<br/>
        </p>
      </div>
      <div class="contact">
        <p>
          <a href="http://github.com/williamqliu/">github.com/williamqliu</a><br/>
        </p>
      </div>
    </div>
  </div>

  <!--
  <a href="http://github.com/williamqliu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  -->

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36019998-1', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Google Analytics end -->
</body>

</html>