<!DOCTYPE html>
<html>
<head>
   <title>Testing</title>
   <meta name="William Liu" content="William Liu" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- LaTeX support -->
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
     MathJax.Hub.Config({
     extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
    });
   </script>

</head>

<body>
  <div class="site">
    <div class="title">
      <a href="/">William Liu</a>
    </div>

    <div id="post">
<h2 id="testing">Testing</h2>

<hr />

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#summary">Summary</a>
    <ul>
      <li><a href="#functionaltests">Functional Tests</a></li>
      <li><a href="#unittests">Unit Tests</a></li>
      <li><a href="#integrationtests">Integration Tests</a></li>
    </ul>
  </li>
  <li><a href="#runtests">Running Tests</a></li>
  <li><a href="#loadingdata">Loading Data</a></li>
  <li><a href="#fixtures">Fixtures</a>
    <ul>
      <li><a href="#dumpdata">Dumping DB data into Fixtures</a></li>
      <li><a href="#loaddata">Loading Data from Fixtures</a></li>
      <li><a href="#fixturesunittest">Using Fixtures in Unit Tests</a></li>
    </ul>
  </li>
  <li><a href="#doubles">Doubles</a></li>
  <li><a href="#mocking">Mocking</a></li>
  <li><a href="#stubbing">Stubbing</a></li>
</ul>

<h2 id="a-idsummarysummarya"><a id="summary">Summary</a></h2>

<p>Testing your code is important because it creates scaffolding for large projects.  When you build new features, you also ensure that you don’t destroy something else accidentally.  There’s a lot of different libraries including:</p>

<ul>
  <li>Unittest</li>
  <li>Doctest</li>
  <li>Nose</li>
  <li>Unittest2</li>
  <li>mock</li>
</ul>

<p>Tests can be broken down into the following:</p>

<ul>
  <li>Functional Tests  (what the user sees)</li>
  <li>Unit Tests  (what the programmer sees)</li>
  <li>Integration Tests  (the two above work together)</li>
</ul>

<p>Some good rules to follow by:</p>

<ul>
  <li>Change the code OR change the tests, don’t change both at once</li>
  <li>Tests should always fail first, then build </li>
</ul>

<h4 id="a-idfunctionaltestsfunctional-testsa"><a id="functionaltests">Functional Tests</a></h4>

<p><strong>Functional tests</strong> (aka Acceptance Test, End-To-End Test, Black Box Test) tests many methods and may interact with dependencies like databases or web services.  You don’t look at the code, but test as if you were a user (instead of the programmer).  Examples include running selenium to simulate opening a browser, clicking on things.  A few simple functional test might pop up a Firefox browser and check the browser title:</p>

<pre><code>from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://localhost:8080')

assert 'Django' in browser.title
</code></pre>

<p>Functional tests should be driving the development.  We make a failing functional test first.  Then we add unit tests.  Then we add code that fixes the unit tests, that then ultimately fix the functional tests.</p>

<p>Normally functional tests are stored outside of a Django app because users don’t know how the apps are structured.  Users just want to see that the entire website works as a whole.</p>

<p>You can write your own <code>unittest.TestCase</code> for your functional tests, but you’re basically building from the ground up with things like <code>setUp</code> and <code>tearDown</code>.  Instead, you should use <code>django.test import LiveServerTestCase</code> where most of that functionality is done (e.g. you don’t have to hardcode the <code>localhost port 8000</code> and can instead use )</p>

<ul>
  <li>In Django, a <strong>Client</strong> returns a <strong>response</strong> and simulates the entire request-response cycle (so takes longer).  This uses Middleware.  Django has a specific <code>from django.test import Client</code> while some prefer to use a framework like <code>Selenium</code>.  See below on how Client should be used (which is different than Selenium’s goal of testing rendered HTML and the behavior of web)</li>
</ul>

<h4 id="a-idunittestsunit-testsa"><a id="unittests">Unit Tests</a></h4>

<p><strong>Unit tests</strong> ensure that a small part of your code works in isolation.  Each of these should be able to run alone and within a test suite regardless of the order called.  This can mean that each test loads a fresh set of fields using <strong>setUp()</strong> and <strong>tearDown()</strong> methods.  Dependencies are all mocked up.  These tests should be fast and small.  If they’re not small, break it up to smaller pieces.  The idea is that you are looking at this program from the perspective of the programmer (and not the user).  To run this test, you normally do a <code>manage.py test</code> where files like <code>tests.py</code> would sit inside your apps.</p>

<ul>
  <li>You can use <strong>Client</strong> to fake a complete request-response cycle (main difference is that it returns a <strong>response</strong>).  This simulates the behavior of a browser.  It will create a request object, pass it through the WSGI handler where it will resolve the url, call the appropriate middleware, then run the view.</li>
  <li>In Django, a <strong>RequestFactory</strong> is used to create a <strong>request</strong> instance that can be used as the first argument to any view.  RequestFactory creates requests and nothing more; this means it doesn’t use Middleware.  This is a slightly reduced subset of the test client API.  This allows you to test views like any other function (as a black box, with exact known inputs, testing for specific outputs).</li>
</ul>

<h4 id="a-idintegrationtestsintegration-testsa"><a id="integrationtests">Integration Tests</a></h4>

<p>So how does this work?  We write a function test that fails, then we write a unit test that fails.  We then write some code to pass the unit test.  Then we check that the functional test is working.  If it doesn’t, we write some more unit tests/code until the functional test passes.</p>

<p>We can use <strong>integration tests</strong> to ensure that all the above tests work well together.</p>

<h2 id="a-idruntestsrun-testsa"><a id="runtests">Run Tests</a></h2>

<p>Execute tests using the following commands:</p>

<ul>
  <li><code>python manage.py test myfunctionaltests</code> assuming folder with ‘myfunctionaltests’ and ‘test_functional.py’ file</li>
  <li><code>python manage.py test myunittests</code> assuming folder with ‘myunittests’ and ‘test_unit.py’ inside folder</li>
  <li><code>python manage.py test</code> to run all tests</li>
</ul>

<h2 id="a-idloadingdataloading-dataa"><a id="loadingdata">Loading Data</a></h2>

<p>You can load data (into and out of databases, into test files, etc) a few different ways.  These include using <strong>fixtures</strong> and <strong>mocks</strong>.</p>

<h2 id="a-idfixturesfixturesa"><a id="fixtures">Fixtures</a></h2>

<p>To create a state for your database, we can create <strong>fixtures</strong>.  </p>

<h4 id="a-iddumpdatadumping-db-data-into-fixturesa"><a id="dumpdata">Dumping DB Data into Fixtures</a></h4>

<p>In Django, if your app has data in the database, you can create fixtures by using the <code>dumpdata</code> command:</p>

<pre><code>python manage.py dumpdata myapp --format=yaml &gt; myapp/fixtures/db_data.yaml
</code></pre>

<p>This fixture is really just a serialization of your database data into a yaml file.  By default the fixture is in JSON format.  You can edit this feature in the text editor if you’d like.</p>

<h4 id="a-idloaddataloading-data-from-fixturesa"><a id="loaddata">Loading Data from Fixtures</a></h4>

<p>If you want to load your data (into the db or the command line) from your Fixtures, we call this <strong>deserialization</strong>.  You can do this with:</p>

<pre><code>from django.core.management import call_command
call_command("loaddata", "' + db_data.yaml' + '", verbosity=8)
</code></pre>

<p>This is the same as (except this is from the command line):</p>

<pre><code>python manage.py loaddata db_data.yaml
</code></pre>

<h4 id="a-idfixturesunittestusing-fixtures-in-unit-testsa"><a id="fixturesunittest">Using Fixtures in Unit Tests</a></h4>

<pre><code>from django.test import TestCase
from myapp.models import Stuff

class StuffTests(TestCase):
    # Note: this is the fixture
    # model: myapp.stuff
    # pk: 1
    # fields: {content: lots of stuff, query: test, title: test, url: 'test'}
    fixtures = ['mine']

    def testFlufflyAnimals(self):
        s = Stuff.objects.get(pk=1)
        self.assertEquals(s.query, 'test')
        s.query = 'who cares'
        s.save()
</code></pre>

<p>For more on testing the serializer and deserializer: http://django-testing-docs.readthedocs.org/en/latest/serialization.html</p>

<p>More specifically, you can use the DRF’s APIRequestFactory for testing serializers and deserializers.</p>

<h2 id="a-iddoublesdoublesa"><a id="doubles">Doubles</a></h2>

<p>When you’re testing individual units, you’ll realize that some parts rely on others.  This is where we get into <strong>test doubles</strong>, which are kinda like stunt doubles in movies.  While this isn’t a real name, we can define what kind of test objects we have, which can include:</p>

<ul>
  <li><strong>Dummy</strong> objects are passed around, but never used (i.e. just used to fill parameter lists)</li>
  <li><strong>Fake</strong> objects actually have working implementations, but take some shortcuts which makes them unsuitable for production environments (e.g. in memory database like sqlite)</li>
  <li><strong>Stubs</strong> provide canned answers to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</li>
  <li><strong>Mocks</strong> are objects programmed with expectations which form a specification of the calls they are expected to receive.</li>
</ul>

<p>An example between <em>stubs</em> and <em>mocks</em> would be if we tested sending out an email.  Stubs would send out the fake email and verify it was sent.  Mocks would take it a step further and also check if we sent it to the right person, with the right contents, etc.</p>

<h2 id="a-idmockingmockinga"><a id="mocking">Mocking</a></h2>

<p>By <strong>mocking</strong> objects, you can simulate objects and mimic the behavior of real objects in a controlled way.  For example, you would create a mock object to test the behavior of some other object.  Some reasons for mocking an object include:</p>

<ul>
  <li>the object supplies non-deterministic results (e.g. the current time or temperature)</li>
  <li>the state is difficult to reproduce (e.g. a network error)</li>
  <li>it is slow (e.g. querying a complete database)</li>
  <li>it does not yet exist (e.g. reliant on another object)</li>
</ul>

<p>An example is if we mock an alarm clock going off at 7:00am, we wouldn’t want to wait till 7:00am just to test.  Another example is if we post to facebook, we don’t want to actually have to post to facebook.</p>


</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
      <li><span>17 Oct 2015</span> <a href="/2015/10/17/django.html">Django Web Framework</a></li>
    
      <li><span>03 Oct 2015</span> <a href="/2015/10/03/django-rest-framework.html">Django REST Framework (DRF)</a></li>
    
      <li><span>02 Oct 2015</span> <a href="/2015/10/02/tmux.html">Tmux</a></li>
    
  </ul>
</div>

    <div class="footer">
      <div class="contact">
        <p>
          William Liu<br/>
        </p>
      </div>
      <div class="contact">
        <p>
          <a href="http://github.com/williamqliu/">github.com/williamqliu</a><br/>
        </p>
      </div>
    </div>
  </div>

  <!--
  <a href="http://github.com/williamqliu"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  -->

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-36019998-1', 'auto');
    ga('send', 'pageview');
  </script>
  <!-- Google Analytics end -->
</body>

</html>